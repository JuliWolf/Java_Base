/**
 * Примитивные типы данных
 *
 */

ТИП     |Размер в байтах |     Диапазон значений     |     Значение по умолчанию     |     Описание
byte    |     1          |   -128 .. 127             |     0                         | Самое маленькое целое — один байт
short   |     2          |   -32,768 .. 32,767       |     0                         | Короткое целое, два байта
int     |     4          |   -2*10 в 9 .. 2*10 в 9   |     0                         | Целое число, 4 байта
long    |     8          |   -9*10 в 18 .. 9*10 в 18 |     0L                        | Длинное целое, 8 байт
float   |     4          |   -10 в 38 .. 10 в 38     |     0.0f                      | Дробное, 4 байта
double  |     8          |   -10 в 308 .. 10 в 308   |     0.0d                      | Дробное, двойной длины, 8 байт
boolean |     1          |   true, false             |     false                     | Логический тип (только true & false)
char    |     2          |   0 .. 65,535             |     '\u0000'                  | Символы, 2 байта, все больше 0
NaN     |                |                           |                               | Не число


// ---------------- BYTE

byte[] buffer = new byte[1024*1024];
FileInputStream sourceFile = new FileInputStream("c:\\data.txt");
FileOutputStream destFile = new FileOutputStream("c:\\output.txt");
while (true)
{
   int size = sourceFile.read(buffer);   // читаем данные из файла в буфер
   destFile.write(buffer, 0, size);      // записываем данные из буфера в файл

   // прекращаем копирование, если буфер заполнен не полностью
   if (size < buffer.length) break;
}
sourceFile.close();
destFile.close();


// ---------------- CHAR

Тоже относится к числовому типу, так как хранит коды символов

char a = 'A'; // Переменная а будет содержать латинскую букву А.
char a = 65; // Переменная а будет содержать латинскую букву А. Ее код как раз 65.
char a = '\u0041'; // Переменная а будет содержать латинскую букву А.


// ---------------- FLOAT

дробное число 987654.321 можно представить как 0.987654321*106.
Поэтому в памяти оно будет представлено как два числа
987654321 (мантисса — значащая часть числа) и
6 (экспонента — степень десятки)

float a = (float) 123.456789; // 123.45679
float a = (float) 12345.9999; // 12346.0
float a = (float) -123.456789E-2; // -1.2345679

float f = 32.5f; // Нужно добавлять f  или делать явное приведение типов, чтобы получить тип float`453


// ---------------- INFINITY

System.out.println( 100.0 / 0.0 ); // Infinity
System.out.println( -100.0 / 0.0 ); // -Infinity

double a = 1d / 0d; // a == Infinity

Если бесконечность умножить на число, получится бесконечность.
Если к бесконечности добавить число, получится бесконечность.


// ---------------- NAN

если разделить бесконечность на бесконечность будет NaN
Любая операция с NaN дает NaN

System.out.println(0.0 / 0.0); // NaN



/* ---------------- Приведение типов ---------------- */

Расширение типа - присвоение меньшего типа большему

byte a = 5;
short b = a;
int c = a + b;
long d = c * c;


Сужение типа - присвоение большего типа меньшему (тип) выражение

// Скомпилируется отлично:

long a = 1;
int b = (int) a;
short c = (short) b;
byte d = (byte) c;

// Произодет потеря данных

long a = 1000000; // a == 1000000
int b = (int) a; // b == 1000000
short c = (short) b; // c == 16960
byte d = (byte) c; // d == 64


Для преобразования типов char и short всегда нужно использовать преобразование типов

В char нельзя сохранить отрицательные числа, которые могут храниться в short.
А в short нельзя сохранить числа больше 32,767, которые могут храниться в char.


// Выражения с двумя разными типами данных

// a будет расширена до типа long и только затем произойдет сложение.

int a = 1;
long b = 2;
long c = a + b;

*** Типы byte, short, char всегда преобразовываются в тип int при взаимодействии между собой.
Не зря же тип int считается стандартным целочисленным типом.

*** Операция приведения типа имеет довольно высокий приоритет.

// Оператор приведения типа будет применен только к переменной a, которая и так имеет тип byte. Код не скомпилируется.

byte a = 1;
byte b = 2;
byte c = (byte) a * b;

Правильно:
byte c = (byte) (a * b);


/**
 * Переменные - ссылки
 */

 ТИП     |     Размер     |     Значение по умолчанию     |     Описание
 String  |     4/8        |     null                      | строка
 Object  |     4/8        |     null                      | строка


Размер всех переменных-ссылок (независимо от типа) одинаков и составляет 4 байта
*** Но! Если ваше приложение запущено на 64-х разрядной Java-машине, размер всех ссылок будет 8 байт (64 бита).


*** как передаются данные в методы в Java? - по значению
 В Java все однозначно: примитивные типы хранят значения, ссылочные тоже хранят значение — ссылку.
 Все дело в том, что считать значением переменной.


// ---------------- OBJECT

 String s = new String("Привет"); // Создает объект типа String
 Scanner console = new Scanner(""); // Создает объект типа Scanner
 int[] data = new int[10]; // Создает объект типа int[]: контейнер на 10 элементов типа int

*** Созданные объекты называют объектом класса или экземпляром класса, а класс — классом объекта


// ---------------- STRING

*** Все методы объекта String  возвращают новый объект, а не модифицируют текущий


// ---------------- ARRAY

Всегда является объектом
