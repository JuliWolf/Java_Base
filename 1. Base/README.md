https://github.com/johnivo/job4j/blob/master/interview_questions/Core.md#4-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-JDK

+ [Основы](#Основы)
+ [ООП](#ООП)
+ [Процедурная Java](#процедурная-java)
+ [ООП в Java](#ООП-в-Java)
+ [Исключения](#Исключения)
+ [Сериализация и копирование](#сериализация-и-копирование)
+ [Дженерики](#дженерики)
+ [Коллекции](#коллекции)
+ [База данных](#База-данных)
+ [Concurrency](#Concurrency)
+ [Spring](#Spring)
+ [Stream](#Stream)
+ [SOLID](#SOLID)
+ [Java 8](#Java-8)


## Основы

+ [1. Какие преимущества у Java?](#1.-Какие-преимущества-у-Java?)
+ [2. Какие недостатки у Java?](#2.-Какие-недостатки-у-Java?)
+ [3. Что такое JVM, JDK, JRE? В чем отличия?](#3.-Что-такое-JVM,-JDK,-JRE?-В-чем-отличия?)
+ [4. Что такое byte code?](#4.-Что такое byte code?)
+ [5. Что такое загрузчик классов classloader?](#5.-Что такое загрузчик классов classloader?)
+ [5. Что такое загрузчик классов classloader?](#5.-Что такое загрузчик классов classloader?)
+ [6. Что такое JIT?](#6.-Что-такое-JIT?)
+ [7. Что такое String[] args в методе main()?](#7.-Что-такое-String[]-args-в-методе-main()?)
+ [8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?](#8.-Что-такое-пакеты,-зачем-они-нужны?-Какие-пакеты-по-умолчанию-подключены?)

### 1. Какие преимущества у Java?
- Основное преимущество  - кроссплатформенность
- Огромный выбор библиотек под любые задачи
- Автоматическое управление памятью
- Многопоточность
- ООП


### 2. Какие недостатки у Java?
- Низкая скорость в сравненни с С и С++
- Требует много памяти
- Нет поддержки низкоуровневого программирования (например указателей)
- Планирование новой программы занимает много времени из-за ООП
- Многословность


### 3. Что такое JVM, JDK, JRE? В чем отличия?

   `JVM(Java Virtual Machine)` — это часть платформы Java, которая исполняет программы.
   программа, предназначенная для выполнения байт-кода. Преимущество - "Write once, run anywhere"

   `JRE(Java Runtime Environment)` — это элемент Java, расположенный на диске, создающий и запускающий JVM
   это пакет всего необходимого для запуска скомпилированной Java программы

   `JDK(Java Development Kit)` - позволяет разработчикам создавать Java-программы, которые могут выполняться и запускаться посредством JVM и JRE. JDK = JRE + компилятор
   включает в себя около 40 различных тулов (компилятор, лаунчер приложений, java debugger etc.


### 4. Что такое byte code?
    - это стандартное промежуточное представление [en], в которое может быть переведена компьютерная программа автоматическими средствами.


### 5. Что такое загрузчик классов classloader?
   Это объект, которые отвечает за загрузку классов. ClassLoader  это абстрактный класс


### 6. Что такое JIT?
   Если в программе присутствуют части кода, которые выполняются много раз,</br>
   то их можно скомпилировать один раз в машинный код, чтобы в будущем ускорить их выполнение.</br>
    - Ускорение работы программы достигается за счет увеличения потребления памяти (чтобы хранить этот код)


### 7. Что такое String[] args в методе main()?
   Это аргументы которые будут переданы из консоли


### 8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
   Для разграничения областей видимости и группировки классов</br>

   По умолчанию подключено lang

## END ---------------- Основы ----------------


## ООП

+ [1. Что такое ООП?](#1.-Что-такое-ООП?)
+ [2. Что такое объект?](#2.-Что-такое-объект?)
+ [3. Что такое класс?](#3.-Что-такое-класс?)
+ [4. Какие преимущства у ООП?](#4.-Какие-преимущства-у-ООП?)
+ [5. Какие недостатки у ООП?](#5.-Какие-недостатки-у-ООП?)
+ [6. Основные принципы ООП](#6.-Основные-принципы-ООП)
+ [7. Что такое ассоциация?](#7.-Что-такое-ассоциация?)
+ [8. Что такое агрегация?](#8.-Что-такое-агрегация?)
+ [9. Что такое композиция?](#9.-Что-такое-композиция?)
+ [10. Раннее и позднее связывание](#10.-Раннее-и-позднее-связывание)
+ [11. Можно ли переопределить private или static методы?](#11.-Можно-ли-переопределить-private-или-static-методы?)
+ [12. Можно ли менять модификатор доступа у унаследованных методов,свойств](#12.-Можно-ли-менять-модификатор-доступа-у-унаследованных-методов,свойств)
+ [13. Можно ли получить доступ к нестатическому полю из статического метода?](#13.-Можно-ли-получить-доступ-к-нестатическому-полю-из-статического-метода?)

### 1. Что такое ООП?
   - ООП - это объектно ориентированное программирование.
   - Это программирование с помощью классов и объектов


### 2. Что такое объект?
   - Объект  - это сущность, одновременно содержащая данные и поведения.
   - Объекты - это строительные блоки объектно-ориентированных программ.

```
Данные объектов - состояние объекта(атрибуты).
Пример: атрибуты работника (SocialSecurityNumber, Gender, DateOfBirth)

Поведения объектов - что объект может сделать( в процедурных языках определяется процедурами, функциями и подпрограммами) (методы).
Пример: методы работника (setGender() getGender() - для установки и получения пола).
```
### 3. Что такое класс?
   Класс - это "чертеж" объекта


### 4. Какие преимущства у ООП?
- Модульность - инкапсуляция объектов в себе упрощает разработку, уменьшает количество ошибок
- Реюзабельность кода
- Высокая скорость разработки - классы и интерфейсы в ООП могут легко трансформироваться в подобие полноценных библиотек
- Расширяемость - ООП легко развивать, дополнять и менять. Этому способствует независимая модульная структура
- Простота восприятия
- Безопасность - инкапсулированных код недоступен извне, поэтому поломать что-либо сложнее
- Гибкость - полиморфизм позволяет быстро адаптировать ООП-код под свои нужды


### 5. Какие недостатки у ООП?
- Объекты во главе угла - из-за особенного внимания к объектам, меньше внимания уделяется вычислениям и алгоритмам
- Негативно сказывается на скорости компиляции кода


### 6. Основные принципы ООП
- Инкапсуляция
- Наследование
- Полиморфизм
- Абстракция - каждый верхний слой над объектом (классы) более абстрактный


### 7. Что такое ассоциация? 
https://i.stack.imgur.com/BBNy5.png

   Объекты между собой никак не связаны. Первый объект может принадлежать сразу нескольким объектам одновременно и не управляться ими</br>
   Наследование позволяет одному классу наследовать от другого, поэтому мы можем абстрагировать атрибуты и поведения для общих классов


### 8. Что такое агрегация?
   Это вложенность одного класса в другой, но при этом класс обертка не управляет сроком жизни вложенного объекта</br>
   части могут принадлежать более чем одному целому за раз, и целое не управляет существованием и временем жизни частей

- Например, отношения между человеком и его домашним адресом. У каждого человека есть свой адрес. Однако этот адрес может принадлежать более чем одному человеку за раз</br>
  Однако этот адрес не управляется человеком — адрес существовал до того, как человек заселился и будет существовать после того, как человек выселится.


### 9. Что такое композиция?
это отношения части-целого. Часть в композиции может быть частью только одного объекта за раз

- Например: сердце, которое является частью тела одного человека, не может быть частью тела ещё одного человека одновременно.


### 10. Раннее и позднее связывание
- Раннее - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода
- Позднее - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.


### 11. Можно ли переопределить private или static методы?
    нельзя


### 12. Можно ли менять модификатор доступа у унаследованных методов,свойств
- Понижать уровень доступа нельзя
- Повышать уровень доступа можно


### 13. Можно ли получить доступ к нестатическому полю из статического метода?
    нет

## END ---------------- ООП ----------------

## Процедурная Java

1. Какие примитивные типы данных есть в Java?

   ТИП     |Размер в байтах |     Диапазон значений     |     Значение по умолчанию     |     Описание
    -------|----------------|---------------------------|-------------------------------|--------------
   byte    |     1          |   -128 .. 127             |     0                         | Самое маленькое целое — один байт
   short   |     2          |   -32,768 .. 32,767       |     0                         | Короткое целое, два байта
   int     |     4          |   -2*10 в 9 .. 2*10 в 9   |     0                         | Целое число, 4 байта
   long    |     8          |   -9*10 в 18 .. 9*10 в 18 |     0L                        | Длинное целое, 8 байт
   float   |     4          |   -10 в 38 .. 10 в 38     |     0.0f                      | Дробное, 4 байта
   double  |     8          |   -10 в 308 .. 10 в 308   |     0.0d                      | Дробное, двойной длины, 8 байт
   boolean |     1          |   true, false             |     false                     | Логический тип (только true & false)
   char    |     2          |   0 .. 65,535             |     '\u0000'                  | Символы, 2 байта, все больше 0
   NaN     |                |                           |                               | Не число


2. Какими значения по умолчанию инициализируются поля примитивных типов
   данных?
   - Числовые и char = 0
   - Булево = false


3. Что такое автоупаковка и автораспаковка?

   - Автоупаковка (autoboxing) — это процесс автоматической инкапсуляции данных простого типа, такого как int или double, в эквивалентную ему оболочку типа, как только понадобится объект этого типа. При этом нет необходимости в явном создании объекта нужного типа.
   - Автораспаковка (auto-unboxing) — это процесс автоматического извлечения из упакованного объекта значения, когда оно потребуется.


4. Что такое класс-обертки?

   Обертка - это специальный класс, который хранит внутри себя значение примитива

   - int - Integer
   - short - Short
   - long - Long

   Классы обертки позволяют невелировать недостатки, которые есть у примитивных типов
   Самый очевидный из них — примитивы не имеют методов.

6. Что такое cast?
   Приведение типов


6. Что такое пул интов?
   Java хранит пул интов [-128; 127]


7. Какие нюансы у строк в Java?
    - Класс реализует Serializable и CharSequence
    - Это final класс, который не может иметь потомков
    - это immutable класс, его объекты не могут быть изменены после создания. Любые операция приводят к созданию нового объекта
    - Благодаря неизменяемости - это потокобезопасный класс
    - Каждый объект может быть преобразован в строку с помощью toString


8. Что такое пул строк?
   - Это набор сктрок, который хранится в Java heap
   - Пул строк возможет благодаря неизменяемости строк в Java
   - Пул строк помогает экономить большой объем памяти

   Когда мы используем двойные кавычки для создания строки, сначала строка ищется в пуле с таким же значением, если находится
   то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка

   Когда мы используем оператор new мы принуждаем создать новую строку


9. Почему строки не рекомендуется использовать для хранения паролей?

    Строка хранится в пуле строка до тех пор пока она не будет удалена сборщиком мусора

     Даже если мы думаем, что закончили работу с паролем, он остается доступен в памяти

     Лучше использовать массив символов для хранения пароля, так как мы можем его очистить после того, как закончим с ним работать


10. Почему строка неизменяемый и финализированный класс?
    - Строковый пул возможен только потому, что строка неизменна. Таким образом сохраняется много места в памяти
    - Изменяемая строка - это угроза приложению: Например параметры для соединения с бд передаются в виде строки и х нельзя изменить
    - Неизменная строка безопасна для многопоточности
    - Ее hashCode кэшируется в момент создания и нет необходимости расчитывать его снова. Это делает строку отличным кандидатом для ключа в Map
      и ее обработка будет быстрее


11. Что делает метод intern() в классе String?
    - Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную нашему объекту, тогда возвращается ссылка на строку из пула
    - Этот метод возвращает строкуЮ которая имеет то же значение, что и текущая строка, но гарантирует что это будет строка из пула уникальных строк


12. Можно ли использовать строку в конструкции Switch
    - строки switch чувствительны к регистру
    - оператор использует метод `String.equals()` для сравнения полученного значения со значениемя case, поэтому необходима проверка на null
    - согласно Java 7 для строк в switch компилятор формирует более эффективный байт код


13. Что такое инвариантность и ковариантность
    - Ковариантность - случай когда более конкретный тип S может быть подставлен вместо более обобщенного типа Т
    - Инвариантность - случай когда подставлять можно только определенный тип


14. В чем разница между String, StringBuffer, StringBuilder?</br>
    _String_ - это класс для создания объекта типа String</br>
    _StringBuffer_ - это класс, который используется для изменения строк и обеспечения безопасности потоков (синхронизирован)</br>
    _StringBuilder_ - это класс класс, который используется для изменения строк, не обеспечивающих потокобезопасность (не синхронизирован)


15. Каким образом переменные передаются в метода?</br>
    _Примитивные_ - копируется само значение</br>
    _Ссылочные_ - копируется ссылка


16. В чем разница между Hashtable и HashMap?</br>
    _Hashtable_ - все методы синхронизированные</br>
    _HashMap_ - все методы не синхронизированные

## END ---------------- Процедурная Java ----------------

## ООП в Java

1. Какие виды есть в java?
    - Вложенные внутренние классы
    - Вложенные статические классы
    - Локальные классы
    - Анонимные классы


2. Что такое вложенные классы? В каком случаях они применяются?</br>
   Это классы, которые создаются внутри других классов</br>
   Бывает 2 вида вложенных классов: Нестатические и статические</br></br>

   Нестатические в свою очередь делятся на подвиды
    - Анонимные
    - Локальные
      </br></br>
   Внутреннние классы - это классы для выделения в программе некой сущности, которая неразрывно связана с другой сущностью</br>
   Например - Руль, сиденьк, педали - это составные части велосипеда</br></br>

    - Объект внутреннего класса не может существовать без объекта "внешнего" класса
    - У объеккта внутреннего класса есть доступк переменных "внешнего" класса
    - Объект внутреннего класса нельзя создать в статическом методе "внешнего" класса
    - Внутренний класс не может содержать статические переменные и методы


3. Что такое "локальный класс"? Каковы его особенности?</br>
   Это классы  объявленные внутри других методов</br></br>

    - Локальные классы могут работать только с final переменными метода
    - Локальные классы нельзя объявлять с модификаторами доступа
    - Локальные классы обладают доступом к переменным метода


4. Что такое "анонимные классы"? Где они применяются?
    - Это обычные нестатические вложенные классы, в более кратком виде. Объявляется класс и сразу создается экземпляр

   Используются когда
    - тело класса является коротким
    - нужен только ожин экземпляр класса
    - класс используется в месте его создания или сразу после него
    - имя класса не важно


5. Каким образом из вложенного класса получить доступ к полю внешнего класса?</br>
   Для получения доступа из внутреннего класса к экземпляру его внешнего класса необходимо в ссылке указать имя класса и влючевое слово this
   OuterClass.this


6. Что такое перечисления (enum)?</br>
   enum - это класс java.lang.Enum</br>
   Элементы перечисления - экземпляры enum-класса, доступные статически


7. Как проблема ромбовидного наследования решена в Java?</br>
   В Java нет множественного наследования</br>
   Но есть возможность использовать неограниченное количество интерфейсов


8. Что такое конструктор по умолчанию?</br>
   Если конструктор у класса не задан, то по умолчанию создастся пустой конструктор без реализации, которые будет вызывать super


9. Могу ли быть приватные конструкторы? Для чего они нужны?</br>
   Может</br>
   Защищает класс от явного превращения в экземпляр. Используется в шаблоне "Одиночка"</br>
   Обычно для создания объекта требуется вызвать другой метод


10. Что такое классы-загрузчики и динамическая загрузка классов?</br>
    Есть 2 типа загрузки классов
    - Статическая
    - Динамическая

    Статическая - это привычная загрузка, которая производится автоматически. При запуске программы загрузчик классов рекрсивно загружает все классы, встречающиеся в программе, начиная с main</br>
    Динамическая - производится через метод Class.forName(String className) или с использованием ClassLoader</br>
    Динамическая загрузка классов имеет смысл, когда требуется загрузить класс во время выполнения программы, когда нужно заменить класс, изменив, например, какую-то логику, не рестартуя приложения</br></br>

    // загружаем класс через ClassLoader</br>
``` 
ClassLoader classLoader = MainClass.class.getClassLoader();
Class aClass = classLoader.loadClass("com.jenkov.MyClass");
myClass = (MyClass) aClass.newInstance();
```

11. Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?
    - Конструктор по-умолчанию не принимает никаких параметров
    - Конструктор копирования принимает в качестве параметра объект класса
    - Конструктор с параметрами принимает на фход параметры</br></br>

    Конструктор копирования
```
// конструктор копирования
public Circle(Circle circle) {
    this(circle.getName(), circle.getArea(), circle.getPerimeter()); //будет вызван конструктор с параметрами ниже
}
```

12. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
    - private (закрытый) - доступ не предоставляется никому, кроме методов этого класса
    - default, package, friendly - доступ по умолчанию. Открытый внутри собственного пакета
    - protected (защищённый) - доступ в пределах пакета и классов наследников
    - public (открытый) - доступен всем и везде


13. Что означает модификатор static?</br>
    Это значит что моле или метод будет относиться к классу, а не к инстансу(объекту) класса


14. Могут ли нестатические методы перегрузить статические?</br>
    Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.


15. Могут ли быть переопределены статические методы?</br>
    Переопределить базовый статический метод нельзя: Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс


16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределение метода?</br>
    нет, можно только расширить


17. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы</br>
    Можно менять модификатор доступа в стороны расширения</br></br>

    - У переопределенного метода должны быть те же аргументы, что и у метода родителя.
    - У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
    - Модификатор доступа у переопределенного метода также не может отличаться от «оригинального» в меньшую сторону

18. Могут ли классы быть статическими</br>
    Да


19. Что такое сигнатуры методы?</br>
    Это имя + параметры (порядок параметров имеет значение)


20. Что такое переопределение и перегрузка методов?</br>
    переопределение - изменение тела унаследованного метода</br>
    перегрузка - несколько вариантом методов с разными аргументами


21. Когда вызывается конструктор?</br>
    ПРи созданииэксземпляра класса


22. Что означает ключевое слово final?</br>
    final - у метода, у переменной, у класса</br></br>

    Класс нельзя унаследовать</br>
    Метод нельзя переопределить</br>
    Свойство нельзя переопределить


23. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?</br>
    Да</br>
    Создать экземпляр абстрактного класса нельзя, но все-равно можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе


24. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</br>
    Это контракт описывающий возможности</br>
    По умолчанию все методы объявляются как public abstract (начиная с Java 8 - default)</br>
    Поля - public static final


25. Может ли интерфейс наследоваться от интерфейса?</br>
    Интерфейс может наследоваться только от интерфейсов


26. Что такое дефолтные методы интерфейсов?</br>
    Это реализация метода по умолчанию


27. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default методами?</br>
    Никак. Будет ошибка на этапе компиляции.


28. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
    - конструктор созданного класса объекта
    - конструктор родителя созданного класса объекта (неявный super в начале конструктора класса)


29. Какие бываю и зачем нужны блоки инициализации?
    - Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов.
    - Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора.
    - Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса.</br></br>

    Бываю статические и нестатические</br>
    static {}</br>
    {}</br></br>

    Зачем?
    - более читабельный код
    - внутри блоков можно не только присваивать значение, но и писать команды (вывод в косоль, циклы и т.д.)


30. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
    - Все статические блоки от первого предка - до последнего наследника
    - попарно динамические блоки инициализации и конструктор (от предка до последнего потомка)


31. Что произойдет, если в блоке инициализации возникнет ошибка?</br>
    - Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется,</br>
    чтобы объявления этих исключений были перечислены в throws всех конструкторов класса.</br>
    Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции. (java.lang.ExceptionInInitializerError;)</br></br>

    - остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте.</br>
       Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</br></br>
    
       ( тип ошибки - Если возникшее исключение - наследник Error,</br>
         то в обоих случаях будет выброшено java.lang.Error.</br>
         Исключение: java.lang.ThreadDeath - смерть потока.</br>
         В этом случае никакое исключение выброшено не будет.</br>
       )


32. Какие методы есть у object</br>
    wait — поток переходит в режим ожидания в течение указанного времени.</br>
    equals — сравнивает объекты.</br>
    clone — клонирование объекта</br>
    notify — просыпается один поток, который ждет на “мониторе” данного объекта.</br>
    finalize — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет. (deprecated)</br>
    toString — возвращает строковое представление объекта.</br>
    hashCode — возвращает хеш-код</br>
    notifyAll — просыпаются все потоки, которые ждут на “мониторе” данного объекта.


33. Что такое метод equals(). Чем он отличается от операции ==. (https://habr.com/ru/post/168195/)</br>
    При сравнении с помощью `==` идет сравнение по ссылкам</br>
    При сравнении по equals() идет сравнение по состоянию объектов</br></br>

    Хем-код - это число. Битовая строка фиксированной длины, полученная из массива произвольной длины (ограничена типом int)


34. Каким образом реализованы методы equals() и hashCode()</br>

    hashCode() - `public native int hashCode();` - реализация на языке С++</br>

    equals() -
```
public boolean equals(Object obj) {
    return (this == obj);
}
```

35. Правила переопределения equals()</br>
    При переопределении обязательно необходимо переопределить hashCode()


36. Правила при переопределении hashCode</br>
    у них должен быть реализован метод для создания ключа и значения должны быть финализированы


37. Могут ли у разных объектов быть одиннаковые hashCode() ?</br>
    Да, это называется коллизией


38. Чем a.getClass().equals(A.class) отличается от instanceOf A.class</br>
    - метод getClass () всегда возвращает точно тот класс, от которого был порожден объект.


39. Может ли метод быть одновременно abstract и final?</br>
    нет


40. Функиональные интерфейсы</br>
    Функциональным считается интерфейс с одним не реализованным (абстрактным) методом
    + интерфейсы, которые создаются след образом

```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);
}
```
@FunctionalInterface - сообщает компилятору, что данный интерфейс функциональный и должен содержать не более одного метода

* Абстрактные интерфейсы могут иметь методы, которые не входят в ограничения одного метода

Статические методы
```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);

    staitc <T> boolean isNotNull(T t) {
        return t != null;
    }
}
```
+ методы по умолчанию
```
@FunctionalInterface
public interface Converter<T, N> {
  N converter (T t);

  staitc <T> boolean isNotNull(T t) {
    return t != null;
  }

  default void writeToConsole (T t) {
    System.out.println("Текущий объем - " + t.toString());
  }
}
```
### END ---------------- ООП в Java ----------------


## Исключения

1. Опишите иерархию исключений?

|     |                   | Object       |            |
|-----|-------------------|-----------|------------|
|     |                   | Throwable    |            |
|  Error   |              |       Exception       |   |
|  OutOfMemoryError   | StackOverflowError |RuntumeException | IOExeption |
|  LinkageError   |                   |IllegalArgumentExceprion |            |


3. Расскажите про обрабатываемые и необрабатываемые исключения?
    - контролируемые исключения (checked) - это ошибки, которые можно и нужно обрабатывать в программе
    - неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) - не трубуют обязательной обработки, но при желании можно обработать
    - исключения времени выполнения (RuntimeExceptions, потомок класса Exception)


4. Какой оператор позволяет принудительно выбросить исключение?</br>
   throw


5. Как создать собственное (пользовательское) исключение?</br>
   Создать класси у наследоваться от Exception


6. В каком случае не выполнится блок finally</br>
   Если в блоке try или catch есть System.exit


7. Может ли метод main выбросить исключение во вне и е</br>
   да, в стандартный вывод ошибок будет выведено сообщение об ошибке, в котором будет указано имя потока</br>
   Если нет запущенных потоков-недемонов, то программа будет завершена, иначе будет ждать завершения всех потоков


8. В каком порядке следует обрабатывать исключения в catch блоках?</br>
   В порядке от наследников к родителю


9. Что такое try-with-resources?</br>
   Это оператор, который решает проблему с обязательным вывзовом close()


10. Что произойдет есть исключение будет выброшено из блока catch после чего другое исключенгие будет выброшено из блока finally</br>
    В finally можно реализовать вложенны try-catch


11. В чем разница между Exception и Error?</br>
    Error - невозмжноо починить</br>
    Exception - можно обработать ошибку


12. Можно ли использовать проверяемые исключения в лямбда функциях</br>
    Нет


## END ---------------- Исключения ----------------

## Сериализация и копирование

1. Что такое сериализация и как она реализована в Java?</br>
   Сериализация  - это процесс сохранения объекта в последовательный байт</br>
   Десериализация  - это процесс восстановления объекта в байт


2. Для чего нужна сериализация?</br>
   Сериализация нужна для передачи объектов


3. Опишите процесс сериализации/десериализации с использованием Serializable</br>
   При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:</br></br>

    - запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
    - рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
    - запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
    - рекурсивную запись объектов, которые являются полями сериализуемого объекта.</br></br>

   При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.</br></br>

   При имплементации интерфейса Serializable у класса появляется идентификатор версии.</br>
   Он вычисляется по содержимому класса - полям, порядку объявления, методам.</br>
   Соотвественно при десериализации поля, порядок и методы должны совпадать.</br>
   Чтобы избежать возможных ошибок можно вручную задать для класса идентификатор версии (long serialVersionUID)


4. Какие поля не будут сериализованы при сериализации?</br>
   Те, которые не помечены как transient</br></br>

   Поля с модификатором final сериализуются как и обычные.</br>
   За одним исключением – их невозможно десериализовать при использовании `Externalizable`.</br>
   Ибо final-поля должны быть инициализированы в конструкторе,</br>
   а после этого в readExternal изменить значение этого поля будет невозможно.</br>
   Соответственно – если вам необходимо сериализовать объект, имеющий final-поле,</br>
   вам придется использовать только стандартную сериализацию.


5. Как изменить стандартное поведение сериализации/десериализации?
    - Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации.</br>
      Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`.</br>
      Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.</br></br>

    - Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,</br>
      а не метод по умолчанию :</br>
      ~ writeObject() - запись объекта в поток;</br>
      ~ readObject() - чтение объекта из потока;</br>
      ~ writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;</br>
      ~ readResolve() - позволяет заменить на себя другой объект после чтения.


6. Как создать собственный протокол сериализации?</br>
   Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:</br>
   `writeExternal()` и `readExternal()`


7. В чем проблема сериализации Singleton?</br>
   Проблема в том, что после десериализации мы получим другой объект.</br>
   Как этого избежать:</br>
    - явный запрет сериализации
    - определение метода с сигнатурой (default/public/private/protected/) Object readResolve() throws ObjectStreamException


8. Как происходит сериализация
    1. Унаследоваться от интерфейса Serializable</br>
       [Serializable] - маркерный интерфейс

    2. Определить переменную
       private static final long serialVersionId = 1;</br>
       Данные поле будет содержать уникальный идентификатор версии сериализованного класса</br></br>

   При сериализации значение serialVersionId сравнивается с десериализованным значением</br>
   ! Если значения не совпадут будет выброшено исключение InvalidClassException

    3. Сериализайия внутренних классов</br>
       Все вложенные классы должны имплементировать интерфейс Serializable

    4. Для того, чтобы свойство не сериализовалось, необходимо использовать ключевое слово transient


## END ---------------- Сериализация и копирование ----------------

## Дженерики

1. Что такое дженерики?</br>
   Дженерики - это типы с параметром


2. Для чего нужны Дженерики?</br>
   Дженерики помогают упростить реализацию принципа ООП - Полиморфизм


3. Что такое сырые типы?</br>
   Raw type - это класс-дженерик, из которого удалили его тип</br>
   Возможность превратить в Raw type оставили для совмещения со старым кодом


4. Что такое `wildcard`?</br>
   Upper Bounded Wildcards - <? extends Animal> - в такой объект ничего кроме null положить нельзя</br>
   Это значит, что метод принимает на вход коллекцию объектов класса Animal либо объектов любого класса-наследника Animal</br></br>

   Lower Bounded Wildcards - <? super Animal> - Можно положить:</br>
   superZoo.encage(new Elephant("Джимбо", 3));</br>
   superZoo.encage(new Animal("", 1))</br>
   Это значит, что метод принимает на вход коллекцию объектов класса Animal либо любого другого класса предка Animal


5. Расскажите про принцы PECS ***</br>
   Producer Extends Consumer Super - если у нас есть некая коллеция, типизированная wildcard с верхней границей (extends) то это "продюсер"

## END ---------------- Дженерики ----------------

## Коллекции

1. Что такое коллекция?</br>
   Коллекции - это наборы однородных элементов


2. Расскажите про иерархию коллекций?</br></br>

   Первая иерархия</br>
   Collection делится на подколлекции:</br>
    - Set - описывает такую структуру как множество, содержащее неупорядоченные уникальные элементы. Есть стандартные реализации - TreeSet, HashSet,LinkedHashSet
    - List - структура данных, которая хранит упорядоченную последовательность объектов. Реализации - ArrayList, Vector, LinkedList
    - Queue - Хранит элементы в виде очереди, которая следует правилу First In First Out. Реализации - LinkedList, PriorityQueue</br></br>

   Вторая иерархия</br>
   Map делится на подколлекции:
    - HashTable, LinkedHashMap, TreeMap


3. Почему Map - это не Collection, в то время как List и Set являются Collection?</br>
   Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».


4. В чем разница между классами java.util.Collection и java.util.Collections?</br>
   java.util.Collections - набор статических методов для работы с коллекциями.</br></br>

   java.util.Collection - один из основных интерфейсов Java Collections Framework.


5. Что такое «fail-fast поведение»?</br>
   fail-fast означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом</br></br>

   Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.</br></br>

   Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):</br>
    - при изменении коллекции счетчик модификаций так же изменяется;
    - при создании итератора ему передается текущее значение счетчика;
    - при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.


6. Какая разница между fail-fast и fail-safe?</br>
   В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.


7. Чем различается Enumeration и Iterator?</br>
    - с помощью Enumeration нельзя добавлять/удалять элементы;
    - в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
    - Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.


8. Как между собой связаны Iterable, Iterator и «for-each»?</br>
   Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.


9. Сравните Iterator и ListIterator.</br>
    - ListIterator расширяет интерфейс Iterator
    - ListIterator может быть использован только для перебора элементов коллекции List;
    - Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next().</br>
      Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
    - ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
    - При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove().
      Iterator не поддерживает данного функционала.


10. Как поведёт себя коллекция, если вызвать iterator.remove()?</br>
    Если вызову iterator.remove() предшествовал вызов iterator.next(),</br>
    то iterator.remove() удалит элемент коллекции, на который указывает итератор,</br>
    в противном случае будет выброшено IllegalStateException().


11. Чем Set отличается от List?</br>
    List допускает дубликаты</br>
    Set имеет только уникальные значения


12. Расскажите про интерфейс Set</br>
    Интерфейс Set расширяет интерфейс Collection</br>
    Представляет набор уникальных элементов</br></br>

    Реализации:
    - SortedSet - NavigableSet
    - AbstractSet - HashSet - LinkedHashSet
    - TreeSet


13. Что будет если добавлять элементы в TreeSet по возрастанию?</br>
    Так как в основе TreeSet будет красное черное дерево, поэтому все элементы буду сбалансированы


14. Как устроен HashSet, сложность основных операций (16)</br>
    - Реализует интерфейс Set
    - Базовой структурой для HashSet является HashTable
    - Повторяющиеся элементы не допускаются
    - порядок элементов не сохранится, так как для сохранения элементов происходит на основании хеш-кода


15. Как устроен LinkedHashSet сложность основных операций
    - Реализует интерфейс Set
    - Базовой структурой для LinkedHashSet является LinkedList
    - Порядок элементов будет сохранен
    - Повторяющиеся элементы не допускаются


16. Как устроен TreeSet сложность основных операций
    - Реализует интерфейс Set
    - Базовой структурой для TreeSet является TreeMap
    - Используется природный порядок элементов, основанный на Comparator


17. Расскажите про интерфейс List</br>
    Интерфейс List расширяет интерфейс Collection</br>
    Представляет собой список


18. Как устроен ArrayList сложность основных операций
    - Это список реализованный на основе массива
    - Доступ к элементу по индексу за константное время
    - Доступ к элементам по значению за линейное время
    - Вставка в конеч за константное время
    - Удаление из списка варьируется
    - Вставка элемента варьируется
    - необходимо одно единое пространство для хранения


19. Как устроен LinkedList сложность основных операций
    - Это двусвязный список, основанный на объектах с ссылками между ними
    - на получение элемента по индексу необходимо линейное время
    - На добавление и удаление потребуется константное время
    - На поиск позиции и вставки или удаления за константное время


20. Почему LinkedList реализует и List и Deque</br>
    - LinkedList позволяет добавлять элементы в начало и в конец списка, что хорошо согласуется с Deque


21. Как перестроить Связанный список в HashTable</br>
    Переопределить hashCode и использовать  "адрес в память"


22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?</br>
    у них должен быть реализован метод для создания ключа и значения должны быть финализированы</br>
    equals и hashCode


## END ---------------- Коллекции ----------------

## База данных

1. В чем разница между Statement и PreparedStatement?</br>
   Statement - не защищен</br>
   PreparedStatement - переданные параметры защищены от sql инъекций


2. План исполнения запроса</br>
   Пример Postgresql</br></br>

   Explain [(OPTION [,...])]
    - Analyze [boolean] - запрос выполнится и составит план выполнения
    - Verbose [boolean] - добавит дополнительную информацию
    - Costs [boolean] - добавит стоимость каждого запроса
    - Buffer [boolean] - определяет число блоков с диска и из кеша
    - Timing [boolean] - Время запуска и время выполнения на каждом узле
    - Summary [boolean]
    - Fomat [TEXT|XML|JSON|YAML] - для подготовки отчета


3. Как работает индекс в таблице
    1. Таблица без индексов выглядит как куча (Heap). При запросе будет сканироваться вся таблица
    2. Преимущества индексов
       - Повышают скорость поиска информации и производительность запросов
    3. Недостатки
       - Требуют много места на диске и в оперативной памяти
       - Замедляют производительность системы (медленнее выполняются операции вставок, обновлений, удалений)
    4. Структура
       - Состоят из:
       - наборов страниц
       - узлов, имеющих древовидную структуру, иерархическую
       - Хранятся в виде сбалансированных B-деревьев
       - При создании индекса создаются указатели на строки таблицы, которые удовлетворяют условию
    5. Виды индексов
       - Составной (несколько колонок)
       - Функциональные или индекс по выражению
       - Обычный, по одной колонке
    6. Типы индексов
       - B-tree (дефолтное)
       - Hash - хранятся в 32-битной хеш код, полученный из значения индексируемого столбца
         Обрабатывает только операции равенства (медленнее чем B-tree в Posgtresql)
       - Gist - это инфраструктура, в которой можно реализовать множество стратегий индексирования</br>
       Подходит для вычисления гео данных, расстояние, пересечение площадей</br>
       Есть триграм, позволяет искать по вхождению и индексировать (regexp)
       - Sp-gist - это инфраструктура, которая поддерживает различные виды поиска.
         Позволяет реализовать несбалансированные дисковые структуры данных
       - Gin - инвертированные индексы, которые подходят для данных, содержащих компонентные значения, например массивы
       - Brin - хранят сводки о значениях, хранящихся в последовательных диапазонах физических блоков таблицы


4. Блокировка таблицы</br>
   Виды блокировок
    - Разделяемые (shared locks) - блокировка на чтение
    - Монолитные (exclusive locks) - блокировка на чтение и запись

   --- Табличная блокировка (exclusive lock)

   `Lock Tables`

   | +         | -      | 
   |---------------------|-----------------------------|
   | требуют небольшого объема памяти  | Отстуствует параллелизм   |
   | быстрая работа при блокировке большого количества таблиц     | Все остальные операции ждут |
   | быстрая работа при операциях Group by или при полном сканировании |   |
   | Подходит когда данные меняются редко                      |     |


   --- Пользовательская блокировка - конкретной строки
   ```SELECT GET_LOCK(‘key’, 10); - key & timeout```

| +         | -                                                                            | 
   |------------------------------------------------------------------------------|-----------------------------|
| одна блокировка для всех приложений  | Небезопасно использовать с репликацией на основе SQL-выражений               |
| Блокировка на уровне приложения | Из-за возможности вызвать сколько угодно lock опасность множества блокировок |
| Подобие транзакции |                                                                              |
| Меньше издержки чем у транзакции |                                                                              |


   ---Глобальная блокировка

   При применении
    - конфликтует с другими блокировками
    - Вызывает снятие всех предыдущих блокировок

| +         | -      | 
   |---------------------|-----------------------------|
| Для получения резервной копии  | Нужно быть аккуратным и знать что делать  |
| Эту команду использует для быстрого alter таблиц | Может быть довольно длительной, так как будет дожидаться выполнения всех Select запросов |
| не так затратна как полная остановка сервера, так как большая часть информации кешируется |   |
| Используется для восстановления |     |

   ---Построчные блокировка

| +         | -      | 
   |---------------------|-----------------------------|
| Лучшее управление конкуретным доступом  | Максимальные издержки |
| Позволяет одновременно выполнять несколько изменений одного ресурса | Приводит к взаимоблокировки |
| Позволяет заблокировать одну строку на долгое время | Работают медленнее табличных блокировок если используется большая часть таблицы|
| Меньше конфликтов блокировок |  Работают намного медленней при полном сканировании таблицы или для группировок Group by |


6. Транзакции
    - Каждая транзация начинается с инструкции
      Begin Transaction и заканчивается
      Commit или Rollback

    - Транзакция - это совокупность операций над базов, которые могут быть либо выполнены все вместе либо не будет выполенна ни одна из них

    - Транзакции основаны на многоверсионной модели (Multiversion Concurrency Control)
        - каждый Sql оператор видит так называемый снимок данных (snapshot)
        - Снимок - это не физическая копия всей базы, это несколько чисел, которые идентифицируют текущую транзакцию и те транзакции,
          которые уже выполнились в момент начала текущей

   **Свойства транзакий**
    - Атомарность - транзакция либо выполняется полностью, либо не выполняется совсем
    - Согласованность - после успешного выполнения транзакции база данных должны быть приведена из олного состояние в другое
    - Изолированность - Во время выполнения транзации другие транзакции должны оказывать минимальное влияние на нее
    - Долговечность - После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных

   **Риски**
   
      - _Потерянное обновление (lost update)_ - Когда разные транзакции одновременно изменяют ожни и те же данные, то после фиксации изменений может оказаться,
      что одна транзакция перезаписала другую
      - Грязное чтение (dirty read) - Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась.
      Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе
      - _Неповторяющиеся чтение (non-repeatable read)_ - При повторном чтении тех же данных в рамках одной транзакции оказывается, что другая транзакция успела изменить
      и зафиксировать эти данные
      - _Фантомное чтение (phantom read)_ - Транзакция выполняет сборку данных и параллельно другая транзакция добавляет строки
      - _Аномалия сериализации (serialization anomaly)_ - Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одной
      из возможных вариантов упорядочения этих транзакций

   **Уровни изоляции**

   - Read uncommitted (dirty read)
   - Read committed - только зафиксированные изменения
   - Repeatable read (phantom read) - видим вставленные записи
   - Serializable - самый безопасный


7. Пул соединений к БД</br>
   Это шаблон доступа к данным, основной целью которого является снижение накладных расходов, связанных с выполнение подключений к бд</br></br>

   Этапы соединения с БД</br>
    - Открытие соединения с БД с помощью драйверов
    - Открытие TCP  сокетов для чтения/записи
    - Чтение/запись данных через сокет
    - Закрытие соединения
    - Закрытие порта</br></br>

   Так как открытие соединения с БД это трудозатратная операция, мы можем настроить ряд соединений при старте приложения,</br>
   которыми мы будем пользоваться в процессе


8. Функция vs Процедура</br></br>

   **Функции**
    - Имеет возвращаемый тип и возвращаемое значение
    - Использование DML(insert, update,delete) запросов внутри функции невозможно.
      Разрешены только SELECT запросы
    - Не имеет выходных аргументов
    - Вызов хранимой процедуры из функции невозможен
    - Вызов функции внутри SELECT запросов возможен

```
   //создает или заменяют функцию с именем
   CREATE [or REPLACE] FUNCTION function_name
   (param_list)
   // возвращаемый тип
   RETURN return_type
   LANGUAGE plpgsql
   as
   $$
   // объявление переменных
   DECLARE
   -- variable declaration
   // начало запроса
   BEGIN
   -- logic
   // окончание запроса
   END;
   $$
```
   **Процедура**
   - Не имеет возвращаемого типа, но имеет выходные аргументы 
   - Использование DML запросов возможно 
   - Имеет входные и выходные аргументы 
   - Использование или управление транзакциями возможно в хранимой процедуре 
   - Вызов процедуры из SELECT запросов невозможен
```
   CREATE [or REPLACE] PROCEDURE procedure_name
   (param_list)
   LANGUAGE language_name
   AS
   $$
   -- stored-procedure-body
   $$
```
## END ---------------- База данных ----------------

## Concurrency

1. В чем разница между sleep() и wait()?</br>
   wait - освобождает монитор</br>
   sleep- не освобождает монитор

## END ---------------- Concurrency ----------------

## Spring

1. Что такое `Autowiring` и как работает</br>
   **IOC** - Inversion of control</br>
   делегирование части обязанностей внешнему компоненту</br></br>

Бин - создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект</br></br>

ApplicationContext - Это сердце спринга. Как правило, он создается в самом начале работы приложения</br></br>

По умолчанию каждый бин имеет внутриспринговое свойство 'scope' в значении 'singleton',</br>
то есть создается ровно один экземпляр класса
```
Определение бина
ИЛИ В файле xml
<bean id="product" class="main.java.Product"></bean>
// Указание места сканирования
<context:component-scan base-package="main"/>
// Поднять контекст из файл xml
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```
Как работает</br>
При поднятии контекста создается бин-объект всех объектов, которые помечены аннотациями `@Component`, `@Service`, `@Controller`, `@Repository`</br>
Когда спринг видит аннотацию @Autowired он начинает искать подходящий бин. Если бин только один, то он без проблем его инжектит</br></br>

Аннотация `@Autowired` можно ставить
- На поле
- На сеттеры
- На определенные методы</br></br>

Если оддинаковых бинов несколько
- Для определения конкретного бина необходимо использовать аннотацию '@Qualifier("dependency1") ServiceDependency'
- Для использования всех бинов
```
@Autowired
public void setDependency(ServiceDependency[] dependencies)
```

2. Плюсы и минусы `@Autowired`

| +  | -   | 
|-----|-----|
|  Требует меньше кода  | Менее экспрессивный, чем явное инжектирование |
|  Уменьшает время разработки | Усложняет автонаписание инструкций |
|    | Множетвенные инъекции могут пересекаться с названием конкруктора|

   **Ограничения**
   - Явные зависимости и аргументы конструктора и свойства всегда переписывают инъекции
   - Инъекции через констркутор всегда переписывают инекции свойств
   - Нельзя переписать примитивы
   - Сложно ориентироваться при большом количестве инъекций


4. В чём разница между @Component, @Service и @Repository аннотациями?
   **@Component** - универсальный компонент</br></br>

   **@Repository** - компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.class</br>
   умеет перехватывать спецефичные для платфомы исключения и повторно генерирует их как одно из унифицированных непроверенных исключений Spring</br>
   Бин проксируется и ему добавляются exception handlers</br></br>

   **@Service** - фасад для некоторой бизнес логики</br></br>

   **@Controller** - класс, в котором указываются контроллеры приложения</br>
   Для получения объекта body внутри методов необходимо дополнительно использовать аннотацию @RequestBody</br>
   Используется для возврата view
```
@Controller
@RequestMapping("books")
public class SimpleBookController {

    @GetMapping("/{id}", produces = "application/json")
    public @ResponseBody Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```
   **@RestController** - Это специализированная сервис контроллера. Включает в себя @Controller и @ResponseBody аннотации</br>
   Необходим при написании REST запросов
```
@RestController
@RequestMapping("books-rest")
public class SimpleBookRestController {
    
    @GetMapping("/{id}", produces = "application/json")
    public Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```
   **@Configuration** - класс для настройки приложения, объявления бинов


5. AOP</br>
   Аспектно-ориентированное программирование - это парадигма программирования, являющейся в дальнейшем развитием процедурно и объектно-ориентированного программирования</br></br>

   **Join Point** - это точки наблюдения, присоединения к коду, где планируется введение функциональности

```
@Pointcut("execution(* com.example.spring._10.AOP_order.dao.*.*(..)))")
public void forDaoPackage () {}
```
   **Pointcut** - Это срез, запрос точек присоединения</br></br>

   **Advice**  - набор инстракций выполняемых на точках среза (может быть несколько для одного Pointcut)
   - Before - Перед вызовом метода
   - After - После вызовом метода
   - After returning - После возврата значения
   - After throwing - В случае exception
   - After finally - В случае выполения блока finally
   - Around - можно сделать пред, пост обработку перед вызовом метода, а также вообще обойти вызов метода

   **Aspect**</br>
   модуль, в котором собраны описанные Pointcut и Advice


6. Spring boot</br>
   В базе используется сервер Tomcat</br></br>

   Без Spring Boot
    - Импортировать необходимые Spring-модули
    - Импортировать библиотеку web-контейнеров (в случае web-приложения)
    - Импортировать сторонние библиотеки (Hibernate, Jackson)
    - Искать версии, совместимые со Spring
    - Конфигурировать компонент DAO, такие как источник данных, управление транзакциями ит т.д.
    - Конфигурировать компоненты web-слоя, такие как диспетчер ресурсов, view resolver
    - Определить класс, который щагрузит все необходимые конфигурации</br></br>

   Основные особенности
    1. Управленияе зависимостями
    2. Автоматическая конфигурация
    3. Встроенные контейнеры сервлетов

- Spring упаковывает необходимые сторонние зависимости для каждого типа приложения посредством starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa)
- Spring автоматически конфигурирует зарегистрированные бины в зависимости от подключенного стартера
- Каждое Spring-boot приложение включает встроенные web-сервлеты
  Spring ам настроивает контейнер сервлетов.
  Приложение может запускаться как jar-файл</br></br>

Основной класс приложения

**@SpringBootApplication** - включает в себя
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan


6. Hibernate ленивая инициализация (LazyInitialization)</br>
   @OneToMany(fetch=FetchType.Lazy)

Для акцивации такой связи необходимо проверить било ли инициализировано</br>
boolean success = Hibernate.isInitialized(products);</br></br>

Инициализировать</br>
Hibernate.initialize(post);


7. RestTemplate
```
@Bean
public RestTemplate restTemplate (RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofMills(3000))
        .setReadTimeout(Duration.ofMills(3000))
        .build();
}

@Bean
public RestTemplate restTemplate () {
    RestTemplate restTemplate = new RestTemplate();
    return restTemplate;
}
```

8. Как активировать/деактивировать Бин</br>
   @Profile("dev")</br>
   @Profile("production")</br></br>

Добавляет возможность включать/выключать бины для разных окружений</br></br>

В файлу 'application.properties'</br>
spring.profiles.active=dev</br></br>

Дополнительно в интерфейсе 'ConfigurableEnvironment' можно установить настройки активных профилей вызвав 'SpringApplication.setAdditionalProdiles(...)'


9. Spring Filters

Для создания фильтры необходимо создать бин и заинжектить интерфейс 'Filter'
```
@Component
@Order(1)
public class TransactionFilter implements Filter {
    @Override
    public void doFilter (
        ServlerRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOExeprion, ServlerException {
        HTTPServlerRequest req = (HTTPServlerRequest) request;
        
        LOG.info("Staring a transaction for req: {}");
        
        req.getRequestURI();
        
        chain.doFilter(request, response);
        
        LOG.info("Commiting a transaction for req: {}");
        
        req.fetRequestURI();
    }
}
```
Мы можем извлечь

`url = req.getRequestURI();`

`method = req.getMethod();`

`contentType = res.getContentType();`

Регистрация бина
```
@Bean
public FilterRegistrationBean<RequestResponseLoggingFilter> loggingFilter () {
FilterRegistrationBean<RequestResponseLoggingFilter> registrationBean = new FilterRegistrationBean<>();

    registrationBean.setFilter(new RequestResponseLoggingFilter());
    registrationBean.addUrlPattern("users");
    registrationBean.setOrder(2);

    return registrationBean;
}
```

10. Как работает Spring изнутри</br>

    **Ключевые понятия**
    - Бины - это обычный объект, который живет внутри DI-контейнера
    - DI-контейнер - Ключевой и фундаментальный механизм Spring.</br></br>
    
    Спринт - это по сути набор бинов, связанных вместе через DI контейнер</br>
    При конфигурации например 'OAuth' в 'application.properties' спринт предоставляет бин 'OAuth2RestTemplate'</br>
    При этом этот бин при обращении к внешнему API будет знать, куда и как пойти, чтобы получить OAuth токен</br>
    как его обновлять, в какое место нашего запроса его добавлять и т.д.</br>
    То есть контейнер - это механизм общения между нашим кодом и библиотеками, подключенными к проекту</br></br>

    Использование инъекций зависимостей не подразумевает создания интерфейсов для каждого компонента.</br></br>

    - Контекст - Представлен интерфейсом 'ApplicationContext'. Позволяет реагировать на различные события,</br>
      которые происходят внутри приложения, управлять жизненным циклом

    - Конфигурация - описание доступных бинов
      Бины могут быть описаны как в одном файле, так как и в разных

    - Сканирование компонентов - спринг сканирует приложений на предмет таких аннотаций как @Component, @Service и т.д. и создает из них бины</br>
      при этом это считается неявным изменением контекста приложения</br></br>

    **Spring boot**</br></br>

    _Автоконфигурация_</br></br>

    Это набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении.</br>
    Можно сказать, что сам Embedded Servler Container - это тоже еще один бин</br></br>

    - Включается аннотацией '@EnableAutoConfiguration'
    - Работает в последнюю очередь, после регистрации пользовательских бинов
    - Принимает решение о конфигурации на основании доступных в classpath классов, свойств в 'application.properties'
    - Можно включать и выключать разные аспекты автоконфигурации
    - Всегда отдает приоритет пользовательским бинам</br></br>

    **Условия и порядок регистрации бинов**</br></br>

    Логика при регистрации бинов управляется набором `@ConditionalOn*` аннотаций </br>
    Можно указать, чтобы быин создавался при наличии в classpath (@ConditionalOnClass), </br>
    наличии существующего бина (@ConditionalOnBean), отсутствии бина (@ConditionalOnMissingBean)

    ```
    @SpringBootApplication
    public class DemoApplication {
        public static void main(String[] args) {
            SpringApplication.run(DemoApplication.class, args);
        }
    }
    ```
    1. **@SpringBootApplication** - мета аннотация, алиас для нескольких аннотаций
    - @SpringBootConfiguration
    - @EnableAutoConfiguration
    - @ComponentScan</br></br>

    1. **SpringApplication.run()**</br>
        это хелпер, который используя список предоставленных конфигураций создает 'ApplicationContext',</br>
        конфигурирует его, выводит баннер в консоли и засекает время старта приложения</br>

    2. **AnnotationConfigEmbeddedWebApplicationContext** - Наследник Spring Boot</br>
        знает о embedded servlet container-ах и умеет их запускать

    3. **@EnableAutoConfiguration** - включает автоконфигурацию
    ```
    @Import(EnableAutoConfigurationImportSelector.class)
        public @interface EnableAutoConfiguration {
        ...
    }
    ```

    `EnableAutoConfigurationImportSelector` - это конфигурация, которая добавит несколько бинов в контекст.</br>
    Этот класс не объявляет бины сам, а использует так называемые фабрики.</br>
    Класс смотрит в файл 'spring.factories' и загружает оттуда список значений, которые являются именами классов ((авто)конфигураций),</br>
    которые Spring Boot импортирует</br></br>

    **Этапы инициализации**

    1. Парсирование конфигурациии создание 'BeanDefinition'</br>
    Задача данного этапа - это создание всех 'BeanDefinition'.</br>
    'BeanDefinition' - это специальный интерфейсы, через который можно получить доступ к метаданным будущего бина

    2. Настройка созданных 'BeanDefinition'</br>
      После первого этапа у нас имеется Map, в котром хранятся 'BeanDefinition'</br>
      Спринт дает нам возможность повлиять на то, какими будут наши бины еще до их создания,</br>
      то есть мы можем получить доступ к метаданным класса.</br>
      Для получения доступа к метаданным есть специальный интерфейс 'BeanFactoryPostProcessor'</br>
    ```
    public interface BeanFactoryPostProcessor {
    `void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
    }
    ```
    Данная фабрика содержит такие методы как 'getBeanDefinitionNames', через который можно получить все 'BeanDefinitionNames',</br>
    а потом по конкретному имени получить 'BeanDefinition' для дальнейшей обработки метаданных</br></br>

    Например, если в классе есть поля, которые должны быть заполнены из файла '.propeties' </br>
       то после постпроцессинга они будут добавлены к класс бина</br></br>

    3. Создание экземпляров бинов</br>
      Созданием экземпляров бинов занимается 'BeanFactory' при этом можно дерегировать это кастомным 'FactoryBean'</br>
      Экземпляры бинов создаются на основе ранее созданных 'BeanDefinition'</br>
      После создания бина он добавляется в Map<BeanName, Bean></br></br>

    4. Настройка созданных бинов</br>
      Интерфейс 'BeanPostProcessor' позволяет вклиниться в процесс настройки бинов, до того как они попадут в контейнер
    ```
    public interface BeanPostProcessor {
      Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // до init метода
      Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; // после init метода
    }
    ```

    * Если нужно сделать прокси над объектом, то лучше это делать в `postProcessAfterInitialization`
    * `BeanPostProcessor` обязательно должен быть бином
    

## END ----------------- Spring -----------------

## Stream

1. Стримы Общее
    1. Stream из массива</br>
       Arrays.stream(array)</br></br>

    2. Stream из ArrayList</br>
       list.stream()</br></br>

    3. Stream из Map</br>
       map.entrySet.stream()</br></br>

    4. Stream из указанных элементов</br>
       Stream.of("1", "2", "3")</br></br>

    5. Лист из указанных элементов</br>
       Arrays.asList("a1", "a2", "a3").stream()</br></br>

    6. Стрим из файла</br>
       Files.lines(Paths.get("file.txt"))</br></br>

    7. Стрим из строки</br>
       "123".chars()</br></br>

    8. Создание из Stream.builder</br>
       Stream.builder().add("a1").add("a2").add("a3").build()</br></br>

    9. Создание параллельного стрима</br>
       collection.parallelStream()</br></br>

    10. Создание бесконечного стрима</br>
        Stream.iterate(1, n -> n +1)</br></br>

    11. Создание бесконечных стримов с помощью</br>
        Stream.generate(() -> "a1"))</br></br>

   Методы
   1. Конвейерные - возвращают другой stream, то есть работают как builder
   2. Терминальные - Возвращают другой объект, такой как коллекция, примитивы, объекты, Optional</br></br>

        ! У стрима может быть сколько угодно вызовов конвейерных методов  и в конце один терминальный</br>
        При этом все конвеейрные методы выполняются лениво и пока не будет вызван терминальный, никаких действий не происходит</br>

```
Конвейерные методы
   'filter'
   collection.stream()
    .filter("a1"::equals)
    .count()

    'skip' - позволяет пропускать первые N элементов
    collection.stream()
        .skip(collection.size() - 1)
        .findFirst()
        .orElse("1")

    'distinct' - возвращает стрим без дубликатов
    collection.stream()
        .distinct()
        .collect(Collectors.toList())

    'map' - преобразует каждый элемент массива
    collection.stream()
        .map((s) -> s + "_1")
        .collect(Collectors.toList())

    'peek' - возвращает тот же стрим, но применяет функцию к каждому элементу
    collection.stream()
        .map(String::toUpperCase)
        .peek((e) -> System.out.println("," + e))
        .collect(Collectors.toList())

    'limit' - ограничивает выборку определенным количеством элементов
    collection.stream()
        .limit(2)
        .collect(Collectors.toList())

    'sorted' - позволяет сортировать значения либо в натуральном порядке либо задавая Comparable
    collection.stream()
        .sorted()
        .collect(Collectors.toList())

    'mapToInt' - аналог map, но возвращает числовой стрим
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .toArray()

    'mapToDouble'
    'mapToLong'

    'flatMap' - похоже на map, о может создавать из одного элемента несколько
    'flatMapToInt'
    'flatMapToDouble'
    'flatMapToLong'

    collection.stream()
        .flatMap((p) -> Arrays.asList(p.split(",").stream()))
        .toArray(String[]::new)

    'reduce' - позволяет выполнять агрегатные функции на всей коллекцией, возвращает одно значение для стрима (Optional)
    collection.stream()
    .reduce((s1, s2) -> s1 + s2)
    .orElse(0)
```
```
Терминальные методы

    'findFirst' - возвращает первый элемент из стрима (Возвращает Optional)
    collection.stream()
        .findFirst()
        .orElse("1")

    'findAny' - возвращает плюбой подходящий элемент из стрима (Возвращает Optional)
    collection.stream()
        .findAny()
        .orElse("1")

    'collect' - представление результатов в виду коллекций и других структур данных
    collection.stream()
        .filter((s) -> s.contains("1"))
        .collect(Collectors.toList())

    'anyMatch' - возвращает true если условие выполняется хотя бы для одного значения
    collection.stream()
        .anyMatch("a1"::equals)

    'count' - возвращает количество элементов в стриме
    collection.stream()
        .filter((s) -> s.contains("1"))
        .count()

    'noneMatch' - возвращает true если условие не выполняется ни для одного элемента
    collection.stream()
        .noneMatch((s) -> s.contains("1"))

    'allMatch' - возвращает true если условие выполняется для всех элементов
    collection.stream()
        .allMatch((s) -> s.contains("1"))

    'min' - возвращает минимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .min(String::compareTo)
        .get()

    'max' - возвращает максимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .max(String::compareTo)
        .get()

    'forEach' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
    set.stream()
        .forEach((p) -> p.append("_1"))

    'forEachOrdered' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении гарантируется
    list.stream()
        .forEachOrdered((p) -> p.append("_1"))

    'toArray' - возвращает массив значений стрима
    collection.stream()
        .map(String::toUpperCase)
        .toArray(String[]::new)
```
```
Дополнительные методы числовых стримов

    'sum' - Возвращает сумму чисел
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .sum()

    'average' - Возвращает среднее арифметическое
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .average()

    'mapToObj' - Преобразует числовой стрим обратно в объект
    Stream.mapToObj((id) -> new Key(id))
        .toArray()
```
```
Другие методы
   'isParallerl' - Узнать является ли стрим параллельным

    'parallel' - Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
    
    collection.stream()
        .peek(...) // операция последовательная
        .parallel()
        .map(...) // операция мождет выполняться параллельно
        .sequential()
        .reduce(...) // операция снова последовательна
```

2. Collectors
   Методы стататические

   `toList` - Представляет стрим в виде списка
   `toCollection` - Представляет стрим в виде коллекции
   `toSet` - Представляет стрим в виде множества</br></br>

   `toConcurrentMap` - Преобразовывает стрим в Map
   `toMap` - Преобразовывает стрим в Map</br></br>

   `averagingInt` - Среднее значение
   `averagingDouble`
   `averagingLong`</br></br>

   `summingInt` - Возвращает сумму
   `summingDouble`
   `summingLong`</br></br>

   `partitioningBy` - разделяет коллекцию на две части по соответствующему условию</br>
   и возвращает как Map<Boolean, List></br></br>

   `groupingBy` - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>></br></br>

   `mapping` - дополнительные преобразования значений для сложных Collector-ов</br></br>

```
strings.stream()
    .collect(Collectors.joining(" "), "<b>", "</b>")

string.stream()
    .collect(Collectors.groupingBy((p) -> p.substring(0, 1)))
```

3. Функциональный интерфейсы

`Predicate`(filter) - означает, что он будет пропускать только те элементы, которые возвращают true
```
public static void main(String[] args) {
    List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
        .filter(x -> x % 2==0)
        .collect(Collectors.toList());
}
```

`Consumer`(peek, forEach)
```
public static void main(String[] args) {
    List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
        .peek(x -> System.out.println("Hello " + x + " !!!"))
        .collect(Collectors.toList());
}
```
`Supplier`(generate)
```
public static void main(String[] args) {
    ArrayList<String> nameList = new ArrayList<>();
    nameList.add("Elena");
    nameList.add("John");
    nameList.add("Alex");
    nameList.add("Jim");
    nameList.add("Sara");
    
    Stream.generate(() -> {
        int value = (int) (Math.random() * nameList.size());
        return nameList.get(value);
    }).limit(5).forEach(System.out::println);
}
```
`Function`(map)
```
public static void main(String[] args) {
    List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
}
```
`UnaryOperator`(iterate)

1. Элемент, с котрого начинается генерация
2. Указывает принцип генерации новых элементов
```
public static void main(String[] args) {
    Stream.iterate(9, x -> x * x)
        .limit(4)
        .forEach(System.out::println);
}
```

3. Меняет ли начальные данные stream?</br>
   нет

## END ---------------- Stream ----------------

## SOLID

- Single Responsibility Principle (Принцип единственной ответственности).
- Open Closed Principle (Принцип открытости/закрытости).
- Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
- Interface Segregation Principle (Принцип разделения интерфейса).
- Dependency Inversion Principle (Принцип инверсии зависимостей).</br></br>

'Single Responsibility Principle' - никогда не должно быть больше одной причины изменить класс.
</br></br>
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс
</br></br>
Пример:</br>
    Представьте себе модуль, который обрабатывает заказы.</br>
    Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа
</br></br>
Данный класс протировечит SRP так как он отвечает за 3 обязанности.</br>
В идеале это должны быть 3 отдельных класса, каждый из которых отвечает за свою область</br></br>

`Open Closed Principle` - программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.</br>
Должна быть возможность изменять внешнее поведеление класс, не внося физические изменения в сам класс.</br>
Класс должны разрабатываться так, чтобы для поднастройки класс к конкретным условиям применения было доставточно расширить его или переопределить некоторые функции
</br></br>
`Liskov’s Substitution Principle` - объекты в программе можно заменить их наследниками без изменения свойств программы.</br>
Класс, разработанный путем расширения на основании базового класса, должен переопределять его метода так, чтобы не нарушалась функциональность</br>
с точки зрения клиента. То есть не должно меняться ожидаемое поведение
</br></br>
`Interface Segregation Principle` - клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.</br>
Слишком "толстые" интерфейсы необходимо разделять на более мелкие, спецефические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе</br>
</br></br>
`Dependency Inversion Principle` - зависимости внутри системы строятся на основе абстракций.</br>
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономны и соединялись друг с другом с помощью абстракций

## END ---------------- SOLID ----------------

## Java 8

1. Методы интерфейсов по умолчанию
```
interface Formula {
    double calculate(int a);
    
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```
2. Лямбда-выражения
```
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```
3. Функциональные интерфейсы
```
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
4. Ссылки на методы и конструкторы
```
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);
```
5. Области действия лямбд</br>
   Лямбды могут ссылаться на переменные, обхявленные как final, на экземплярные поля класса и статические переменные
```
final int num = 1;
Converter<Integer, String> stringConverter = (from) -> String.valueOf(from + num);

stringConverter.convert(2);
```
переменная num не обязательно должна быть final, но должна быть неизменяемой

6. Доступ к полям и статическим переменным

7. Доступ к методам интерфейсом по умолчанию</br>
   Внутри лямбда-выражений запрещено обращаться к методам по умолчанию

8. Stream

9. Апи для работы с датами
    - Clock
    - Часовые пояса
    - LocalTime
    - LocalDate
    - LocalDateTime

10. Аннотации
    @Repeatable

## END ---------------- Java 8 ----------------

    26. Можно ли увеличить размер массива после его инициализации?
    нет, только пересоздать новый массив


    27. Как создать собственный иммутабельный класс?
final и без геттеров