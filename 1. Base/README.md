https://github.com/johnivo/job4j/blob/master/interview_questions/Core.md#4-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-JDK

+ [REST vs SOAP](#rest-vs-soap)
+ [Основы](#основы)
+ [Garbage collector](#garbage-collector)
+ [ООП](#ооп)
+ [Процедурная Java](#процедурная-java)
+ [ООП в Java](#ооп-в-java)
+ [Исключения](#исключения)
+ [Сериализация и копирование](#сериализация-и-копирование)
+ [Дженерики](#дженерики)
+ [Коллекции](#коллекции)
+ [База данных](#база-данных)
+ [Concurrency](#concurrency)
+ [Spring](#spring)
+ [Kafka](#kafka)
+ [Stream](#stream)
+ [SOLID](#solid)
+ [Java 8](#java-8)
+ [ENUM](#enum)

## REST vs SOAP

+ [1. Как расшифровывается REST](#1-как-расшифровывается-rest)
+ [2. Что такое REST](#2-что-такое-rest)
+ [3. Какие принципы есть у REST](#3-какие-принципы-есть-у-rest)
+ [4. Что такое SOAP](#4-что-такое-soap)
+ [5. Как SOAP и REST используют HTTP протокол](#5-как-soap-и-rest-используют-http-протокол)
+ [6. В каком формате должны возвращаться данные при REST и SOAP](#6-в-каком-формате-должны-возвращаться-данные-при-rest-и-soap)
+ [7. С чем работает SOAP и REST](#7-с-чем-работает-soap-и-rest)
+ [8. Когда лучше использовать SOAP](#8-когда-лучше-использовать-soap)
+ [9. Когда лучше использовать REST](#9-когда-лучше-использовать-rest)

### 1. Как расшифровывается REST
Representational State Transfer - передача состояния представления
Запрос ресурса с сервера переводит клиентское приложение в определенное состояние (state)</br>
а запрос следующего ресурса меняет состояние приложения (transfer)</br>
Representational означает, что ресурс возвращается не просто так, а в каком-то представлении</br>

### 2. Что такое REST
REST - это архитектурный стиль

### 3. Какие принципы есть у REST
- Give every 'thing' an ID
- Link things together - В страницу о Mercedes C218 лучше добавить ссылку о двигателе данной моделе
- Use standard methods - использовать стандыртный методы HTTP
- Resources can have multiple representations - Одни и те же данные можно вернуть в XML или JSON
- Communicate statelessly - REST просто отвечает на запрос, вне зависимости от предыдущих запросов

### 4. Что такое SOAP</br>
SOAP(Simple Object Access Protocol) - это целое семейство протоколов и стандартов</br>
Это более тяжеловесный и сложный вариант с точки зрения машинной обработки</br>
SOAP стандартизирован

### 5. Как SOAP и REST используют HTTP протокол</br>
SOAP использует HTTP как транспортный протокол</br>
REST базируется на HTTP</br>

В REST работают все наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование</br>
В SOAP необзодимо искать другие средства для реализации наработок</br>

SOAP могут работать с любым протоколом транспортного уровня вместо HTTP

### 6. В каком формате должны возвращаться данные при REST и SOAP</br>
SOAP - привязан к XML</br>
REST - не привязан к формату, может возвращать любой формат

### 7. С чем работает SOAP и REST</br>
SOAP работает с операциями </br>
REST работает с ресурсами </br>

* транзации или сложная логика должна реализовываться SOAP

### 8. Когда лучше использовать SOAP</br>
Когда необходимо делать многочисленные проверки данных, повышенная безопасность и устойчивость

### 9. Когда лучше использовать REST</br>
Для простых операций, который независимы друг от друга (CRUD)

## END ---------------- REST vs SOAP ----------------

## Основы

+ [1. Какие преимущества у Java?](#1-какие-преимущества-у-java)
+ [2. Какие недостатки у Java?](#2-какие-недостатки-у-java)
+ [3. Что такое JVM, JDK, JRE? В чем отличия?](#3-что-такое-jvm-jdk-jre-в-чем-отличия)
+ [4. Что такое byte code?](#4-что-такое-byte-code)
+ [5. Что такое загрузчик классов classloader?](#5-что-такое-загрузчик-классов-classloader)
+ [6. Что такое JIT?](#6-что-такое-jit)
+ [7. Что такое String[] args в методе main()?](#7-что-такое-string-args-в-методе-main)
+ [8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?](#8-что-такое-пакеты-зачем-они-нужны-какие-пакеты-по-умолчанию-подключены)

### 1. Какие преимущества у Java?
- Основное преимущество  - кроссплатформенность
- Огромный выбор библиотек под любые задачи
- Автоматическое управление памятью
- Многопоточность
- ООП


### 2. Какие недостатки у Java?
- Низкая скорость в сравненни с С и С++
- Требует много памяти
- Нет поддержки низкоуровневого программирования (например указателей)
- Планирование новой программы занимает много времени из-за ООП
- Многословность


### 3. Что такое JVM, JDK, JRE? В чем отличия?

   `JVM(Java Virtual Machine)` — это часть платформы Java, которая исполняет программы.
   программа, предназначенная для выполнения байт-кода. Преимущество - "Write once, run anywhere"

   `JRE(Java Runtime Environment)` — это элемент Java, расположенный на диске, создающий и запускающий JVM
   это пакет всего необходимого для запуска скомпилированной Java программы

   `JDK(Java Development Kit)` - позволяет разработчикам создавать Java-программы, которые могут выполняться и запускаться посредством JVM и JRE. JDK = JRE + компилятор
   включает в себя около 40 различных тулов (компилятор, лаунчер приложений, java debugger etc.


### 4. Что такое byte code?
    - это стандартное промежуточное представление [en], в которое может быть переведена компьютерная программа автоматическими средствами.


### 5. Что такое загрузчик классов classloader?
   Это объект, которые отвечает за загрузку классов. ClassLoader  это абстрактный класс


### 6. Что такое JIT?
   Если в программе присутствуют части кода, которые выполняются много раз,</br>
   то их можно скомпилировать один раз в машинный код, чтобы в будущем ускорить их выполнение.</br>
    - Ускорение работы программы достигается за счет увеличения потребления памяти (чтобы хранить этот код)


### 7. Что такое String[] args в методе main()?
   Это аргументы которые будут переданы из консоли


### 8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
   Для разграничения областей видимости и группировки классов</br>

   По умолчанию подключено lang

## END ---------------- Основы ----------------

## Garbage collector

+ [1. Как устроена память?](#1-как-устроена-память)
+ [2. Что является мусором?](#2-что-является-мусором)
+ [3. Этапы сборки мусора](#3-этапы-сборки-мусора-)
+ [4. Что означает поколения объектов?](#4-что-означает-поколения-объектов)
+ [5. Зачем нужны поколения объектов?](#5-зачем-нужны-поколения-объектов)
+ [6. Как происходит заполнения областей?](#6-как-происходит-заполнения-областей)
+ [7. Какие есть сборкики мусора?](#7-какие-есть-сборкики-мусора)
+ [8. Как работает сболрщик CMS GC(Concurrent Mark Sweep)](#8-как-работает-сболрщик-cms-gcconcurrent-mark-sweep)
+ [9. Как работает G1 GC (Garbage First)?](#9-как-работает-g1-gc-garbage-first)

### 1. Как устроена память?
- Native Memory — вся доступная системная память.
- Heap (куча) - часть Native Memory. Здесь храняться JVM объекты. Это общее пространство для всех потомок приложения
- Stack (стек) - используется для хранения локальных переменных и стека вызовов метода. Для каждого потоко выделяется свой стек
- Metaspace (метаданные) - тут хранятся метаданных классов и статические переменные. Является общим для всех
- CodeCache (кэш кода) - JIT компилятор компилирует часто исполняемый код, преобразуя его в нативный машинный код и кеширует для более быстрого выполнения

### 2. Что является мусором?</br>
Мусором является объект, который больше не может быть достигнут по ссылке из какого-либо места

### 3. Этапы сборки мусора </br>
- Mark (маркировка) (Stop the world) - GC сканирует все объекты и помечает живые. На этом этапе выполнение программы приостанавливается
- Sweep (очистка) - Освобождается память, занятая объектами, не помечанными на предыдущем шаге
- Compact (уплотнение) - Объекты, переживщие очистку, перемещаются в единый непрерывных блок памяти

### 4. Что означает поколения объектов?
Объекты разделяются на 2 типа в зависимости от их типа для оптимизации
- Young generation
  - Eden - Здесь создаются новые объекты
  - S0 и S1 (Survivor Space - область для выживших)
- Old generation (Tenured) - давно живущие объекты

### 5. Зачем нужны поколения объектов?
- Большинство объектов живут не долго
- Если объект выживает, то он, скорее всего, будет жить вечно
- Этапы mark и sweep занима.т меньше времени при большом количество мусора. </br>
То есть маркировка будет происходить быстрее, если анализируемая область небольшая и в ней много метных объектов

### 6. Как происходит заполнения областей?
1. Новые объекты создаются в Eden
2. Когда Eden заполняется, происходит минортая сборка мусора
* Minor GC - это процесс при котором операции mark и sweep выполняются для young generation
3. После Minor GC выживышие объекты перемещаются в одну из областей S0
4. По мере работы приложения пространство заполняется новыми объектами. </br>
При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в S1 и их возраст увеличивается
5. При следующем Minor GC процесс повторяется
Однако области Survivor Space меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст
6. Таким образом объекты копируются из области в область несколько раз пока в областях не закончится место или пока они не переживую определенное количество чисток</br>
После чего они будут перемещены в Old generation
7. Major GC. При Major GC этапы mark и sweep выполняются для Old generation

### 7. Какие есть сборкики мусора?

| Сборщик мусора | Описание                                                            | Преимущества                                                                                                                    | Когда использовать                                                                                                                                                                                                            | Флаги для включения |
|----------------|---------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|
| Serial         | Использует 1 поток                                                  | Эффективный, т.к. нет накладных расходов на взаимодействие потоков                                                              | Однопроцессорные машины<br/>Работы с небольшими наборами данных                                                                                                                                                               | -XX:+UseSerialGC    |
| Parallel       | Использует несколько потоков                                        | Многопоточность усколяет сборку мусора                                                                                          | В приоритете пиковая производительность<br/>Допустимы паузы при GC в одну секунду и более<br/>Работа со средними и большими наборами данных<br/>Для приложений работающих на многопроцессорном или многопоточном оборудовании | -XX:+UseParallelGC  |
| G1             | Выполняет некоторую тяжелую работу параллельно с работой приложения | Может использоваться как на небольших системах, так и на больших с большим количеством процессором и большим количеством памяти | Когда время отклика важнее пропускной способности<br/>Паущы GC должны быть меньше одной секунды                                                                                                                               | -XX:+UseG1GC        |
| Z1             | Выполняет всю тяжелую работу параллельно с работой приложения       | Низкая задержка                                                                                                                 | В приоритете время отклика                                                                                                                                                                                                    | +UseZGC             |


### 8. Как работает сболрщик CMS GC(Concurrent Mark Sweep)
- Использует такую же организацию памяти как и Serial/Parallel (пункт 4)
- Использует такие же принципи по работе с младшими поколениями (пункт 6 - 1-6)
- Не дожидается полного заполнения блока старшего поколения (Tenured) для того чтобы начать сборку мусора
- Работает в фоном режиме и постоянно поддерживает Tenured в компактном состоянии
- Сборщик умеет разносить во времени малые и старшие сборки мусора, чтобы не создавать продолжительных пауз

0. Этапы от 1-6 с пункта 6
1. Останавливает основные потоки приложения (initial mark pause)
2. Помечает все объекты, которые доступны из корня
3. Запускает работу приложения
4. Сборщик параллельно продлолжает поиск всех живых объектов, доступных по ссылке из помеченных на втором этапе объектов
 - происходит это в одном или нескольких потоках
5. После завершения поиска сборщик еще раз останавливает приложение (remark pause) и просматривает кучу для поиска живых объектов
 - На данном этапе в живые могут попасть те объекты, которые живыми уже не являются
 - Такие объекты называются _плавающим мусором_ (floating garbage) - они будут удалены в процессе следующей сборки
 - Используется алгоритм Snapshot-At-The-Beginning (SATB) - в список живых попадают все объекты, которые могли быть таковыми на момент начала работы алгоритма
6. Возобновляется работа основных потоков приложения
7. Сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках
 - После очистки не будет производится упаковка объектов в старшем поколении

### 9. Как работает G1 GC (Garbage First)?
- Изначально предназначался для приложений с большими кучам (от 4гб и выше)
- Задача минимизировать паузы в работе основного приложения

**Структура кучи**
- Память разбита на множество регионом одиннакового размера
- Для больших объектов может объеденяться несколько регионов
- По умолчанию регионы разбираются так, чтобы их было не больше 2048 (~ от 1 до 32mb)
- Разделение регионов на Eden, Survivor и Tenured логическое и регионы могут менять свою принадлежность

**Принцип работы**
1. Остановка основного процесса приложения
2. Работа с малыми сборками происходит в несколько потоков
- Принцип работы с малыми сборками такой же как в пункте 6 (1-6)
- Но очистка выполняется не на всем поколении, а только на части регионов, которые сборщик может очистить не превышая желаемое время
- Выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора (Garbage First)
4. Начало работы Смешанной сборки (ранее работы со старым поколением)
5. Остановка приложения (initial mark pause)
6. Пометка корней с использованием информации, полученной из малых сборок
7. Concurrent marking - пометка всех живых объектов в куче в нескольких потоках, параллельно с работой приложения
8. Оставнока приложения (remark pause)
9. Дополнительный поиск не учтенных ранее живых объектов
- Использует Snapshot-At-The-Beginning (SATB), то есть может присутсвовать плавающий мусор
8. Возобновление работы приложения
9. Остановка приложения
10. Cleanup - очистка вспомогательных структур учета ссылок на объеты
11. Возобновление работы приложения
12. Поиск пустых регионов, которые можно использовать для размещения новых объектов

* После окончания цикла пометки (2) G1 переключается на выполнение смешанных сборок (5)
    - Каждый раз к набору регионом младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения
    - У сборщика есть статистика по предыдущим сборкам, чтобы не выходить за рамки по времени
    - После окончания очистки возвращается к работе с младшим поколением
* Очередной цикл пометки будет запущен тогда, когда заполненность кучи превысит определенный порог

## END ---------------- Garbage collector ----------------


## ООП

+ [1. Что такое ООП?](#1-что-такое-ооп)
+ [2. Что такое объект?](#2-что-такое-объект)
+ [3. Что такое класс?](#3-что-такое-класс)
+ [4. Какие преимущства у ООП?](#4-какие-преимущства-у-ооп)
+ [5. Какие недостатки у ООП?](#5-какие-недостатки-у-ооп)
+ [6. Основные принципы ООП](#6-основные-принципы-ооп)
+ [7. Что такое ассоциация?](#7-что-такое-ассоциация)
+ [8. Что такое агрегация?](#8-что-такое-агрегация)
+ [9. Что такое композиция?](#9-что-такое-композиция)
+ [10. Раннее и позднее связывание](#10-раннее-и-позднее-связывание)
+ [11. Можно ли переопределить private или static методы?](#11-можно-ли-переопределить-private-или-static-методы)
+ [12. Можно ли менять модификатор доступа у унаследованных методов,свойств](#12-можно-ли-менять-модификатор-доступа-у-унаследованных-методовсвойств)
+ [13. Можно ли получить доступ к нестатическому полю из статического метода?](#13-можно-ли-получить-доступ-к-нестатическому-полю-из-статического-метода)
+ [14. Что такое diamond problem и как она решена в Java](#14-что-такое-diamond-problem-и-как-она-решена-в-java-)

### 1. Что такое ООП?
   - ООП - это объектно ориентированное программирование.
   - Это программирование с помощью классов и объектов


### 2. Что такое объект?
   - Объект  - это сущность, одновременно содержащая данные и поведения.
   - Объекты - это строительные блоки объектно-ориентированных программ.

```
Данные объектов - состояние объекта(атрибуты).
Пример: атрибуты работника (SocialSecurityNumber, Gender, DateOfBirth)

Поведения объектов - что объект может сделать( в процедурных языках определяется процедурами, функциями и подпрограммами) (методы).
Пример: методы работника (setGender() getGender() - для установки и получения пола).
```
### 3. Что такое класс?
   Класс - это "чертеж" объекта


### 4. Какие преимущства у ООП?
- Модульность - инкапсуляция объектов в себе упрощает разработку, уменьшает количество ошибок
- Реюзабельность кода
- Высокая скорость разработки - классы и интерфейсы в ООП могут легко трансформироваться в подобие полноценных библиотек
- Расширяемость - ООП легко развивать, дополнять и менять. Этому способствует независимая модульная структура
- Простота восприятия
- Безопасность - инкапсулированных код недоступен извне, поэтому поломать что-либо сложнее
- Гибкость - полиморфизм позволяет быстро адаптировать ООП-код под свои нужды


### 5. Какие недостатки у ООП?
- Объекты во главе угла - из-за особенного внимания к объектам, меньше внимания уделяется вычислениям и алгоритмам
- Негативно сказывается на скорости компиляции кода


### 6. Основные принципы ООП
- Инкапсуляция - свойство системы, позволяющее объеденить данные и методы, работающие с ним, в классе. В частности, некоторые языки подразумевают сокрытие этих компонентов от доступа из вне.
- Наследование - Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью
- Полиморфизм поддтипов - свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта
- Полиморфизм параметрический - свойство семантики системы типов, позволяющее обрабатывать значения разных типов идентичным образом, то есть исполнять физически один и тот же код для данных разных типов
- Полиморфизм ad hoc - это свойство языка программирования, позволяющее создать функцию, семантика которой будет зависеть от типов входных параметров
- Абстракция - каждый верхний слой над объектом (классы) более абстрактный


### 7. Что такое ассоциация? 
https://i.stack.imgur.com/BBNy5.png

   Объекты между собой никак не связаны. Первый объект может принадлежать сразу нескольким объектам одновременно и не управляться ими</br>
   Наследование позволяет одному классу наследовать от другого, поэтому мы можем абстрагировать атрибуты и поведения для общих классов


### 8. Что такое агрегация?
   Это вложенность одного класса в другой, но при этом класс обертка не управляет сроком жизни вложенного объекта</br>
   части могут принадлежать более чем одному целому за раз, и целое не управляет существованием и временем жизни частей

- Например, отношения между человеком и его домашним адресом. У каждого человека есть свой адрес. Однако этот адрес может принадлежать более чем одному человеку за раз</br>
  Однако этот адрес не управляется человеком — адрес существовал до того, как человек заселился и будет существовать после того, как человек выселится.


### 9. Что такое композиция?
это отношения части-целого. Часть в композиции может быть частью только одного объекта за раз

- Например: сердце, которое является частью тела одного человека, не может быть частью тела ещё одного человека одновременно.


### 10. Раннее и позднее связывание
- Раннее - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода
- Позднее - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.


### 11. Можно ли переопределить private или static методы?
    нельзя


### 12. Можно ли менять модификатор доступа у унаследованных методов,свойств
- Понижать уровень доступа нельзя
- Повышать уровень доступа можно


### 13. Можно ли получить доступ к нестатическому полю из статического метода?
    нет

### 14. Что такое diamond problem и как она решена в Java </br>
Diamond problem это Когда классы B и C наследуют А, а класс D наследуюет B и C</br>
При этом классы A, B, C определяют метод test что приводит к непонимаю какую именно имплементацию метода test должен унаследовать класс D

В java запрещено множественное наследование
## END ---------------- ООП ----------------

## Процедурная Java

+ [1. Какие примитивные типы данных есть в Java?](#1-какие-примитивные-типы-данных-есть-в-java)
+ [2. Какими значения по умолчанию инициализируются поля примитивных типов данных?](#2-какими-значения-по-умолчанию-инициализируются-поля-примитивных-типов-данных)
+ [3. Что такое автоупаковка и автораспаковка?](#3-что-такое-автоупаковка-и-автораспаковка)
+ [4. Что такое класс-обертки?](#4-что-такое-класс-обертки)
+ [5. Что такое cast?](#5-что-такое-cast)
+ [6. Что такое пул интов?](#6-что-такое-пул-интов)
+ [7. Какие нюансы у строк в Java?](#7-какие-нюансы-у-строк-в-java)
+ [8. Что такое пул строк?](#8-что-такое-пул-строк)
+ [9. Почему строки не рекомендуется использовать для хранения паролей?](#9-почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
+ [10. Почему строка неизменяемый и финализированный класс?](#10-почему-строка-неизменяемый-и-финализированный-класс)
+ [11. Что делает метод intern() в классе String?](#11-что-делает-метод-intern-в-классе-string)
+ [12. Можно ли использовать строку в конструкции Switch](#12-можно-ли-использовать-строку-в-конструкции-switch)
+ [13. Что такое инвариантность и ковариантность](#13-что-такое-инвариантность-и-ковариантность)
+ [14. В чем разница между String, StringBuffer, StringBuilder?](#14-в-чем-разница-между-string-stringbuffer-stringbuilder)
+ [15. Каким образом переменные передаются в метода?](#15-каким-образом-переменные-передаются-в-метода)
+ [16. В чем разница между Hashtable и HashMap?](#16-в-чем-разница-между-hashtable-и-hashmap)

### 1. Какие примитивные типы данных есть в Java?

| ТИП     |Размер в байтах |     Диапазон значений     |     Значение по умолчанию     |     Описание  |
|---------|----------------|---------------------------|-------------------------------|-------------- |
| byte    |     1          |   -128 .. 127             |     0                         | Самое маленькое целое — один байт |
| short   |     2          |   -32,768 .. 32,767       |     0                         | Короткое целое, два байта |
| int     |     4          |   -2*10 в 9 .. 2*10 в 9   |     0                         | Целое число, 4 байта |
| long    |     8          |   -9*10 в 18 .. 9*10 в 18 |     0L                        | Длинное целое, 8 байт |
| float   |     4          |   -10 в 38 .. 10 в 38     |     0.0f                      | Дробное, 4 байта |
| double  |     8          |   -10 в 308 .. 10 в 308   |     0.0d                      | Дробное, двойной длины, 8 байт |
| boolean |     1          |   true, false             |     false                     | Логический тип (только true & false) |
| char    |     2          |   0 .. 65,535             |     '\u0000'                  | Символы, 2 байта, все больше 0 |
|  NaN    |                |                           |                               | Не число |


### 2. Какими значения по умолчанию инициализируются поля примитивных типов данных?
   - Числовые и char = 0
   - Булево = false


### 3. Что такое автоупаковка и автораспаковка?

   - Автоупаковка (autoboxing) — это процесс автоматической инкапсуляции данных простого типа, такого как int или double, в эквивалентную ему оболочку типа, как только понадобится объект этого типа. При этом нет необходимости в явном создании объекта нужного типа.
   - Автораспаковка (auto-unboxing) — это процесс автоматического извлечения из упакованного объекта значения, когда оно потребуется.


### 4. Что такое класс-обертки?

   Обертка - это специальный класс, который хранит внутри себя значение примитива

   - int - Integer
   - short - Short
   - long - Long

   Классы обертки позволяют невелировать недостатки, которые есть у примитивных типов
   Самый очевидный из них — примитивы не имеют методов.

### 5. Что такое cast?
   Приведение типов


### 6. Что такое пул интов?
   Java хранит пул интов [-128; 127]


### 7. Какие нюансы у строк в Java?
- Класс реализует Serializable и CharSequence
- Это final класс, который не может иметь потомков
- это immutable класс, его объекты не могут быть изменены после создания. Любые операция приводят к созданию нового объекта
- Благодаря неизменяемости - это потокобезопасный класс
- Каждый объект может быть преобразован в строку с помощью toString


### 8. Что такое пул строк?
   - Это набор сктрок, который хранится в Java heap
   - Пул строк возможет благодаря неизменяемости строк в Java
   - Пул строк помогает экономить большой объем памяти

   Когда мы используем двойные кавычки для создания строки, сначала строка ищется в пуле с таким же значением, если находится</br>
   то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка

   Когда мы используем оператор new мы принуждаем создать новую строку


### 9. Почему строки не рекомендуется использовать для хранения паролей?

Строка хранится в пуле строка до тех пор пока она не будет удалена сборщиком мусора

Даже если мы думаем, что закончили работу с паролем, он остается доступен в памяти

Лучше использовать массив символов для хранения пароля, так как мы можем его очистить после того, как закончим с ним работать


### 10. Почему строка неизменяемый и финализированный класс?
- Строковый пул возможен только потому, что строка неизменна. Таким образом сохраняется много места в памяти
- Изменяемая строка - это угроза приложению: Например параметры для соединения с бд передаются в виде строки и х нельзя изменить
- Неизменная строка безопасна для многопоточности
- Ее hashCode кэшируется в момент создания и нет необходимости расчитывать его снова. Это делает строку отличным кандидатом для ключа в Map
  и ее обработка будет быстрее


### 11. Что делает метод intern() в классе String?
- Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную нашему объекту, тогда возвращается ссылка на строку из пула
- Этот метод возвращает строку, которая имеет то же значение, что и текущая строка, но гарантирует что это будет строка из пула уникальных строк


### 12. Можно ли использовать строку в конструкции Switch
- строки switch чувствительны к регистру
- оператор использует метод `String.equals()` для сравнения полученного значения со значениемя case, поэтому необходима проверка на null
- согласно Java 7 для строк в switch компилятор формирует более эффективный байт код


### 13. Что такое инвариантность и ковариантность
- Ковариантность - случай когда более конкретный тип S может быть подставлен вместо более обобщенного типа Т </br>
Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>
- Инвариантность - случай когда подставлять можно только определенный тип</br>
Если Кошка — это подтип Животные, то Множество<Кошки> не является подтипом Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.


### 14. В чем разница между String, StringBuffer, StringBuilder?</br>
_String_ - это класс для создания объекта типа String</br>
_StringBuffer_ - это класс, который используется для изменения строк и обеспечения безопасности потоков (синхронизирован)</br>
_StringBuilder_ - это класс класс, который используется для изменения строк, не обеспечивающих потокобезопасность (не синхронизирован)


### 15. Каким образом переменные передаются в метода?</br>
_Примитивные_ - копируется само значение</br>
_Ссылочные_ - копируется ссылка


### 16. В чем разница между Hashtable и HashMap?</br>
_Hashtable_ - все методы синхронизированные</br>
_HashMap_ - все методы не синхронизированные

## END ---------------- Процедурная Java ----------------

## ООП в Java

+ [1. Какие виды есть в java?](#1-какие-виды-есть-в-java)
+ [2. Что такое вложенные классы? В каком случаях они применяются?](#2-что-такое-вложенные-классы-в-каком-случаях-они-применяются)
+ [3. Что такое "локальный класс"? Каковы его особенности?](#3-что-такое-локальный-класс-каковы-его-особенности)
+ [4. Что такое "анонимные классы"? Где они применяются?](#4-что-такое-анонимные-классы-где-они-применяются)
+ [5. Каким образом из вложенного класса получить доступ к полю внешнего класса?](#5-каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ [6. Что такое перечисления (enum)?](#6-что-такое-перечисления-enum)
+ [7. Как проблема ромбовидного наследования решена в Java?](#7-как-проблема-ромбовидного-наследования-решена-в-java)
+ [8. Что такое конструктор по умолчанию?](#8-что-такое-конструктор-по-умолчанию)
+ [9. Могу ли быть приватные конструкторы? Для чего они нужны?](#9-могу-ли-быть-приватные-конструкторы-для-чего-они-нужны)
+ [10. Что такое классы-загрузчики и динамическая загрузка классов?](#10-что-такое-классы-загрузчики-и-динамическая-загрузка-классов)
+ [11. Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?](#11-чем-отличаются-конструкторы-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ [12. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.](#12-какие-модификации-уровня-доступа-вы-знаете-расскажите-про-каждый-из-них)
+ [13. Что означает модификатор static?](#13-что-означает-модификатор-static)
+ [14. Могут ли нестатические методы перегрузить статические?](#14-могут-ли-нестатические-методы-перегрузить-статические)
+ [15. Могут ли быть переопределены статические методы?](#15-могут-ли-быть-переопределены-статические-методы)
+ [16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределение метода?](#16-можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределение-метода)
+ [17. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы](#17-что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы)
+ [18. Могут ли классы быть статическими](#18-могут-ли-классы-быть-статическими)
+ [19. Что такое сигнатуры методы?](#19-что-такое-сигнатуры-методы)
+ [20. Что такое переопределение и перегрузка методов?](#20-что-такое-переопределение-и-перегрузка-методов)
+ [21. Когда вызывается конструктор?](#21-когда-вызывается-конструктор)
+ [22. Что означает ключевое слово final?](#22-что-означает-ключевое-слово-final)
+ [23. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?](#23-могут-ли-быть-конструкторы-у-абстрактных-классов-зачем-они-нужны)
+ [24. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#24-что-такое-интерфейсы-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ [25. Может ли интерфейс наследоваться от интерфейса?](#25-может-ли-интерфейс-наследоваться-от-интерфейса)
+ [26. Что такое дефолтные методы интерфейсов?](#26-что-такое-дефолтные-методы-интерфейсов)
+ [27. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default методами?
  ](#27-как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-с-default-методами)
+ [28. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?](#28-каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учетом-иерархии-классов) 
+ [29. Какие бываю и зачем нужны блоки инициализации?](#29-какие-бываю-и-зачем-нужны-блоки-инициализации) 
+ [30. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?](#30-каков-порядок-вызова-конструкторов-и-блоков-инициализации-двух-классов-потомка-и-его-предка) 
+ [31. Что произойдет, если в блоке инициализации возникнет ошибка?](#31-что-произойдет-если-в-блоке-инициализации-возникнет-ошибка) 
+ [32. Какие методы есть у object](#32-какие-методы-есть-у-object) 
+ [33. Что такое метод equals(). Чем он отличается от операции ==. (https://habr.com/ru/post/168195/)](#33-что-такое-метод-equals-чем-он-отличается-от-операции--httpshabrcomrupost168195) 
+ [34. Каким образом реализованы методы equals() и hashCode()](#34-каким-образом-реализованы-методы-equals-и-hashcode) 
+ [35. Правила переопределения equals()](#35-правила-переопределения-equals) 
+ [36. Правила при переопределении hashCode](#36-правила-при-переопределении-hashcode) 
+ [37. Могут ли у разных объектов быть одиннаковые hashCode() ?](#37-могут-ли-у-разных-объектов-быть-одиннаковые-hashcode-) 
+ [38. Чем a.getClass().equals(A.class) отличается от instanceOf A.class](#38-чем-agetclassequalsaclass-отличается-от-instanceof-aclass) 
+ [39. Может ли метод быть одновременно abstract и final?](#39-может-ли-метод-быть-одновременно-abstract-и-final) 
+ [40. Функиональные интерфейсы](#40-функиональные-интерфейсы)
+ [41. Как связаны equals и hashCode? Можно ли их использовать по отдельности?](#41-как-связаны-equals-и-hashcode-можно-ли-их-использовать-по-отдельности-)

### 1. Какие виды есть в java?
- Вложенные внутренние классы
- Вложенные статические классы
- Локальные классы
- Анонимные классы


### 2. Что такое вложенные классы? В каком случаях они применяются?</br>
   Это классы, которые создаются внутри других классов</br>
   Бывает 2 вида вложенных классов: Нестатические и статические</br></br>

   Нестатические в свою очередь делятся на подвиды
    - Анонимные
    - Локальные
      </br></br>
   Внутреннние классы - это классы для выделения в программе некой сущности, которая неразрывно связана с другой сущностью</br>
   Например - Руль, сиденьк, педали - это составные части велосипеда</br></br>

- Объект внутреннего класса не может существовать без объекта "внешнего" класса
- У объеккта внутреннего класса есть доступк переменных "внешнего" класса
- Объект внутреннего класса нельзя создать в статическом методе "внешнего" класса
- Внутренний класс не может содержать статические переменные и методы


### 3. Что такое "локальный класс"? Каковы его особенности?</br>
   Это классы  объявленные внутри других методов</br></br>

- Локальные классы могут работать только с final переменными метода
- Локальные классы нельзя объявлять с модификаторами доступа
- Локальные классы обладают доступом к переменным метода


### 4. Что такое "анонимные классы"? Где они применяются?
- Это обычные нестатические вложенные классы, в более кратком виде. Объявляется класс и сразу создается экземпляр

   Используются когда
    - тело класса является коротким
    - нужен только ожин экземпляр класса
    - класс используется в месте его создания или сразу после него
    - имя класса не важно


### 5. Каким образом из вложенного класса получить доступ к полю внешнего класса?</br>
   Для получения доступа из внутреннего класса к экземпляру его внешнего класса необходимо в ссылке указать имя класса и влючевое слово this
   OuterClass.this


### 6. Что такое перечисления (enum)?</br>
   enum - это класс java.lang.Enum</br>
   Элементы перечисления - экземпляры enum-класса, доступные статически


### 7. Как проблема ромбовидного наследования решена в Java?</br>
   В Java нет множественного наследования</br>
   Но есть возможность использовать неограниченное количество интерфейсов


### 8. Что такое конструктор по умолчанию?</br>
   Если конструктор у класса не задан, то по умолчанию создастся пустой конструктор без реализации, которые будет вызывать super


### 9. Могу ли быть приватные конструкторы? Для чего они нужны?</br>
   Может</br>
   Защищает класс от явного превращения в экземпляр. Используется в шаблоне "Одиночка"</br>
   Обычно для создания объекта требуется вызвать другой метод


### 10. Что такое классы-загрузчики и динамическая загрузка классов?</br>
Есть 2 типа загрузки классов
- Статическая
- Динамическая

_Статическая_ - это привычная загрузка, которая производится автоматически. При запуске программы загрузчик классов рекрсивно загружает все классы, встречающиеся в программе, начиная с main</br>
_Динамическая_ - производится через метод Class.forName(String className) или с использованием ClassLoader</br>
Динамическая загрузка классов имеет смысл, когда требуется загрузить класс во время выполнения программы, когда нужно заменить класс, изменив, например, какую-то логику, не рестартуя приложения</br></br>

// загружаем класс через ClassLoader</br>
``` 
ClassLoader classLoader = MainClass.class.getClassLoader();
Class aClass = classLoader.loadClass("com.jenkov.MyClass");
myClass = (MyClass) aClass.newInstance();
```

### 11. Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?
- Конструктор по-умолчанию не принимает никаких параметров
- Конструктор копирования принимает в качестве параметра объект класса
- Конструктор с параметрами принимает на фход параметры</br></br>

    Конструктор копирования
```
// конструктор копирования
public Circle(Circle circle) {
    this(circle.getName(), circle.getArea(), circle.getPerimeter()); //будет вызван конструктор с параметрами ниже
}
```

### 12. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
- private (закрытый) - доступ не предоставляется никому, кроме методов этого класса
- default, package, friendly - доступ по умолчанию. Открытый внутри собственного пакета
- protected (защищённый) - доступ в пределах пакета и классов наследников
- public (открытый) - доступен всем и везде


### 13. Что означает модификатор static?</br>
Это значит что моле или метод будет относиться к классу, а не к инстансу(объекту) класса


### 14. Могут ли нестатические методы перегрузить статические?</br>
Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.


### 15. Могут ли быть переопределены статические методы?</br>
Переопределить базовый статический метод нельзя: Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс


### 16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределение метода?</br>
нет, можно только расширить


### 17. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы</br>
Можно менять модификатор доступа в стороны расширения</br></br>

- У переопределенного метода должны быть те же аргументы, что и у метода родителя.
- У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
- Модификатор доступа у переопределенного метода также не может отличаться от «оригинального» в меньшую сторону

### 18. Могут ли классы быть статическими</br>
Да


### 19. Что такое сигнатуры методы?</br>
Это имя + параметры (порядок параметров имеет значение)


### 20. Что такое переопределение и перегрузка методов?</br>
переопределение - изменение тела унаследованного метода</br>
перегрузка - несколько вариантом методов с разными аргументами


### 21. Когда вызывается конструктор?</br>
ПРи созданииэксземпляра класса


### 22. Что означает ключевое слово final?</br>
final - у метода, у переменной, у класса</br></br>

Класс нельзя унаследовать</br>
Метод нельзя переопределить</br>
Свойство нельзя переопределить


### 23. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?</br>
Да</br>
Создать экземпляр абстрактного класса нельзя, но все-равно можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе


### 24. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</br>
Это контракт описывающий возможности</br>
По умолчанию все методы объявляются как public abstract (начиная с Java 8 - default)</br>
Поля - public static final


### 25. Может ли интерфейс наследоваться от интерфейса?
Интерфейс может наследоваться только от интерфейсов


### 26. Что такое дефолтные методы интерфейсов?
Это реализация метода по умолчанию


### 27. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default методами?</br>
Никак. Будет ошибка на этапе компиляции.


### 28. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
- конструктор созданного класса объекта
- конструктор родителя созданного класса объекта (неявный super в начале конструктора класса)


### 29. Какие бываю и зачем нужны блоки инициализации?
- Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов.
- Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора.
- Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса.</br></br>

    Бываю статические и нестатические</br>
    static {}</br>
    {}</br></br>

    Зачем?
    - более читабельный код
    - внутри блоков можно не только присваивать значение, но и писать команды (вывод в косоль, циклы и т.д.)


### 30. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
- Все статические блоки от первого предка - до последнего наследника
- попарно динамические блоки инициализации и конструктор (от предка до последнего потомка)


### 31. Что произойдет, если в блоке инициализации возникнет ошибка?</br>
- Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется,</br>
чтобы объявления этих исключений были перечислены в throws всех конструкторов класса.</br>
Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции. (java.lang.ExceptionInInitializerError;)</br></br>

- остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте.</br>
   Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</br></br>
    
   ( тип ошибки - Если возникшее исключение - наследник Error,</br>
     то в обоих случаях будет выброшено java.lang.Error.</br>
     Исключение: java.lang.ThreadDeath - смерть потока.</br>
     В этом случае никакое исключение выброшено не будет.</br>
   )


### 32. Какие методы есть у object</br>
wait — поток переходит в режим ожидания в течение указанного времени.</br>
equals — сравнивает объекты.</br>
clone — клонирование объекта</br>
notify — просыпается один поток, который ждет на “мониторе” данного объекта.</br>
finalize — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет. (deprecated)</br>
toString — возвращает строковое представление объекта.</br>
hashCode — возвращает хеш-код</br>
notifyAll — просыпаются все потоки, которые ждут на “мониторе” данного объекта.


### 33. Что такое метод equals(). Чем он отличается от операции ==. (https://habr.com/ru/post/168195/)</br>
При сравнении с помощью `==` идет сравнение по ссылкам</br>
При сравнении по equals() идет сравнение по состоянию объектов</br></br>

Хем-код - это число. Битовая строка фиксированной длины, полученная из массива произвольной длины (ограничена типом int)


### 34. Каким образом реализованы методы equals() и hashCode()</br>

hashCode() - `public native int hashCode();` - реализация на языке С++</br>

equals() -
```
public boolean equals(Object obj) {
    return (this == obj);
}
```

### 35. Правила переопределения equals()</br>
При переопределении обязательно необходимо переопределить hashCode()


### 36. Правила при переопределении hashCode</br>
у них должен быть реализован метод для создания ключа и значения должны быть финализированы


### 37. Могут ли у разных объектов быть одиннаковые hashCode() ?</br>
Да, это называется коллизией


### 38. Чем a.getClass().equals(A.class) отличается от instanceOf A.class</br>
- метод getClass () всегда возвращает точно тот класс, от которого был порожден объект.


### 39. Может ли метод быть одновременно abstract и final?</br>
нет


### 40. Функиональные интерфейсы</br>
Функциональным считается интерфейс с одним не реализованным (абстрактным) методом
+ интерфейсы, которые создаются след образом

```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);
}
```
@FunctionalInterface - сообщает компилятору, что данный интерфейс функциональный и должен содержать не более одного метода

* Абстрактные интерфейсы могут иметь методы, которые не входят в ограничения одного метода

Статические методы
```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);

    staitc <T> boolean isNotNull(T t) {
        return t != null;
    }
}
```
+ методы по умолчанию
```
@FunctionalInterface
public interface Converter<T, N> {
  N converter (T t);

  staitc <T> boolean isNotNull(T t) {
    return t != null;
  }

  default void writeToConsole (T t) {
    System.out.println("Текущий объем - " + t.toString());
  }
}
```

### 41. Как связаны equals и hashCode? Можно ли их использовать по отдельности? </br>
- Повторный вызов hashCode для одного и того же объекта должен возвращать одиннаковые хеш-значения
- Если equals() для двух объектов возвращает true, hashCode()  также должен возвращать для них одно и тоже число
- Неравные между собой объекты могут иметь одиннаковый hashCode
- hashCode Используется для ускорения работы хеш-таблиц
- equals и hashCode можно использовать по отдельности

### END ---------------- ООП в Java ----------------

## Исключения

+ [1. Опишите иерархию исключений?](#1-опишите-иерархию-исключений)
+ [2. Чем отличается Error от Exception?](#2-чем-отличается-error-от-exception)
+ [3. Расскажите про обрабатываемые и необрабатываемые исключения?](#3-расскажите-про-обрабатываемые-и-необрабатываемые-исключения)
+ [4. Какой оператор позволяет принудительно выбросить исключение?](#4-какой-оператор-позволяет-принудительно-выбросить-исключение)
+ [5. Как создать собственное (пользовательское) исключение?](#5-как-создать-собственное-пользовательское-исключение)
+ [6. В каком случае не выполнится блок finally](#6-в-каком-случае-не-выполнится-блок-finally)
+ [7. Может ли метод main выбросить исключение во вне и е](#7-может-ли-метод-main-выбросить-исключение-во-вне-и-е)
+ [8. В каком порядке следует обрабатывать исключения в catch блоках?](#8-в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
+ [9. Что такое try-with-resources?](#9-что-такое-try-with-resources)
+ [10. Что произойдет есть исключение будет выброшено из блока catch после чего другое исключенгие будет выброшено из блока finally
  ](#10-что-произойдет-есть-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключенгие-будет-выброшено-из-блока-finally)
+ [11. В чем разница между Exception и Error?](#11-в-чем-разница-между-exception-и-error)
+ [12. Можно ли использовать проверяемые исключения в лямбда функциях](#12-можно-ли-использовать-проверяемые-исключения-в-лямбда-функциях)


### 1. Опишите иерархию исключений?

|     |                   | Object       |            |
|-----|-------------------|-----------|------------|
|     |                   | Throwable    |            |
|  Error   |              |       Exception       |   |
|  OutOfMemoryError   | StackOverflowError |RuntumeException | IOExeption |
|  LinkageError   |                   |IllegalArgumentExceprion |            |


### 2. Чем отличается Error от Exception?
 - Error - ошибка при выполнении java их нельзя исправить, о ним можно сообщить
 - Exception - это "особые случаи", которые нужно как-то обработать


### 3. Расскажите про обрабатываемые и необрабатываемые исключения?
- контролируемые исключения (checked) - это ошибки, которые можно и нужно обрабатывать в программе
- неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) - не трубуют обязательной обработки, но при желании можно обработать
- исключения времени выполнения (RuntimeExceptions, потомок класса Exception)


### 4. Какой оператор позволяет принудительно выбросить исключение?</br>
throw


### 5. Как создать собственное (пользовательское) исключение?</br>
Создать класси у наследоваться от Exception


### 6. В каком случае не выполнится блок finally</br>
Если в блоке try или catch есть System.exit


### 7. Может ли метод main выбросить исключение во вне и е</br>
да, в стандартный вывод ошибок будет выведено сообщение об ошибке, в котором будет указано имя потока</br>
Если нет запущенных потоков-недемонов, то программа будет завершена, иначе будет ждать завершения всех потоков


### 8. В каком порядке следует обрабатывать исключения в catch блоках?</br>
В порядке от наследников к родителю


### 9. Что такое try-with-resources?</br>
Это оператор, который решает проблему с обязательным вывзовом close()


### 10. Что произойдет есть исключение будет выброшено из блока catch после чего другое исключенгие будет выброшено из блока finally</br>
В finally можно реализовать вложенны try-catch


### 11. В чем разница между Exception и Error?</br>
Error - невозмжноо починить</br>
Exception - можно обработать ошибку


### 12. Можно ли использовать проверяемые исключения в лямбда функциях</br>
Нет


## END ---------------- Исключения ----------------

## Сериализация и копирование

+ [1. Что такое сериализация и как она реализована в Java?](#1-что-такое-сериализация-и-как-она-реализована-в-java)
+ [2. Для чего нужна сериализация?](#2-для-чего-нужна-сериализация)
+ [3. Опишите процесс сериализации/десериализации с использованием Serializable](#3-опишите-процесс-сериализациидесериализации-с-использованием-serializable)
+ [4. Какие поля не будут сериализованы при сериализации?](#4-какие-поля-не-будут-сериализованы-при-сериализации)
+ [5. Как изменить стандартное поведение сериализации/десериализации?](#5-как-изменить-стандартное-поведение-сериализациидесериализации)
+ [6. Как создать собственный протокол сериализации?](#6-как-создать-собственный-протокол-сериализации)
+ [7. В чем проблема сериализации Singleton?](#7-в-чем-проблема-сериализации-singleton)
+ [8. Как происходит сериализация](#8-как-происходит-сериализация)


### 1. Что такое сериализация и как она реализована в Java?</br>
Сериализация  - это процесс сохранения объекта в последовательный байт</br>
Десериализация  - это процесс восстановления объекта в байт


### 2. Для чего нужна сериализация?</br>
Сериализация нужна для передачи объектов


### 3. Опишите процесс сериализации/десериализации с использованием Serializable</br>
При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:</br></br>

- запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
- рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
- запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
- рекурсивную запись объектов, которые являются полями сериализуемого объекта.</br></br>

   При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.</br></br>

   При имплементации интерфейса Serializable у класса появляется идентификатор версии.</br>
   Он вычисляется по содержимому класса - полям, порядку объявления, методам.</br>
   Соотвественно при десериализации поля, порядок и методы должны совпадать.</br>
   Чтобы избежать возможных ошибок можно вручную задать для класса идентификатор версии (long serialVersionUID)


### 4. Какие поля не будут сериализованы при сериализации?</br>
   Те, которые не помечены как transient</br></br>

   Поля с модификатором final сериализуются как и обычные.</br>
   За одним исключением – их невозможно десериализовать при использовании `Externalizable`.</br>
   Ибо final-поля должны быть инициализированы в конструкторе,</br>
   а после этого в readExternal изменить значение этого поля будет невозможно.</br>
   Соответственно – если вам необходимо сериализовать объект, имеющий final-поле,</br>
   вам придется использовать только стандартную сериализацию.


### 5. Как изменить стандартное поведение сериализации/десериализации?
- Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации.</br>
  Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`.</br>
  Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.</br></br>

- Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,</br>
  а не метод по умолчанию :</br>
  ~ writeObject() - запись объекта в поток;</br>
  ~ readObject() - чтение объекта из потока;</br>
  ~ writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;</br>
  ~ readResolve() - позволяет заменить на себя другой объект после чтения.


### 6. Как создать собственный протокол сериализации?</br>
   Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:</br>
   `writeExternal()` и `readExternal()`


### 7. В чем проблема сериализации Singleton?</br>
   Проблема в том, что после десериализации мы получим другой объект.</br>
   Как этого избежать:</br>
    - явный запрет сериализации
    - определение метода с сигнатурой (default/public/private/protected/) Object readResolve() throws ObjectStreamException


### 8. Как происходит сериализация
1. Унаследоваться от интерфейса Serializable</br>
   [Serializable] - маркерный интерфейс

2. Определить переменную
   private static final long serialVersionId = 1;</br>
   Данные поле будет содержать уникальный идентификатор версии сериализованного класса</br></br>

   При сериализации значение serialVersionId сравнивается с десериализованным значением</br>
   ! Если значения не совпадут будет выброшено исключение InvalidClassException

3. Сериализайия внутренних классов</br>
   Все вложенные классы должны имплементировать интерфейс Serializable

4. Для того, чтобы свойство не сериализовалось, необходимо использовать ключевое слово transient


## END ---------------- Сериализация и копирование ----------------

## Дженерики

+ [1. Что такое дженерики?](#1-что-такое-дженерики)
+ [2. Для чего нужны Дженерики?](#2-для-чего-нужны-дженерики)
+ [3. Что такое сырые типы?](#3-что-такое-сырые-типы)
+ [4. Что такое `wildcard`?](#4-что-такое-wildcard)
+ [5. Расскажите про принцы PECS ***](#5-расскажите-про-принцы-pecs-)


### 1. Что такое дженерики?</br>
Дженерики - это типы с параметром


### 2. Для чего нужны Дженерики?</br>
Дженерики помогают упростить реализацию принципа ООП - Полиморфизм</br>
Позволяют на жтапе компиляции узнать о пробелеме типов</br>
Дженерики в основном инвариантны, но через wildcart можно сделать их коваринтными </br>
Дают возможность реализовать общее поведение для нескольких реализаций

### 3. Что такое сырые типы?</br>
Raw type - это класс-дженерик, из которого удалили его тип</br>
Возможность превратить в Raw type оставили для совмещения со старым кодом


### 4. Что такое `wildcard`?</br>
Upper Bounded Wildcards - <? extends Animal> - в такой объект ничего кроме null положить нельзя</br>
Это значит, что метод принимает на вход коллекцию объектов класса Animal либо объектов любого класса-наследника Animal</br></br>

Lower Bounded Wildcards - <? super Animal> - Можно положить:</br>
superZoo.encage(new Elephant("Джимбо", 3));</br>
superZoo.encage(new Animal("", 1))</br>
Это значит, что метод принимает на вход коллекцию объектов класса Animal либо любого другого класса предка Animal</br></br>

extends B — символ подстановки с указанием верхней границы</br>
super B — символ подстановки с указанием нижней границы</br>
где B — представляет собой границу</br></br>

т.е.</br>
Number <=? extends Object</br>
? extends Number <=? extends Object</br>
и</br>
? super Object <=? super Number</br>

### 5. Расскажите про принцы PECS ***</br>
Producer Extends Consumer Super - если у нас есть некая коллеция, типизированная wildcard с верхней границей (extends) то это "продюсер"

## END ---------------- Дженерики ----------------

## Коллекции

+ [1. Что такое коллекция?](#1-что-такое-коллекция)
+ [2. Расскажите про иерархию коллекций?](#2-расскажите-про-иерархию-коллекций)
+ [3. Почему Map - это не Collection, в то время как List и Set являются Collection?](#3-почему-map---это-не-collection-в-то-время-как-list-и-set-являются-collection)
+ [4. В чем разница между классами java.util.Collection и java.util.Collections?](#4-в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
+ [5. Что такое «fail-fast поведение»?](#5-что-такое-fail-fast-поведение)
+ [6. Какая разница между fail-fast и fail-safe?](#6-какая-разница-между-fail-fast-и-fail-safe)
+ [7. Чем различается Enumeration и Iterator?](#7-чем-различается-enumeration-и-iterator)
+ [8. Как между собой связаны Iterable, Iterator и «for-each»?](#8-как-между-собой-связаны-iterable-iterator-и-for-each)
+ [9. Сравните Iterator и ListIterator.](#9-сравните-iterator-и-listiterator)
+ [10. Как поведёт себя коллекция, если вызвать iterator.remove()?](#10-как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
+ [11. Чем Set отличается от List?](#11-чем-set-отличается-от-list)
+ [12. Расскажите про интерфейс Set](#12-расскажите-про-интерфейс-set)
+ [13. Что будет если добавлять элементы в TreeSet по возрастанию?](#13-что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
+ [14. Как устроен HashSet, сложность основных операций (16)](#14-как-устроен-hashset-сложность-основных-операций-16)
+ [15. Как устроен LinkedHashSet сложность основных операций](#15-как-устроен-linkedhashset-сложность-основных-операций)
+ [16. Как устроен TreeSet сложность основных операций](#16-как-устроен-treeset-сложность-основных-операций)
+ [17. Расскажите про интерфейс List](#17-расскажите-про-интерфейс-list)
+ [18. Как устроен ArrayList сложность основных операций](#18-как-устроен-arraylist-сложность-основных-операций)
+ [19. Как устроен LinkedList сложность основных операций](#19-как-устроен-linkedlist-сложность-основных-операций)
+ [20. Почему LinkedList реализует и List и Deque](#20-почему-linkedlist-реализует-и-list-и-deque)
+ [21. Как перестроить Связанный список в HashTable](#21-как-перестроить-связанный-список-в-hashtable)
+ [21. Как перестроить Связанный список в HashTable](#21-как-перестроить-связанный-список-в-hashtable)
+ [22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?](#22-существуют-ли-какие-нибудь-требованию-к-объектам-используемым-в-качестве-ключа-в-hashmap)
+ [23. Как работает HashMap?](#23-как-работает-hashmap)
+ [24. Как строиться красное-черное дерево?](#24-как-строиться-красное-черное-дерево)
+ [25. На чем основана HashSet?](#25-на-чем-основана-hashset)

### 1. Что такое коллекция?</br>
Коллекции - это наборы однородных элементов


### 2. Расскажите про иерархию коллекций?</br></br>

   Первая иерархия</br>
   Collection делится на подколлекции:</br>
    - Set - описывает такую структуру как множество, содержащее неупорядоченные уникальные элементы. Есть стандартные реализации - TreeSet, HashSet,LinkedHashSet</br>
    - List - структура данных, которая хранит упорядоченную последовательность объектов. Реализации - ArrayList, Vector, LinkedList</br>
    - Queue - Хранит элементы в виде очереди, которая следует правилу First In First Out. Реализации - LinkedList, PriorityQueue</br></br>

   Вторая иерархия</br>
   Map делится на подколлекции:</br>
    - HashTable, LinkedHashMap, TreeMap


### 3. Почему Map - это не Collection, в то время как List и Set являются Collection?</br>
Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».


### 4. В чем разница между классами java.util.Collection и java.util.Collections?</br>
java.util.Collections - набор статических методов для работы с коллекциями.</br></br>

java.util.Collection - один из основных интерфейсов Java Collections Framework.


### 5. Что такое «fail-fast поведение»?</br>
fail-fast означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом</br></br>

Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.</br></br>

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):</br>
- при изменении коллекции счетчик модификаций так же изменяется;
- при создании итератора ему передается текущее значение счетчика;
- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.


### 6. Какая разница между fail-fast и fail-safe?</br>
В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.


### 7. Чем различается Enumeration и Iterator?</br>
- с помощью Enumeration нельзя добавлять/удалять элементы;
- в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
- Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.


### 8. Как между собой связаны Iterable, Iterator и «for-each»?</br>
Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.


### 9. Сравните Iterator и ListIterator.</br>
- ListIterator расширяет интерфейс Iterator
- ListIterator может быть использован только для перебора элементов коллекции List;
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next().</br>
  Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
- ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove().
  Iterator не поддерживает данного функционала.


### 10. Как поведёт себя коллекция, если вызвать iterator.remove()?</br>
Если вызову iterator.remove() предшествовал вызов iterator.next(),</br>
то iterator.remove() удалит элемент коллекции, на который указывает итератор,</br>
в противном случае будет выброшено IllegalStateException().


### 11. Чем Set отличается от List?</br>
List допускает дубликаты</br>
Set имеет только уникальные значения


### 12. Расскажите про интерфейс Set</br>
Интерфейс Set расширяет интерфейс Collection</br>
Представляет набор уникальных элементов</br></br>

Реализации:
- SortedSet - NavigableSet
- AbstractSet - HashSet - LinkedHashSet
- TreeSet


### 13. Что будет если добавлять элементы в TreeSet по возрастанию?</br>
Так как в основе TreeSet будет красное черное дерево, поэтому все элементы буду сбалансированы


### 14. Как устроен HashSet, сложность основных операций (16)</br>
- Реализует интерфейс Set
- Базовой структурой для HashSet является HashTable
- Повторяющиеся элементы не допускаются
- порядок элементов не сохранится, так как для сохранения элементов происходит на основании хеш-кода


### 15. Как устроен LinkedHashSet сложность основных операций
- Реализует интерфейс Set
- Базовой структурой для LinkedHashSet является LinkedList
- Порядок элементов будет сохранен
- Повторяющиеся элементы не допускаются


### 16. Как устроен TreeSet сложность основных операций
- Реализует интерфейс Set
- Базовой структурой для TreeSet является TreeMap
- Используется природный порядок элементов, основанный на Comparator


### 17. Расскажите про интерфейс List</br>
Интерфейс List расширяет интерфейс Collection</br>
Представляет собой список


### 18. Как устроен ArrayList сложность основных операций
- Это список реализованный на основе массива
- Доступ к элементу по индексу за константное время
- Доступ к элементам по значению за линейное время
- Вставка в конеч за константное время
- Удаление из списка варьируется
- Вставка элемента варьируется
- необходимо одно единое пространство для хранения


### 19. Как устроен LinkedList сложность основных операций
- Это двусвязный список, основанный на объектах с ссылками между ними
- на получение элемента по индексу необходимо линейное время
- На добавление и удаление потребуется константное время
- На поиск позиции и вставки или удаления за константное время


### 20. Почему LinkedList реализует и List и Deque</br>
- LinkedList позволяет добавлять элементы в начало и в конец списка, что хорошо согласуется с Deque


### 21. Как перестроить Связанный список в HashTable</br>
Переопределить hashCode и использовать  "адрес в память"


### 22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?</br>
у них должен быть реализован метод для создания ключа и значения должны быть финализированы</br>
equals и hashCode

### 23. Как работает HashMap?
- HashMap представляет собой динамический массив, так как он умеет расширяться
- Пока в HashMap нет ни одного элемента массив не иницализируется
- После инициализации массива, каждый элемент массива будет представлять из себя корзину `bucket`, представленный в виде LinkedList
- Каждый элемент LinkedList представлдяет собой Node, с полями (hash, key, value, next) (односвязанный список)
- При добавлении элемента
  - Вычисляется хэш ключа 
  ```
  // default
  static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```
  - Вычисляется индекс бакета
  ```
  // n - длина массива
  i = (n - 1) & hash
  ```
  - Создается объект Node
  - Получаем список по индексу
    - Если в списке пусто, то размещаем элемент</br>
    - Если в списке есть элементы, то хэш и ключ первого элемента поочередно сравнивается с хэшами элементов из списка
    `(p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))`
    - Если в результате всех проверок всегда был возвращен false, то элемент добавляется в конец листа
    - Если было найдено совпадение, то заменяем текущие значения на новые
  - Увеличиваем количество элементов
  - Проверяем loadFactor
  
### 24. Как строиться красное-черное дерево?
- Элементы сортируется по хеш-коду
- Делятся на 2 ветки, начиная с первого элемента списка
- Остальные элементы распределяются направо и налево в зависимости от значения хешей
- Все левые меньше своего корневого, все правые больше
- Если хеш код элементов совпадает, то вызывается нативный `System.identityHashCode()` для вычисления хеша

### 25. На чем основана HashSet?
HashSet работает так же как и HashMap только для значения она использует объект-заглушку


## END ---------------- Коллекции ----------------

## База данных

+ [1. В чем разница между Statement и PreparedStatement?](#1-в-чем-разница-между-statement-и-preparedstatement)
+ [2. План исполнения запроса](#2-план-исполнения-запроса)
+ [3. Как работает индекс в таблице](#3-как-работает-индекс-в-таблице)
+ [4. Блокировка таблицы](#4-блокировка-таблицы)
+ [5. Транзакции](#5-транзакции)
+ [6. Пул соединений к БД](#6-пул-соединений-к-бд)
+ [7. Функция vs Процедура](#7-функция-vs-процедура)
+ [8. Что означает ASID](#8-что-означает-asid)


### 1. В чем разница между Statement и PreparedStatement?</br>
Statement - не защищен</br>
PreparedStatement - переданные параметры защищены от sql инъекций


### 2. План исполнения запроса</br>
Пример Postgresql</br></br>

   Explain [(OPTION [,...])]</br>
- Analyze [boolean] - запрос выполнится и составит план выполнения
- Verbose [boolean] - добавит дополнительную информацию
- Costs [boolean] - добавит стоимость каждого запроса
- Buffer [boolean] - определяет число блоков с диска и из кеша
- Timing [boolean] - Время запуска и время выполнения на каждом узле
- Summary [boolean]
- Format [TEXT|XML|JSON|YAML] - для подготовки отчета


### 3. Как работает индекс в таблице
1. Таблица без индексов выглядит как куча (Heap). При запросе будет сканироваться вся таблица
2. Преимущества индексов
   - Повышают скорость поиска информации и производительность запросов
3. Недостатки
   - Требуют много места на диске и в оперативной памяти
   - Замедляют производительность системы (медленнее выполняются операции вставок, обновлений, удалений)
4. Структура
   - Состоят из:
   - наборов страниц
   - узлов, имеющих древовидную структуру, иерархическую
   - Хранятся в виде сбалансированных B-деревьев
   - При создании индекса создаются указатели на строки таблицы, которые удовлетворяют условию
5. Виды индексов
   - Составной (несколько колонок)
   - Функциональные или индекс по выражению
   - Обычный, по одной колонке
6. Типы индексов
   - B-tree (дефолтное)
   - Hash - хранятся в 32-битной хеш код, полученный из значения индексируемого столбца
     Обрабатывает только операции равенства (медленнее чем B-tree в Posgtresql)
   - Gist - это инфраструктура, в которой можно реализовать множество стратегий индексирования</br>
   Подходит для вычисления гео данных, расстояние, пересечение площадей</br>
   Есть триграм, позволяет искать по вхождению и индексировать (regexp)
   - Sp-gist - это инфраструктура, которая поддерживает различные виды поиска.
     Позволяет реализовать несбалансированные дисковые структуры данных
   - Gin - инвертированные индексы, которые подходят для данных, содержащих компонентные значения, например массивы
   - Brin - хранят сводки о значениях, хранящихся в последовательных диапазонах физических блоков таблицы


### 4. Блокировка таблицы</br>
Виды блокировок
- Разделяемые (shared locks) - блокировка на чтение
- Монолитные (exclusive locks) - блокировка на чтение и запись</br>

   --- Табличная блокировка (exclusive lock)

   `Lock Tables`

| +         | -      | 
|---------------------|-----------------------------|
| требуют небольшого объема памяти  | Отстуствует параллелизм   |
| быстрая работа при блокировке большого количества таблиц     | Все остальные операции ждут |
| быстрая работа при операциях Group by или при полном сканировании |   |
 | Подходит когда данные меняются редко                      |     |


   --- Пользовательская блокировка - конкретной строки
   ```SELECT GET_LOCK(‘key’, 10); - key & timeout```

| +         | -                                                                            | 
|------------------------------------------------------------------------------|-----------------------------|
| одна блокировка для всех приложений  | Небезопасно использовать с репликацией на основе SQL-выражений               |
| Блокировка на уровне приложения | Из-за возможности вызвать сколько угодно lock опасность множества блокировок |
| Подобие транзакции |                                                                              |
| Меньше издержки чем у транзакции |                                                                              |


   ---Глобальная блокировка

   При применении
    - конфликтует с другими блокировками
    - Вызывает снятие всех предыдущих блокировок

| +         | -      | 
|---------------------|-----------------------------|
| Для получения резервной копии  | Нужно быть аккуратным и знать что делать  |
| Эту команду использует для быстрого alter таблиц | Может быть довольно длительной, так как будет дожидаться выполнения всех Select запросов |
| не так затратна как полная остановка сервера, так как большая часть информации кешируется |   |
| Используется для восстановления |     |

   ---Построчные блокировка

| +         | -      | 
|---------------------|-----------------------------|
| Лучшее управление конкуретным доступом  | Максимальные издержки |
| Позволяет одновременно выполнять несколько изменений одного ресурса | Приводит к взаимоблокировки |
| Позволяет заблокировать одну строку на долгое время | Работают медленнее табличных блокировок если используется большая часть таблицы|
| Меньше конфликтов блокировок |  Работают намного медленней при полном сканировании таблицы или для группировок Group by |


### 5. Транзакции
- Каждая транзация начинается с инструкции
  Begin Transaction и заканчивается
  Commit или Rollback

- Транзакция - это совокупность операций над базов, которые могут быть либо выполнены все вместе либо не будет выполенна ни одна из них

- Транзакции основаны на многоверсионной модели (Multiversion Concurrency Control)
    - каждый Sql оператор видит так называемый снимок данных (snapshot)
    - Снимок - это не физическая копия всей базы, это несколько чисел, которые идентифицируют текущую транзакцию и те транзакции,
      которые уже выполнились в момент начала текущей

**Свойства транзакий**
- Атомарность - транзакция либо выполняется полностью, либо не выполняется совсем
- Согласованность - после успешного выполнения транзакции база данных должны быть приведена из олного состояние в другое
- Изолированность - Во время выполнения транзации другие транзакции должны оказывать минимальное влияние на нее
- Долговечность - После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных

**Риски**
   
  - _Потерянное обновление (lost update)_ - Когда разные транзакции одновременно изменяют ожни и те же данные, то после фиксации изменений может оказаться,
  что одна транзакция перезаписала другую
  - Грязное чтение (dirty read) - Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась.
  Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе
  - _Неповторяющиеся чтение (non-repeatable read)_ - При повторном чтении тех же данных в рамках одной транзакции оказывается, что другая транзакция успела изменить
  и зафиксировать эти данные
  - _Фантомное чтение (phantom read)_ - Транзакция выполняет сборку данных и параллельно другая транзакция добавляет строки
  - _Аномалия сериализации (serialization anomaly)_ - Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одной
  из возможных вариантов упорядочения этих транзакций

**Уровни изоляции**

- Read uncommitted (dirty read)
- Read committed - только зафиксированные изменения
- Repeatable read (phantom read) - видим вставленные записи
- Serializable - самый безопасный


### 6. Пул соединений к БД</br>
   Это шаблон доступа к данным, основной целью которого является снижение накладных расходов, связанных с выполнение подключений к бд</br></br>

   Этапы соединения с БД</br>
    - Открытие соединения с БД с помощью драйверов
    - Открытие TCP  сокетов для чтения/записи
    - Чтение/запись данных через сокет
    - Закрытие соединения
    - Закрытие порта</br></br>

   Так как открытие соединения с БД это трудозатратная операция, мы можем настроить ряд соединений при старте приложения,</br>
   которыми мы будем пользоваться в процессе


### 7. Функция vs Процедура

**Функции**
- Имеет возвращаемый тип и возвращаемое значение
- Использование DML(insert, update,delete) запросов внутри функции невозможно.
  Разрешены только SELECT запросы
- Не имеет выходных аргументов
- Вызов хранимой процедуры из функции невозможен
- Вызов функции внутри SELECT запросов возможен

```
   //создает или заменяют функцию с именем
   CREATE [or REPLACE] FUNCTION function_name
   (param_list)
   // возвращаемый тип
   RETURN return_type
   LANGUAGE plpgsql
   as
   $$
   // объявление переменных
   DECLARE
   -- variable declaration
   // начало запроса
   BEGIN
   -- logic
   // окончание запроса
   END;
   $$
```
**Процедура**
- Не имеет возвращаемого типа, но имеет выходные аргументы 
- Использование DML запросов возможно 
- Имеет входные и выходные аргументы 
- Использование или управление транзакциями возможно в хранимой процедуре 
- Вызов процедуры из SELECT запросов невозможен
```
   CREATE [or REPLACE] PROCEDURE procedure_name
   (param_list)
   LANGUAGE language_name
   AS
   $$
   -- stored-procedure-body
   $$
```

### 8. Что означает ASID
- Atomicity - Атомарность
- Consistency - Согласованность
- Isolation - Изолированность
- Durability - Надежность</br>

1. _Атомарность_ гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем</br>
Не допускаются промежуточные состояния
2. _Согласованность_ - транзакция, достигающая своего завершения(EOT - end of transaction) и, тем самым, фиксирующая свои результаты, согхраняет согласованность базы данных</br>
Упорядоченное множество операций, переводщих базу данных из одного согласованного состояние в другое
3. Изолированность - во время выполнения транзакции параллельные транзакции не должны оказывать влияния на ее результат
4. Надежность - Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя

### 9. JSONB в Postgresql

## END ---------------- База данных ----------------

## Concurrency

+ [1. В чем разница между sleep() и wait()?](#1-в-чем-разница-между-sleep-и-wait)

### 1. В чем разница между sleep() и wait()?
wait - освобождает монитор</br>
sleep- не освобождает монитор

## END ---------------- Concurrency ----------------

## Spring

+ [1. Что такое Autowiring и как работает](#1-что-такое-autowiring-и-как-работает)
+ [2. Плюсы и минусы @Autowired](#2-плюсы-и-минусы-autowired)
+ [3. Как создаются контекст и бины? Опишите флоу создания спринг приложения](#3-как-создаются-контекст-и-бины-опишите-флоу-создания-спринг-приложения)
+ [4. В чём разница между @Component, @Service и @Repository аннотациями?](#4-в-чём-разница-между-component-service-и-repository-аннотациями)
+ [5. AOP](#5-aop)
+ [6. Spring boot](#6-spring-boot)
+ [7. RestTemplate](#7-resttemplate)
+ [8. Как активировать/деактивировать Бин](#8-как-активироватьдеактивировать-бин)
+ [10. Как работает Spring изнутри](#10-как-работает-spring-изнутри)
+ [11. Hibernate](#11-hibernate)
+ [12. @PreDestroy что это такое и зачем он нужен](#12-predestroy-что-это-такое-и-зачем-он-нужен)
+ [13. КТо уничтожает бин со Scope prototype](#13-кто-уничтожает-бин-со-scope-prototype)
+ [14. Аннотация @Cachable](#14-аннотация-cachable)
+ [15. Аннотация @Async](#15-аннотация-async-)

### 1. Что такое `Autowiring` и как работает</br>
   **IOC** - Inversion of control</br>
   делегирование части обязанностей внешнему компоненту</br>
Управление отдается на сторону, но мы получаем возможность гибко конфигурировать и подменять модули</br></br>

Бин - создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект</br></br>

ApplicationContext - Это сердце спринга. Как правило, он создается в самом начале работы приложения</br></br>

По умолчанию каждый бин имеет внутриспринговое свойство 'scope' в значении 'singleton',</br>
то есть создается ровно один экземпляр класса
```
Определение бина
ИЛИ В файле xml
<bean id="product" class="main.java.Product"></bean>
// Указание места сканирования
<context:component-scan base-package="main"/>
// Поднять контекст из файл xml
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```
Как работает</br>
При поднятии контекста создается бин-объект всех объектов, которые помечены аннотациями `@Component`, `@Service`, `@Controller`, `@Repository`</br>
Когда спринг видит аннотацию @Autowired он начинает искать подходящий бин. Если бин только один, то он без проблем его инжектит</br></br>

Аннотация `@Autowired` можно ставить
- На поле
- На сеттеры
- На определенные методы</br></br>

Если оддинаковых бинов несколько
- Для определения конкретного бина необходимо использовать аннотацию '@Qualifier("dependency1") ServiceDependency'
- Для использования всех бинов
```
@Autowired
public void setDependency(ServiceDependency[] dependencies)
```

### 2. Плюсы и минусы `@Autowired`

| +  | -   | 
|-----|-----|
|  Требует меньше кода  | Менее экспрессивный, чем явное инжектирование |
|  Уменьшает время разработки | Усложняет автонаписание инструкций |
|    | Множетвенные инъекции могут пересекаться с названием конкруктора|

   **Ограничения**
   - Явные зависимости и аргументы конструктора и свойства всегда переписывают инъекции
   - Инъекции через констркутор всегда переписывают инекции свойств
   - Нельзя переписать примитивы
   - Сложно ориентироваться при большом количестве инъекций

### 3. Как создаются контекст и бины? Опишите флоу создания спринг приложения
- Application -> StartingEvent
Когда мы пишем `SpringApplication.run`
  - Находит всех слушателей и кидает событие, что приложение начало строиться
- Application -> EnvironmentPreparedEvent, EnvironmentPostProcessor's
  - Слушателели находят `EnvironmentPostProcessor` и дают им настроить environment
- Application -> PreparedEvent, Application ContextInitializer's
  - В этот момент environment уже настроен и начинает строиться контекст
  - В этот же момент всем `ApplicationInitializer` получают возможность с данным контекстом что-то сделать
- Context -> RefreshEvent
  - Контекст настроен и начинают работать `BeanFactoryPostProcessor`, `BeanPostProcessor`
- EmbeddedServler -> Container InitializedEvent
- Application -> ReadyEvent

### 4. В чём разница между @Component, @Service и @Repository аннотациями?
   **@Component** - универсальный компонент</br></br>

   **@Repository** - компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.class</br>
   умеет перехватывать спецефичные для платфомы исключения и повторно генерирует их как одно из унифицированных непроверенных исключений Spring</br>
   Бин проксируется и ему добавляются exception handlers</br></br>

   **@Service** - фасад для некоторой бизнес логики</br></br>

   **@Controller** - класс, в котором указываются контроллеры приложения</br>
   Для получения объекта body внутри методов необходимо дополнительно использовать аннотацию @RequestBody</br>
   Используется для возврата view
```
@Controller
@RequestMapping("books")
public class SimpleBookController {

    @GetMapping("/{id}", produces = "application/json")
    public @ResponseBody Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```
   **@RestController** - Это специализированная сервис контроллера. Включает в себя @Controller и @ResponseBody аннотации</br>
   Необходим при написании REST запросов
```
@RestController
@RequestMapping("books-rest")
public class SimpleBookRestController {
    
    @GetMapping("/{id}", produces = "application/json")
    public Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```
   **@Configuration** - класс для настройки приложения, объявления бинов


### 5. AOP</br>
   Аспектно-ориентированное программирование - это парадигма программирования, являющейся в дальнейшем развитием процедурно и объектно-ориентированного программирования</br></br>

   **Join Point** - это точки наблюдения, присоединения к коду, где планируется введение функциональности

```
@Pointcut("execution(* com.example.spring._10.AOP_order.dao.*.*(..)))")
public void forDaoPackage () {}
```
   **Pointcut** - Это срез, запрос точек присоединения</br></br>

   **Advice**  - набор инстракций выполняемых на точках среза (может быть несколько для одного Pointcut)
   - Before - Перед вызовом метода
   - After - После вызовом метода
   - After returning - После возврата значения
   - After throwing - В случае exception
   - After finally - В случае выполения блока finally
   - Around - можно сделать пред, пост обработку перед вызовом метода, а также вообще обойти вызов метода

   **Aspect**</br>
   модуль, в котором собраны описанные Pointcut и Advice


### 6. Spring boot</br>
   В базе используется сервер Tomcat</br></br>

   Без Spring Boot
- Импортировать необходимые Spring-модули
- Импортировать библиотеку web-контейнеров (в случае web-приложения)
- Импортировать сторонние библиотеки (Hibernate, Jackson)
- Искать версии, совместимые со Spring
- Конфигурировать компонент DAO, такие как источник данных, управление транзакциями ит т.д.
- Конфигурировать компоненты web-слоя, такие как диспетчер ресурсов, view resolver
- Определить класс, который щагрузит все необходимые конфигурации</br></br>

   Основные особенности
    1. Управленияе зависимостями
    2. Автоматическая конфигурация
    3. Встроенные контейнеры сервлетов

- Spring упаковывает необходимые сторонние зависимости для каждого типа приложения посредством starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa)
- Spring автоматически конфигурирует зарегистрированные бины в зависимости от подключенного стартера
- Каждое Spring-boot приложение включает встроенные web-сервлеты
  Spring ам настроивает контейнер сервлетов.
  Приложение может запускаться как jar-файл</br></br>

Основной класс приложения

**@SpringBootApplication** - включает в себя
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan


### 6. Hibernate ленивая инициализация (LazyInitialization)</br>
   @OneToMany(fetch=FetchType.Lazy)

Для акцивации такой связи необходимо проверить било ли инициализировано</br>
boolean success = Hibernate.isInitialized(products);</br></br>

Инициализировать</br>
Hibernate.initialize(post);


### 7. RestTemplate
```
@Bean
public RestTemplate restTemplate (RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofMills(3000))
        .setReadTimeout(Duration.ofMills(3000))
        .build();
}

@Bean
public RestTemplate restTemplate () {
    RestTemplate restTemplate = new RestTemplate();
    return restTemplate;
}
```

### 8. Как активировать/деактивировать Бин</br>
   @Profile("dev")</br>
   @Profile("production")</br></br>

Добавляет возможность включать/выключать бины для разных окружений</br></br>

В файлу 'application.properties'</br>
spring.profiles.active=dev</br></br>

Дополнительно в интерфейсе 'ConfigurableEnvironment' можно установить настройки активных профилей вызвав 'SpringApplication.setAdditionalProdiles(...)'


### 9. Spring Filters

Для создания фильтры необходимо создать бин и заинжектить интерфейс 'Filter'
```
@Component
@Order(1)
public class TransactionFilter implements Filter {
    @Override
    public void doFilter (
        ServlerRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOExeprion, ServlerException {
        HTTPServlerRequest req = (HTTPServlerRequest) request;
        
        LOG.info("Staring a transaction for req: {}");
        
        req.getRequestURI();
        
        chain.doFilter(request, response);
        
        LOG.info("Commiting a transaction for req: {}");
        
        req.fetRequestURI();
    }
}
```
Мы можем извлечь

`url = req.getRequestURI();`

`method = req.getMethod();`

`contentType = res.getContentType();`

Регистрация бина
```
@Bean
public FilterRegistrationBean<RequestResponseLoggingFilter> loggingFilter () {
FilterRegistrationBean<RequestResponseLoggingFilter> registrationBean = new FilterRegistrationBean<>();

    registrationBean.setFilter(new RequestResponseLoggingFilter());
    registrationBean.addUrlPattern("users");
    registrationBean.setOrder(2);

    return registrationBean;
}
```

### 10. Как работает Spring изнутри</br>

**Ключевые понятия**
- Бины - это обычный объект, который живет внутри DI-контейнера
- DI-контейнер - Ключевой и фундаментальный механизм Spring.</br></br>
    
Спринт - это по сути набор бинов, связанных вместе через DI контейнер</br>
При конфигурации например 'OAuth' в 'application.properties' спринт предоставляет бин 'OAuth2RestTemplate'</br>
При этом этот бин при обращении к внешнему API будет знать, куда и как пойти, чтобы получить OAuth токен</br>
как его обновлять, в какое место нашего запроса его добавлять и т.д.</br>
То есть контейнер - это механизм общения между нашим кодом и библиотеками, подключенными к проекту</br></br>

Использование инъекций зависимостей не подразумевает создания интерфейсов для каждого компонента.</br></br>

- Контекст - Представлен интерфейсом 'ApplicationContext'. Позволяет реагировать на различные события,</br>
  которые происходят внутри приложения, управлять жизненным циклом

- Конфигурация - описание доступных бинов</br>
  Бины могут быть описаны как в одном файле, так как и в разных

- Сканирование компонентов - спринг сканирует приложений на предмет таких аннотаций как @Component, @Service и т.д. и создает из них бины</br>
  при этом это считается неявным изменением контекста приложения</br></br>

**Spring boot**</br></br>

_Автоконфигурация_</br></br>

Это набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении.</br>
Можно сказать, что сам Embedded Servler Container - это тоже еще один бин</br></br>

- Включается аннотацией '@EnableAutoConfiguration'
- Работает в последнюю очередь, после регистрации пользовательских бинов
- Принимает решение о конфигурации на основании доступных в classpath классов, свойств в 'application.properties'
- Можно включать и выключать разные аспекты автоконфигурации
- Всегда отдает приоритет пользовательским бинам</br></br>

**Условия и порядок регистрации бинов**</br></br>

Логика при регистрации бинов управляется набором `@ConditionalOn*` аннотаций </br>
Можно указать, чтобы быин создавался при наличии в classpath (@ConditionalOnClass), </br>
наличии существующего бина (@ConditionalOnBean), отсутствии бина (@ConditionalOnMissingBean)

```
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```
1. **@SpringBootApplication** - мета аннотация, алиас для нескольких аннотаций
- @SpringBootConfiguration
- @EnableAutoConfiguration
- @ComponentScan</br></br>

1. **SpringApplication.run()**</br>
    это хелпер, который используя список предоставленных конфигураций создает 'ApplicationContext',</br>
    конфигурирует его, выводит баннер в консоли и засекает время старта приложения</br>

2. **AnnotationConfigEmbeddedWebApplicationContext** - Наследник Spring Boot</br>
    знает о embedded servlet container-ах и умеет их запускать

3. **@EnableAutoConfiguration** - включает автоконфигурацию
```
@Import(EnableAutoConfigurationImportSelector.class)
    public @interface EnableAutoConfiguration {
        ...
    }
}
```

`EnableAutoConfigurationImportSelector` - это конфигурация, которая добавит несколько бинов в контекст.</br>
Этот класс не объявляет бины сам, а использует так называемые фабрики.</br>
Класс смотрит в файл 'spring.factories' и загружает оттуда список значений, которые являются именами классов ((авто)конфигураций),</br>
которые Spring Boot импортирует</br></br>

**Этапы инициализации**

1. Парсирование конфигурациии создание 'BeanDefinition'</br>
Задача данного этапа - это создание всех 'BeanDefinition'.</br>
'BeanDefinition' - это специальный интерфейсы, через который можно получить доступ к метаданным будущего бина

2. Настройка созданных 'BeanDefinition'</br>
  После первого этапа у нас имеется Map, в котром хранятся 'BeanDefinition'</br>
  Спринт дает нам возможность повлиять на то, какими будут наши бины еще до их создания,</br>
  то есть мы можем получить доступ к метаданным класса.</br>
  Для получения доступа к метаданным есть специальный интерфейс 'BeanFactoryPostProcessor'</br>
```
public interface BeanFactoryPostProcessor {
`void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
```
Данная фабрика содержит такие методы как 'getBeanDefinitionNames', через который можно получить все 'BeanDefinitionNames',</br>
а потом по конкретному имени получить 'BeanDefinition' для дальнейшей обработки метаданных</br></br>

Например, если в классе есть поля, которые должны быть заполнены из файла '.propeties' </br>
   то после постпроцессинга они будут добавлены к класс бина</br></br>

3. Создание кастомных `FactoryBean`
актуально если бины до сих пор создаются через xml и нужно создать ряд бинов, у которых не сильно отличаются настройки

4. Создание экземпляров бинов</br>
  Созданием экземпляров бинов занимается 'BeanFactory' при этом можно дерегировать это кастомным 'FactoryBean'</br>
  Экземпляры бинов создаются на основе ранее созданных 'BeanDefinition'</br>
  После создания бина он добавляется в Map<BeanName, Bean></br></br>

5. Настройка созданных бинов</br>
  Интерфейс 'BeanPostProcessor' позволяет вклиниться в процесс настройки бинов, до того как они попадут в контейнер
```
public interface BeanPostProcessor {
  Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // до init метода
  Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; // после init метода
}
```

* Если нужно сделать прокси над объектом, то лучше это делать в `postProcessAfterInitialization`
* `BeanPostProcessor` обязательно должен быть бином


### 11. Hibernate
ORM - Object-relational mapping - это отображение объектов какого-либо объектно-ориентированного языка в структуры реляционных баз данных

Hibernate - заботится о связи Java классов с таблицами бд, а также предоставляет средства для автоматического построения запросов и извлечения данных

Внутри используется собственный язык запросов Query Language или HQL


### 12. @PreDestroy что это такое и зачем он нужен</br>
Если мы указывем аннотацию @PreDestroy над методом, то этот метод будет вызван при закрытии контекста

### 13. КТо уничтожает бин со Scope prototype</br>
Он уничтожается garbage collector после того как все ссылки на него будут уничтожены</br>
В некоторых случаях советую явно уничтожать подобные бины</br>
Для этго можно написать пост процессор, методы которого будут явно уничтожать компоненты прототипа

### 14. Аннотация `@Cachable`</br>
https://habr.com/ru/companies/rosbank/articles/694768/ </br>
Если мы хотим закешировать методы, мы ставим данную аннотацию, которая создать мапу с закешированными значениями
```
@Cacheable(cacheNames = {"signature"},  key = "{#userId}")
public Set<SignatureLevel> getSignatureLevels(long userId) {
      //логика
}
```

### 15. Аннотация `@Async` </br>
Позволяет запускать методы в фоновом потоке </br>
- Для активации необходимо добавить аннотацию `@EnableAsync` над основным классом приложения
```
@Configuration
@EnableAsync
public class AsyncConfiguration extends AsyncConfigurerSupport {
//…. 
}
```
- Аннотация применяется только на публичных методах
- Нельзя вызывать метод из того же класса, к которому он принадлежит
- Если метод должен что-то возвращать, то возвращаемый тип должен быть `CompletableFuture`


## END ----------------- Spring -----------------

## Kafka

+ [1. Основной принцип работы kafka](#1-основной-принцип-работы-kafka)
+ [2. Если у нас есть несколько инстансов одного микросервиса сообщений, как отправить только одно сообщение](#2-если-у-нас-есть-несколько-инстансов-одного-микросервиса-сообщений-как-отправить-только-одно-сообщение)
+ [3. Максимальный объем сообщения](#3-максимальный-объем-сообщения)
+ [4. Какие гарантии Kafka дает](#4-какие-гарантии-kafka-дает)
+ [5. Подходит ли Kafka для пересылки больших сообщений](#5-подходит-ли-kafka-для-пересылки-больших-сообщений)
+ [6. Что произойдет если Kafka отправит большое сообщение (Poison Message)](#6-что-произойдет-если-kafka-отправит-большое-сообщение-poison-message)
+ [7. Что означает Идемпотентность](#7-что-означает-идемпотентность)
+ [8. Как настроить отправку только одного сообщения (exactly one)](#8-как-настроить-отправку-только-одного-сообщения-exactly-one-)

### 1. Основной принцип работы kafka
- Kafka использует pull (получатели сами достают из топика сообщения)
- Другие сервисы используют push ратегию (отправляют сообщения получателям)

### 2. Если у нас есть несколько инстансов одного микросервиса сообщений, как отправить только одно сообщение
- consumer group концепция
- Назначить consumer group id для инстансов, после чего кафка сама позаботится о разделении сообщения для разных инстансов
- Необходимо чтобы все инстансы одного микросервиса имели один и тот же group id

### 3. Максимальный объем сообщения</br>
10 мб

### 4. Какие гарантии Kafka дает</br>
Что сообщение будет доставлено как минимум одному получателю

### 5. Подходит ли Kafka для пересылки больших сообщений</br>
Нет, Kafka заточена под пересылку большого количества сообщений небольшого размера</br>
Если необходимо отправить большой файл, то нужно его сохранить в какое-то хранилище и в сообщении передать ссылку на него

### 6. Что произойдет если Kafka отправит большое сообщение (Poison Message)</br>
У получателя произойдет ошибка, которую скорее всего он не обрабатывает. Эта ошибка повлияет на последющие сообщения</br>
Для избежания таких ситуаций можно добавить кастомную обработку при получении сообщений

### 7. Что означает Идемпотентность</br>
https://habr.com/ru/companies/badoo/articles/333046/ </br>
свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом (чистые функции)

### 8. Как настроить отправку только одного сообщения (exactly one) </br>
```
enable.idempotence=true
```
Каждый пакет, отправленный Kafka, будет содержать порядковый номер, при помощи которого блокер сможет устранить дублирование данных

## END ----------------- Kafka -----------------

## Stream

+ [1. Стримы Общее](#1-стримы-общее)
+ [2. Collectors](#2-collectors)
+ [3. Функциональный интерфейсы](#3-функциональный-интерфейсы)
+ [4. Меняет ли начальные данные stream?](#4-меняет-ли-начальные-данные-stream)
+ [5. Почему стримы, в чем основная фишка](#5-почему-стримы-в-чем-основная-фишка)

### 1. Стримы Общее
1. Stream из массива</br>
   Arrays.stream(array)</br></br>

2. Stream из ArrayList</br>
   list.stream()</br></br>

3. Stream из Map</br>
   map.entrySet.stream()</br></br>

4. Stream из указанных элементов</br>
   Stream.of("1", "2", "3")</br></br>

5. Лист из указанных элементов</br>
   Arrays.asList("a1", "a2", "a3").stream()</br></br>

6. Стрим из файла</br>
   Files.lines(Paths.get("file.txt"))</br></br>

7. Стрим из строки</br>
   "123".chars()</br></br>

8. Создание из Stream.builder</br>
   Stream.builder().add("a1").add("a2").add("a3").build()</br></br>

9. Создание параллельного стрима</br>
   collection.parallelStream()</br></br>

10. Создание бесконечного стрима</br>
    Stream.iterate(1, n -> n +1)</br></br>

11. Создание бесконечных стримов с помощью</br>
    Stream.generate(() -> "a1"))</br></br>

   Методы
   1. Конвейерные - возвращают другой stream, то есть работают как builder
   2. Терминальные - Возвращают другой объект, такой как коллекция, примитивы, объекты, Optional</br></br>

        ! У стрима может быть сколько угодно вызовов конвейерных методов  и в конце один терминальный</br>
        При этом все конвеейрные методы выполняются лениво и пока не будет вызван терминальный, никаких действий не происходит</br>

```
Конвейерные методы
   'filter'
   collection.stream()
    .filter("a1"::equals)
    .count()

    'skip' - позволяет пропускать первые N элементов
    collection.stream()
        .skip(collection.size() - 1)
        .findFirst()
        .orElse("1")

    'distinct' - возвращает стрим без дубликатов
    collection.stream()
        .distinct()
        .collect(Collectors.toList())

    'map' - преобразует каждый элемент массива
    collection.stream()
        .map((s) -> s + "_1")
        .collect(Collectors.toList())

    'peek' - возвращает тот же стрим, но применяет функцию к каждому элементу
    collection.stream()
        .map(String::toUpperCase)
        .peek((e) -> System.out.println("," + e))
        .collect(Collectors.toList())

    'limit' - ограничивает выборку определенным количеством элементов
    collection.stream()
        .limit(2)
        .collect(Collectors.toList())

    'sorted' - позволяет сортировать значения либо в натуральном порядке либо задавая Comparable
    collection.stream()
        .sorted()
        .collect(Collectors.toList())

    'mapToInt' - аналог map, но возвращает числовой стрим
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .toArray()

    'mapToDouble'
    'mapToLong'

    'flatMap' - похоже на map, о может создавать из одного элемента несколько
    'flatMapToInt'
    'flatMapToDouble'
    'flatMapToLong'

    collection.stream()
        .flatMap((p) -> Arrays.asList(p.split(",").stream()))
        .toArray(String[]::new)

    'reduce' - позволяет выполнять агрегатные функции на всей коллекцией, возвращает одно значение для стрима (Optional)
    collection.stream()
    .reduce((s1, s2) -> s1 + s2)
    .orElse(0)
```
```
Терминальные методы

    'findFirst' - возвращает первый элемент из стрима (Возвращает Optional)
    collection.stream()
        .findFirst()
        .orElse("1")

    'findAny' - возвращает плюбой подходящий элемент из стрима (Возвращает Optional)
    collection.stream()
        .findAny()
        .orElse("1")

    'collect' - представление результатов в виду коллекций и других структур данных
    collection.stream()
        .filter((s) -> s.contains("1"))
        .collect(Collectors.toList())

    'anyMatch' - возвращает true если условие выполняется хотя бы для одного значения
    collection.stream()
        .anyMatch("a1"::equals)

    'count' - возвращает количество элементов в стриме
    collection.stream()
        .filter((s) -> s.contains("1"))
        .count()

    'noneMatch' - возвращает true если условие не выполняется ни для одного элемента
    collection.stream()
        .noneMatch((s) -> s.contains("1"))

    'allMatch' - возвращает true если условие выполняется для всех элементов
    collection.stream()
        .allMatch((s) -> s.contains("1"))

    'min' - возвращает минимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .min(String::compareTo)
        .get()

    'max' - возвращает максимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .max(String::compareTo)
        .get()

    'forEach' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
    set.stream()
        .forEach((p) -> p.append("_1"))

    'forEachOrdered' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении гарантируется
    list.stream()
        .forEachOrdered((p) -> p.append("_1"))

    'toArray' - возвращает массив значений стрима
    collection.stream()
        .map(String::toUpperCase)
        .toArray(String[]::new)
```
```
Дополнительные методы числовых стримов

    'sum' - Возвращает сумму чисел
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .sum()

    'average' - Возвращает среднее арифметическое
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .average()

    'mapToObj' - Преобразует числовой стрим обратно в объект
    Stream.mapToObj((id) -> new Key(id))
        .toArray()
```
```
Другие методы
   'isParallerl' - Узнать является ли стрим параллельным

    'parallel' - Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
    
    collection.stream()
        .peek(...) // операция последовательная
        .parallel()
        .map(...) // операция мождет выполняться параллельно
        .sequential()
        .reduce(...) // операция снова последовательна
```

### 2. Collectors
   Методы стататические

   `toList` - Представляет стрим в виде списка
   `toCollection` - Представляет стрим в виде коллекции
   `toSet` - Представляет стрим в виде множества</br></br>

   `toConcurrentMap` - Преобразовывает стрим в Map
   `toMap` - Преобразовывает стрим в Map</br></br>

   `averagingInt` - Среднее значение
   `averagingDouble`
   `averagingLong`</br></br>

   `summingInt` - Возвращает сумму
   `summingDouble`
   `summingLong`</br></br>

   `partitioningBy` - разделяет коллекцию на две части по соответствующему условию</br>
   и возвращает как Map<Boolean, List></br></br>

   `groupingBy` - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>></br></br>

   `mapping` - дополнительные преобразования значений для сложных Collector-ов</br></br>

```
strings.stream()
    .collect(Collectors.joining(" "), "<b>", "</b>")

string.stream()
    .collect(Collectors.groupingBy((p) -> p.substring(0, 1)))
```

### 3. Функциональный интерфейсы

`Predicate`(filter) - означает, что он будет пропускать только те элементы, которые возвращают true
```
public static void main(String[] args) {
    List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
        .filter(x -> x % 2==0)
        .collect(Collectors.toList());
}
```

`Consumer`(peek, forEach)
```
public static void main(String[] args) {
    List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
        .peek(x -> System.out.println("Hello " + x + " !!!"))
        .collect(Collectors.toList());
}
```
`Supplier`(generate)
```
public static void main(String[] args) {
    ArrayList<String> nameList = new ArrayList<>();
    nameList.add("Elena");
    nameList.add("John");
    nameList.add("Alex");
    nameList.add("Jim");
    nameList.add("Sara");
    
    Stream.generate(() -> {
        int value = (int) (Math.random() * nameList.size());
        return nameList.get(value);
    }).limit(5).forEach(System.out::println);
}
```
`Function`(map)
```
public static void main(String[] args) {
    List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
}
```
`UnaryOperator`(iterate)

1. Элемент, с котрого начинается генерация
2. Указывает принцип генерации новых элементов
```
public static void main(String[] args) {
    Stream.iterate(9, x -> x * x)
        .limit(4)
        .forEach(System.out::println);
}
```

### 4. Меняет ли начальные данные stream?</br>
   нет

### 5. Почему стримы, в чем основная фишка</br>
Стримы представлены в виде чистых функций, при одиннаковых получаемых аргументах всегда возвращает один и тот же результат</br>
Являются потокобекзопасными, так как работают или с атомарными значениями или финализированными значениями </br>
Лучше всего подходит для манипуляции над одной структурой, без ее изменения

## END ---------------- Stream ----------------

## SOLID

- Single Responsibility Principle (Принцип единственной ответственности).
- Open Closed Principle (Принцип открытости/закрытости).
- Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
- Interface Segregation Principle (Принцип разделения интерфейса).
- Dependency Inversion Principle (Принцип инверсии зависимостей).</br></br>

'Single Responsibility Principle' - никогда не должно быть больше одной причины изменить класс.
</br></br>
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс
</br></br>
Пример:</br>
    Представьте себе модуль, который обрабатывает заказы.</br>
    Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа
</br></br>
Данный класс протировечит SRP так как он отвечает за 3 обязанности.</br>
В идеале это должны быть 3 отдельных класса, каждый из которых отвечает за свою область</br></br>

`Open Closed Principle` - программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.</br>
Должна быть возможность изменять внешнее поведеление класс, не внося физические изменения в сам класс.</br>
Класс должны разрабатываться так, чтобы для поднастройки класс к конкретным условиям применения было доставточно расширить его или переопределить некоторые функции
</br></br>
`Liskov’s Substitution Principle` - объекты в программе можно заменить их наследниками без изменения свойств программы.</br>
Класс, разработанный путем расширения на основании базового класса, должен переопределять его метода так, чтобы не нарушалась функциональность</br>
с точки зрения клиента. То есть не должно меняться ожидаемое поведение
</br></br>
`Interface Segregation Principle` - клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.</br>
Слишком "толстые" интерфейсы необходимо разделять на более мелкие, спецефические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе</br>
</br></br>
`Dependency Inversion Principle` - зависимости внутри системы строятся на основе абстракций.</br>
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономны и соединялись друг с другом с помощью абстракций

## END ---------------- SOLID ----------------

## Java 8

+ [1. Методы интерфейсов по умолчанию](#1-методы-интерфейсов-по-умолчанию)
+ [2. Лямбда-выражения](#2-лямбда-выражения)
+ [3. Функциональные интерфейсы](#3-функциональные-интерфейсы)
+ [4. Ссылки на методы и конструкторы](#4-ссылки-на-методы-и-конструкторы)
+ [5. Области действия лямбд](#5-области-действия-лямбд)
+ [6. Доступ к полям и статическим переменным](#6-доступ-к-полям-и-статическим-переменным)
+ [7. Доступ к методам интерфейсом по умолчанию](#7-доступ-к-методам-интерфейсом-по-умолчанию)
+ [8. Stream](#8-stream)
+ [9. Апи для работы с датами](#9-апи-для-работы-с-датами)
+ [10. Аннотации](#10-аннотации)

### 1. Методы интерфейсов по умолчанию 
```
interface Formula {
    double calculate(int a);
    
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```
### 2. Лямбда-выражения
```
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```
### 3. Функциональные интерфейсы
```
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
### 4. Ссылки на методы и конструкторы
```
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);
```
### 5. Области действия лямбд</br>
Лямбды могут ссылаться на переменные, обхявленные как final, на экземплярные поля класса и статические переменные
```
final int num = 1;
Converter<Integer, String> stringConverter = (from) -> String.valueOf(from + num);

stringConverter.convert(2);
```
переменная num не обязательно должна быть final, но должна быть неизменяемой

### 6. Доступ к полям и статическим переменным

### 7. Доступ к методам интерфейсом по умолчанию</br>
   Внутри лямбда-выражений запрещено обращаться к методам по умолчанию

### 8. Stream

### 9. Апи для работы с датами
- Clock
- Часовые пояса
- LocalTime
- LocalDate
- LocalDateTime

### 10. Аннотации
    @Repeatable

## END ---------------- Java 8 ----------------

## ENUM

+ [1. Зачем нужен enum?](#1-зачем-нужен-enum)
+ [2. Что такое enum?](#2-что-такое-enum)
+ [3. Как указать значения для свойсты и как их получить](#3-как-указать-значения-для-свойсты-и-как-их-получить)

### 1. Зачем нужен enum?</br>
Это класс для создания некоторого ограниченного круга значений
```
public enum DayOfWeek {
   SUNDAY,
   MONDAY,
   TUESDAY,
   WEDNESDAY,
   THURSDAY,
   FRIDAY,
   SATURDAY
}
```

### 2. Что такое enum?
Это финализированный класс, от него нельзя наследоваться

### 3. Как указать значения для свойсты и как их получить
```
public enum DayOfWeek {

   SUNDAY ("Воскресенье"),
   MONDAY ("Понедельник"),
   TUESDAY ("Вторник"),
   WEDNESDAY ("Среда"),
   THURSDAY ("Четверг"),
   FRIDAY ("Пятница"),
   SATURDAY ("Суббота");

   private String title;

   DayOfWeek(String title) {
       this.title = title;
   }

   public String getTitle() {
       return title;
   }

   @Override
   public String toString() {
       return "DayOfWeek{" +
               "title='" + title + '\'' +
               '}';
   }
}
```
Получение всех значений `DayOfWeek.values()`
Получение индекса константы `int sundayIndex = DayOfWeek.SUNDAY.ordinal();`
Получение индекса по значению `DayOfWeek sunday = DayOfWeek.valueOf("SUNDAY");`
## END ---------------- ENUM ----------------

26. Можно ли увеличить размер массива после его инициализации?
нет, только пересоздать новый массив


27. Как создать собственный иммутабельный класс?
final и без геттеров