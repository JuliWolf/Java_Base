https://github.com/johnivo/job4j/blob/master/interview_questions/Core.md#4-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-JDK

+ [REST vs SOAP](#rest-vs-soap)
+ [Основы](#основы)
+ [Garbage collector](#garbage-collector)
+ [Classloader](#classloader)
+ [ООП](#ооп)
+ [Процедурная Java](#процедурная-java)
+ [Потоки ввода/вывода](#потоки-вводавывода)
+ [ООП в Java](#ооп-в-java)
+ [Исключения](#исключения)
+ [Сериализация и копирование](#сериализация-и-копирование)
+ [Дженерики](#дженерики)
+ [Коллекции](#коллекции)
+ [База данных](#база-данных)
+ [Concurrency](#concurrency)
+ [Spring изнутри](#spring-изнутри)
+ [Spring](#spring)
+ [Spring Кеш](#spring-кеш)
+ [Spring Transactional](#spring-transactional)
+ [Spring Patterns](https://github.com/JuliWolf/Spring/blob/master/Spring-patterns/README.md)
+ [Hibernate & JPA](#hibernate--jpa)
+ [Kafka](#kafka)
+ [Stream](#stream)
+ [SOLID](#solid)
+ [ENUM](#enum)
+ [Maven](#maven)
+ [Servlet](#servlet)
+ [Swagger](#swagger)
+ [Nginx](#Nginx)
+ [Java 8](#java-8)
+ [Аутентификация и авторизация](#аутентификация-и-авторизация)
+ [JsonB](https://github.com/JuliWolf/Java_Base/blob/main/JsonB/README.md)
+ [Mockito & Junit](https://github.com/JuliWolf/Spring/blob/master/mockito/README.md)
+ [DDD](ddd.md)

## REST vs SOAP

+ [1. Как расшифровывается REST](#1-как-расшифровывается-rest)
+ [2. Что такое REST](#2-что-такое-rest)
+ [3. Какие принципы есть у REST](#3-какие-принципы-есть-у-rest)
+ [4. Что такое SOAP](#4-что-такое-soap)
+ [5. Как SOAP и REST используют HTTP протокол](#5-как-soap-и-rest-используют-http-протокол)
+ [6. В каком формате должны возвращаться данные при REST и SOAP](#6-в-каком-формате-должны-возвращаться-данные-при-rest-и-soap)
+ [7. С чем работает SOAP и REST](#7-с-чем-работает-soap-и-rest)
+ [8. Когда лучше использовать SOAP](#8-когда-лучше-использовать-soap)
+ [9. Когда лучше использовать REST](#9-когда-лучше-использовать-rest)

### 1. Как расшифровывается REST
Representational State Transfer - передача состояния представления
Запрос ресурса с сервера переводит клиентское приложение в определенное состояние (state)</br>
а запрос следующего ресурса меняет состояние приложения (transfer)</br>
Representational означает, что ресурс возвращается не просто так, а в каком-то представлении</br>

### 2. Что такое REST
REST - это архитектурный стиль

### 3. Какие принципы есть у REST
- Give every 'thing' an ID
- Link things together - В страницу о Mercedes C218 лучше добавить ссылку о двигателе данной моделе
- Use standard methods - использовать стандыртный методы HTTP
- Resources can have multiple representations - Одни и те же данные можно вернуть в XML или JSON
- Communicate statelessly - REST просто отвечает на запрос, вне зависимости от предыдущих запросов

### 4. Что такое SOAP
SOAP(Simple Object Access Protocol) - это целое семейство протоколов и стандартов</br>
Это более тяжеловесный и сложный вариант с точки зрения машинной обработки</br>
SOAP стандартизирован

### 5. Как SOAP и REST используют HTTP протокол
SOAP использует HTTP как транспортный протокол</br>
REST базируется на HTTP</br>

В REST работают все наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование</br>
В SOAP необзодимо искать другие средства для реализации наработок</br>

SOAP могут работать с любым протоколом транспортного уровня вместо HTTP

### 6. В каком формате должны возвращаться данные при REST и SOAP
SOAP - привязан к XML</br>
REST - не привязан к формату, может возвращать любой формат

### 7. С чем работает SOAP и REST
SOAP работает с операциями </br>
REST работает с ресурсами </br>

* транзации или сложная логика должна реализовываться SOAP

### 8. Когда лучше использовать SOAP
Когда необходимо делать многочисленные проверки данных, повышенная безопасность и устойчивость

### 9. Когда лучше использовать REST
Для простых операций, который независимы друг от друга (CRUD)

## END ---------------- REST vs SOAP ----------------

## Основы

+ [1. Какие преимущества у Java?](#1-какие-преимущества-у-java)
+ [2. Какие недостатки у Java?](#2-какие-недостатки-у-java)
+ [3. Что такое JVM, JDK, JRE? В чем отличия?](#3-что-такое-jvm-jdk-jre-в-чем-отличия)
+ [4. Что такое byte code?](#4-что-такое-byte-code)
+ [5. Что такое загрузчик классов classloader?](#5-что-такое-загрузчик-классов-classloader)
+ [6. Что такое JIT?](#6-что-такое-jit)
+ [7. Что такое String[] args в методе main()?](#7-что-такое-string-args-в-методе-main)
+ [8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?](#8-что-такое-пакеты-зачем-они-нужны-какие-пакеты-по-умолчанию-подключены)
+ [9. Какой дефолтный оператор доступа у класса](#9-какой-дефолтный-оператор-доступа-у-класса)
+ [10. Какие типы принимает System.out.printLn](#10-какие-типы-принимает-systemoutprintln)

### 1. Какие преимущества у Java?
- Основное преимущество  - кроссплатформенность
- Огромный выбор библиотек под любые задачи
- Автоматическое управление памятью
- Многопоточность
- ООП

### 2. Какие недостатки у Java?
- Низкая скорость в сравненни с С и С++
- Требует много памяти
- Нет поддержки низкоуровневого программирования (например указателей)
- Планирование новой программы занимает много времени из-за ООП
- Многословность

### 3. Что такое JVM, JDK, JRE? В чем отличия?

   `JVM(Java Virtual Machine)` — это часть платформы Java, которая исполняет программы.
   программа, предназначенная для выполнения байт-кода. Преимущество - "Write once, run anywhere"

   `JRE(Java Runtime Environment)` — это элемент Java, расположенный на диске, создающий и запускающий JVM
   это пакет всего необходимого для запуска скомпилированной Java программы

   `JDK(Java Development Kit)` - позволяет разработчикам создавать Java-программы, которые могут выполняться и запускаться посредством JVM и JRE. JDK = JRE + компилятор
   включает в себя около 40 различных тулов (компилятор, лаунчер приложений, java debugger etc.

### 4. Что такое byte code?
- это стандартное промежуточное представление [en], в которое может быть переведена компьютерная программа автоматическими средствами.

### 5. Что такое загрузчик классов classloader?
   Это объект, которые отвечает за загрузку классов. ClassLoader  это абстрактный класс

### 6. Что такое JIT?
   Если в программе присутствуют части кода, которые выполняются много раз,</br>
   то их можно скомпилировать один раз в машинный код, чтобы в будущем ускорить их выполнение.</br>
    - Ускорение работы программы достигается за счет увеличения потребления памяти (чтобы хранить этот код)

### 7. Что такое String[] args в методе main()?
   Это аргументы которые будут переданы из консоли

### 8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
   Для разграничения областей видимости и группировки классов</br>

   По умолчанию подключено lang

### 9. Какой дефолтный оператор доступа у класса
package-private

### 10. Какие типы принимает System.out.printLn
Только примитивы</br>
При попытке вывести в консоль объект или массив будет обращение к методу `toString`


## END ---------------- Основы ----------------

## Garbage collector

+ [1. Как устроена память?](#1-как-устроена-память)
+ [2. Что является мусором?](#2-что-является-мусором)
+ [3. Этапы сборки мусора](#3-этапы-сборки-мусора-)
+ [4. Что означает поколения объектов?](#4-что-означает-поколения-объектов)
+ [5. Зачем нужны поколения объектов?](#5-зачем-нужны-поколения-объектов)
+ [6. Как происходит заполнения областей?](#6-как-происходит-заполнения-областей)
+ [7. Какие есть сборкики мусора?](#7-какие-есть-сборкики-мусора)
+ [8. Как работает сболрщик CMS GC(Concurrent Mark Sweep)](#8-как-работает-сболрщик-cms-gcconcurrent-mark-sweep)
+ [9. Как работает G1 GC (Garbage First)?](#9-как-работает-g1-gc-garbage-first)
+ [10. Какие бывают ссылки и в чем их отличия](#10-какие-бывают-ссылки-и-в-чем-их-отличия)

### 1. Как устроена память?
- Native Memory — вся доступная системная память.
- Heap (куча) - часть Native Memory. Здесь храняться JVM объекты. Это общее пространство для всех потомок приложения
- Stack (стек) - используется для хранения локальных переменных и стека вызовов метода. Для каждого потоко выделяется свой стек
- Metaspace (метаданные) - тут хранятся метаданных классов и статические переменные. Является общим для всех
- CodeCache (кэш кода) - JIT компилятор компилирует часто исполняемый код, преобразуя его в нативный машинный код и кеширует для более быстрого выполнения

### 2. Что является мусором?
Мусором является объект, который больше не может быть достигнут по ссылке из какого-либо места

### 3. Этапы сборки мусора
- Mark (маркировка) (Stop the world) - GC сканирует все объекты и помечает живые. На этом этапе выполнение программы приостанавливается
- Sweep (очистка) - Освобождается память, занятая объектами, не помечанными на предыдущем шаге
- Compact (уплотнение) - Объекты, переживщие очистку, перемещаются в единый непрерывных блок памяти

### 4. Что означает поколения объектов?
Объекты разделяются на 2 типа в зависимости от их типа для оптимизации
- Young generation
  - Eden - Здесь создаются новые объекты
  - S0 и S1 (Survivor Space - область для выживших)
- Old generation (Tenured) - давно живущие объекты

### 5. Зачем нужны поколения объектов?
- Большинство объектов живут не долго
- Если объект выживает, то он, скорее всего, будет жить вечно
- Этапы mark и sweep занима.т меньше времени при большом количество мусора. </br>
То есть маркировка будет происходить быстрее, если анализируемая область небольшая и в ней много метных объектов

### 6. Как происходит заполнения областей?
1. Новые объекты создаются в Eden
2. Когда Eden заполняется, происходит минортая сборка мусора
* Minor GC - это процесс при котором операции mark и sweep выполняются для young generation
3. После Minor GC выживышие объекты перемещаются в одну из областей S0
4. По мере работы приложения пространство заполняется новыми объектами. </br>
При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в S1 и их возраст увеличивается
5. При следующем Minor GC процесс повторяется
Однако области Survivor Space меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст
6. Таким образом объекты копируются из области в область несколько раз пока в областях не закончится место или пока они не переживую определенное количество чисток</br>
После чего они будут перемещены в Old generation
7. Major GC. При Major GC этапы mark и sweep выполняются для Old generation

### 7. Какие есть сборкики мусора?

| Сборщик мусора | Описание                                                            | Преимущества                                                                                                                    | Когда использовать                                                                                                                                                                                                            | Флаги для включения |
|----------------|---------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|
| Serial         | Использует 1 поток                                                  | Эффективный, т.к. нет накладных расходов на взаимодействие потоков                                                              | Однопроцессорные машины<br/>Работы с небольшими наборами данных                                                                                                                                                               | -XX:+UseSerialGC    |
| Parallel       | Использует несколько потоков                                        | Многопоточность усколяет сборку мусора                                                                                          | В приоритете пиковая производительность<br/>Допустимы паузы при GC в одну секунду и более<br/>Работа со средними и большими наборами данных<br/>Для приложений работающих на многопроцессорном или многопоточном оборудовании | -XX:+UseParallelGC  |
| G1             | Выполняет некоторую тяжелую работу параллельно с работой приложения | Может использоваться как на небольших системах, так и на больших с большим количеством процессором и большим количеством памяти | Когда время отклика важнее пропускной способности<br/>Паущы GC должны быть меньше одной секунды                                                                                                                               | -XX:+UseG1GC        |
| Z1             | Выполняет всю тяжелую работу параллельно с работой приложения       | Низкая задержка                                                                                                                 | В приоритете время отклика                                                                                                                                                                                                    | +UseZGC             |


### 8. Как работает сболрщик CMS GC(Concurrent Mark Sweep)
- Использует такую же организацию памяти как и Serial/Parallel (пункт 4)
- Использует такие же принципи по работе с младшими поколениями (пункт 6 - 1-6)
- Не дожидается полного заполнения блока старшего поколения (Tenured) для того чтобы начать сборку мусора
- Работает в фоном режиме и постоянно поддерживает Tenured в компактном состоянии
- Сборщик умеет разносить во времени малые и старшие сборки мусора, чтобы не создавать продолжительных пауз

0. Этапы от 1-6 с пункта 6
1. Останавливает основные потоки приложения (initial mark pause)
2. Помечает все объекты, которые доступны из корня
3. Запускает работу приложения
4. Сборщик параллельно продлолжает поиск всех живых объектов, доступных по ссылке из помеченных на втором этапе объектов
 - происходит это в одном или нескольких потоках
5. После завершения поиска сборщик еще раз останавливает приложение (remark pause) и просматривает кучу для поиска живых объектов
 - На данном этапе в живые могут попасть те объекты, которые живыми уже не являются
 - Такие объекты называются _плавающим мусором_ (floating garbage) - они будут удалены в процессе следующей сборки
 - Используется алгоритм Snapshot-At-The-Beginning (SATB) - в список живых попадают все объекты, которые могли быть таковыми на момент начала работы алгоритма
6. Возобновляется работа основных потоков приложения
7. Сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках
 - После очистки не будет производится упаковка объектов в старшем поколении

### 9. Как работает G1 GC (Garbage First)?
- Изначально предназначался для приложений с большими кучам (от 4гб и выше)
- Задача минимизировать паузы в работе основного приложения

**Структура кучи**
- Память разбита на множество регионом одиннакового размера
- Для больших объектов может объеденяться несколько регионов
- По умолчанию регионы разбираются так, чтобы их было не больше 2048 (~ от 1 до 32mb)
- Разделение регионов на Eden, Survivor и Tenured логическое и регионы могут менять свою принадлежность

**Принцип работы**
1. Остановка основного процесса приложения
2. Работа с малыми сборками происходит в несколько потоков
- Принцип работы с малыми сборками такой же как в пункте 6 (1-6)
- Но очистка выполняется не на всем поколении, а только на части регионов, которые сборщик может очистить не превышая желаемое время
- Выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора (Garbage First)
4. Начало работы Смешанной сборки (ранее работы со старым поколением)
5. Остановка приложения (initial mark pause)
6. Пометка корней с использованием информации, полученной из малых сборок
7. Concurrent marking - пометка всех живых объектов в куче в нескольких потоках, параллельно с работой приложения
8. Оставнока приложения (remark pause)
9. Дополнительный поиск не учтенных ранее живых объектов
- Использует Snapshot-At-The-Beginning (SATB), то есть может присутсвовать плавающий мусор
8. Возобновление работы приложения
9. Остановка приложения
10. Cleanup - очистка вспомогательных структур учета ссылок на объеты
11. Возобновление работы приложения
12. Поиск пустых регионов, которые можно использовать для размещения новых объектов

* После окончания цикла пометки (2) G1 переключается на выполнение смешанных сборок (5)
    - Каждый раз к набору регионом младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения
    - У сборщика есть статистика по предыдущим сборкам, чтобы не выходить за рамки по времени
    - После окончания очистки возвращается к работе с младшим поколением
* Очередной цикл пометки будет запущен тогда, когда заполненность кучи превысит определенный порог

### 10. Какие бывают ссылки и в чем их отличия
- Weak reference
- Strong reference
- Soft reference
- Phantom reference

- Strong reference - это самая простая ссылка, которую используем чаще всего
Данная ссылка запрещена для удаления сборщиком мусора
   `String s = “abc”`

- Weak reference (больше подходит для метаданных)
```
Counter counter = new Counter(); // strong reference
WeakReference weakCounter = new WeakReference(counter); //weak reference
counter = null; // now Counter object is eligible for garbage collection
```
Когда ссылка больше не имеет strong ссылки, он становится доступным для удаления сборщиком мусора

- Soft reference (больше подходит для кешей)
```
Counter prime = new Counter();  // prime holds a strong reference
SoftReference soft = new SoftReference(prime) ; //soft reference variable has SoftReference to Counter Object
prime = null;  // now Counter object is eligible for garbage collection but only be collected when JVM absolutely needs memory
```
Soft ссылка, которая не имеет strong ссылки будет удалена сборщиком мусора тогда, когда JVM будет нуждаться в памяти
Soft ссылка откладывает процесс удаления сборщиком мусора до момента когда в этом не будет необходимости

- Phantom reference
```
DigitalCounter digit = new DigitalCounter(); // digit reference variable has strong reference
PhantomReference phantom = new PhantomReference(digit); // phantom reference
digit = null;
```
Объект на который указывают только phantom ссылки может быть удален сборщиком в любой момент


## END ---------------- Garbage collector ----------------

## Classloader

+ [1. Задачи classloader](#1-задачи-classloader)
+ [2. Этапы получения работающего JVM кода](#2-этапы-получения-работающего-jvm-кода)
+ [3. Условия для выполнения этапов](#3-условия-для-выполнения-этапов)
+ [4. Типы загрузчиков](#4-типы-загрузчиков)
+ [5. От какого класса наследуются все загрузчики?](#5-от-какого-класса-наследуются-все-загрузчики)
+ [6. От какого класса наследуются базоый загрузчик?](#6-от-какого-класса-наследуются-базоый-загрузчик)
+ [7. Какие методы надо реализовывать при реализации Classloader](#7-какие-методы-надо-реализовывать-при-реализации-classloader)
+ [8. Какой метод является точной входа для загрузки классов](#8-какой-метод-является-точной-входа-для-загрузки-классов)
+ [9. Логика работы `classLoader`](#9-логика-работы-classloader)
+ [10. Принципы загрузки классов](#10-принципы-загрузки-классов)
+ [11. Схема загрузки классов](#11-схема-загрузки-классов)
+ [12. Все ли классы загружаются сразу](#12-все-ли-классы-загружаются-сразу)

### 1. Задачи classloader
- Для поставки в JVM скомпилированного байт-кода, который хранится в файлах с расширением `.class`, но модет быть также получен из других источников

### 2. Этапы получения работающего JVM кода
- Загрузить байт-код из ресурсов и создание экземпляра класса `Class`
  - Поиск запрошенного класса среди загруженных ранее
  - Получение байт-кода для загрузки и проверки его корректности
  - Создание экземпляра класса `Class`
  - Загрузка родительских классов
- Связываение (линковка)
  - `Verification` - проверка корректности полученного байт-кода
  - `Preparation` - выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию
  - `Resolution` - разрешение символьных ссылок типов, полей и методов
- Инициализация полученного объекта

### 3. Условия для выполнения этапов
- Класс должен быть полностью загружен прежде, чем слинкован
- Класс должен быть полностью проверен и подготовлен прежде, чем проиницилизирован
- Ошибки разрешения ссылок происходят во время выполнения программ, даже если быть обнаружены на этапе линковки

### 4. Типы загрузчиков
- **Bootstrap** - базовый загрузчик, также называется `Primodial Classloader`
  - загружает стандартные классы JDK из архива rt.jar
- **Extension ClassLoader** - загрузчик расширенный
  - Загружает классы расширений, которые по умолчанию находятся в каталоге `jre/lib/ext`, но могут быть заданы системным свойством `java.ext.dirs`
- **System Classloader** - системный загрузчик
  - загружает классы приложения, опрределенные в переменной среды окружения CLASSPATH

(*) Используется иерархия загрузчиков классов
- Корневой - базовый
- Загрузчик расширений
- Системный загрузчик

### 5. От какого класса наследуются все загрузчики?
абстрактный классс `Classloader`

### 6. От какого класса наследуются базоый загрузчик?
базовый загрузчик является нативным и его реализация включена в JVM

### 7. Какие методы надо реализовывать при реализации Classloader
- loadClass(String name)
- loadClass(String name, boolean resolve)
- findLoadedClass(String name)
- getParent()
- findClass(String name)
- resolveClass(Class<?> c)

### 8. Какой метод является точной входа для загрузки классов
- Метод `loadClass(String name)`

### 9. Логика работы `classLoader`
- Вызывается метод `loadClass(String name)`
- Его реализация сводится к вызову protected метода `loadClass(String name, boolean resolve)`
    - На вход этого метода подаются два параметра
    - 1 бинарное имя класса, который необходимо загрузить
    - 2 флаг, определяющий, требуется ли выполнять процедуру разрешения символьных ссылок (по умолчанию false)
- Далее происходит вызов метода `findLoadedClass(String name)`
  - Проверяет был ли класс уже загружен ранее
    - Если был, то вернет ссылку на класс
    - Иначе вызывает метод загрузки класса у родительского загрузчика
    - Если ни один из загрузчиков не смог найти загруженный класс, каждый из них следуя в обратном порядке попытается этот класс найти и загрузить, переопределяя метод `findClass(String name)`
- Послед загрузки определяется стоит ли выполнять загрузку классов по символьным ссылкам

### 10. Принципы загрузки классов
- **Дегерирование**
  - Запрос на загрузку класс передается родительскому загрузчику
  - Попытка загрузить класс самостоятельно выполняется, только если родительский загрузчик не смог найти и загрузить класс
  - Позволяет загружать классы тем загрузчиком, который максимально близко к базовому
- **Видимость**
  - Загрузчик видит только свои классы и классы родителя и понятия не имеет о классах, которые были загружены его потомком
- **Уникальность**
  - Класс может быть загружен только однажды

### 11. Схема загрузки классов
1. Приходит вызов загрузки класса
2. Происходит поиск этого класса в кеше уже загруженных классов текущего загрузчика
3. Если класс не загружался ранее
   1. Управление передается родительскому загрузчику (делегирование)
      1. Если класс уже был загружен и загрузчик знает о его местонахождении, то будет возвращен объект `Class` этого класса
      2. Если нет, поиск будет продолжаться до тех пор, пока не дойдет до базового загрузчика
         1. Если в базовом загрузчике нет информации об искомо классе, будет выполнен поиск байт-кода
            - Если класс загрузить н удается, то управление возвращается обратно к загрузчику-потомку
            - Потомок будет выполнять загрузку из известным ему источников и передавать ниже по цепочке

```
| Генерируется исключение java.lang.ClassNotFoundException | <---------------------------------------  < нет | класс загружен? | да >--
                                                                                                                         ^
                                                                                                                         |
                                                                                                                загрузка |
| Программа запросила класс {name} | --------------------------------> |*********************** System Classloader ***********************|
                                   |                                             | поиск в кеше                          ^
                                   |                                             |                                       | нет
                                   |                                             v                                       | нет
                                   | <--------------------------------<да | Класс найден? |                       | Класс загружен? | да >--
                                   |                                         нет |                                       ^
                                   |                                             |                                       |
                                   |                                             v                              загрузка |
                                   |                                   |********************* Extension ClassLoader **********************|
                                   |                                             | поиск в кеше                          |
                                   |                                             |                                       | нет
                                   |                                             v                                       | нет
                                   | <--------------------------------<да | Класс найден? |                       | Класс загружен? | да >--
                                   |                                         нет |                                       ^
                                   |                                             |                                       |
                                   |                                             v                              загрузка |
                                   |                                   |************************* Bootstrap ******************************|
                                   |                                             | поиск в кеше                          ^
                                   |                                             |                                       |
                                   |                                             v                                       |
                                   | <--------------------------------<да | Класс найден? | нет>-----------------> | Попытка загрузить класс |
```

### 12. Все ли классы загружаются сразу
Нет, классы загружаются по мере необходимости во время выполнения программы

3 этапа загрузки класса
1. Загрузка: Класс загружается когда он впервые используется в программе. В этот момент классовый загрузчик загружает файл класса их файловой системы или с другого источника
2. Связываение: На этом этапе происходит проверка целостности и семантическая проыерка загруженного класса, а также разрешение ссылок на другие классы и ресурсы
3. Инициализация: Происходит инициализация статических полей и выполнение статических блоков иницилизации в классе

## END ---------------- Classloader ----------------

## ООП

+ [1. Что такое ООП?](#1-что-такое-ооп)
+ [2. Что такое объект?](#2-что-такое-объект)
+ [3. Что такое класс?](#3-что-такое-класс)
+ [4. Какие преимущства у ООП?](#4-какие-преимущства-у-ооп)
+ [5. Какие недостатки у ООП?](#5-какие-недостатки-у-ооп)
+ [6. Основные принципы ООП](#6-основные-принципы-ооп)
+ [7. Что такое ассоциация?](#7-что-такое-ассоциация)
+ [8. Что такое агрегация?](#8-что-такое-агрегация)
+ [9. Что такое композиция?](#9-что-такое-композиция)
+ [10. Раннее и позднее связывание](#10-раннее-и-позднее-связывание)
+ [11. Можно ли переопределить private или static методы?](#11-можно-ли-переопределить-private-или-static-методы)
+ [12. Можно ли менять модификатор доступа у унаследованных методов,свойств](#12-можно-ли-менять-модификатор-доступа-у-унаследованных-методовсвойств)
+ [13. Можно ли получить доступ к нестатическому полю из статического метода?](#13-можно-ли-получить-доступ-к-нестатическому-полю-из-статического-метода)
+ [14. Что такое diamond problem и как она решена в Java](#14-что-такое-diamond-problem-и-как-она-решена-в-java-)

### 1. Что такое ООП?
   - ООП - это объектно ориентированное программирование.
   - Это программирование с помощью классов и объектов

### 2. Что такое объект?
   - Объект  - это сущность, одновременно содержащая данные и поведения.
   - Объекты - это строительные блоки объектно-ориентированных программ.

```
Данные объектов - состояние объекта(атрибуты).
Пример: атрибуты работника (SocialSecurityNumber, Gender, DateOfBirth)

Поведения объектов - что объект может сделать( в процедурных языках определяется процедурами, функциями и подпрограммами) (методы).
Пример: методы работника (setGender() getGender() - для установки и получения пола).
```

### 3. Что такое класс?
   Класс - это "чертеж" объекта

### 4. Какие преимущства у ООП?
- Модульность - инкапсуляция объектов в себе упрощает разработку, уменьшает количество ошибок
- Реюзабельность кода
- Высокая скорость разработки - классы и интерфейсы в ООП могут легко трансформироваться в подобие полноценных библиотек
- Расширяемость - ООП легко развивать, дополнять и менять. Этому способствует независимая модульная структура
- Простота восприятия
- Безопасность - инкапсулированных код недоступен извне, поэтому поломать что-либо сложнее
- Гибкость - полиморфизм позволяет быстро адаптировать ООП-код под свои нужды

### 5. Какие недостатки у ООП?
- Объекты во главе угла - из-за особенного внимания к объектам, меньше внимания уделяется вычислениям и алгоритмам
- Негативно сказывается на скорости компиляции кода

### 6. Основные принципы ООП
- Инкапсуляция - свойство системы, позволяющее объеденить данные и методы, работающие с ним, в классе. В частности, некоторые языки подразумевают сокрытие этих компонентов от доступа из вне.
- Наследование - Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью
- Полиморфизм поддтипов - свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта
- Полиморфизм параметрический - свойство семантики системы типов, позволяющее обрабатывать значения разных типов идентичным образом, то есть исполнять физически один и тот же код для данных разных типов
- Полиморфизм ad hoc - это свойство языка программирования, позволяющее создать функцию, семантика которой будет зависеть от типов входных параметров
- Абстракция - каждый верхний слой над объектом (классы) более абстрактный

### 7. Что такое ассоциация? 
https://i.stack.imgur.com/BBNy5.png

   Объекты между собой никак не связаны. Первый объект может принадлежать сразу нескольким объектам одновременно и не управляться ими</br>
   Наследование позволяет одному классу наследовать от другого, поэтому мы можем абстрагировать атрибуты и поведения для общих классов

### 8. Что такое агрегация?
   Это вложенность одного класса в другой, но при этом класс обертка не управляет сроком жизни вложенного объекта</br>
   части могут принадлежать более чем одному целому за раз, и целое не управляет существованием и временем жизни частей

- Например, отношения между человеком и его домашним адресом. У каждого человека есть свой адрес. Однако этот адрес может принадлежать более чем одному человеку за раз</br>
  Однако этот адрес не управляется человеком — адрес существовал до того, как человек заселился и будет существовать после того, как человек выселится.

### 9. Что такое композиция?
это отношения части-целого. Часть в композиции может быть частью только одного объекта за раз

- Например: сердце, которое является частью тела одного человека, не может быть частью тела ещё одного человека одновременно.

### 10. Раннее и позднее связывание
- Раннее - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода
- Позднее - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.

### 11. Можно ли переопределить private или static методы?
нельзя

### 12. Можно ли менять модификатор доступа у унаследованных методов,свойств
- Понижать уровень доступа нельзя
- Повышать уровень доступа можно

### 13. Можно ли получить доступ к нестатическому полю из статического метода?
нет

### 14. Что такое diamond problem и как она решена в Java
Diamond problem это Когда классы B и C наследуют А, а класс D наследуюет B и C</br>
При этом классы A, B, C определяют метод test что приводит к непонимаю какую именно имплементацию метода test должен унаследовать класс D

В java запрещено множественное наследование

## END ---------------- ООП ----------------

## Процедурная Java

+ [1. Какие примитивные типы данных есть в Java?](#1-какие-примитивные-типы-данных-есть-в-java)
+ [2. Какими значения по умолчанию инициализируются поля примитивных типов данных?](#2-какими-значения-по-умолчанию-инициализируются-поля-примитивных-типов-данных)
+ [3. Что такое автоупаковка и автораспаковка?](#3-что-такое-автоупаковка-и-автораспаковка)
+ [4. Что такое класс-обертки?](#4-что-такое-класс-обертки)
+ [5. Что такое cast?](#5-что-такое-cast)
+ [6. Что такое пул интов?](#6-что-такое-пул-интов)
+ [7. Какие нюансы у строк в Java?](#7-какие-нюансы-у-строк-в-java)
+ [8. Что такое пул строк?](#8-что-такое-пул-строк)
+ [9. Почему строки не рекомендуется использовать для хранения паролей?](#9-почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
+ [10. Почему строка неизменяемый и финализированный класс?](#10-почему-строка-неизменяемый-и-финализированный-класс)
+ [11. Что делает метод intern() в классе String?](#11-что-делает-метод-intern-в-классе-string)
+ [12. Можно ли использовать строку в конструкции Switch](#12-можно-ли-использовать-строку-в-конструкции-switch)
+ [13. Что такое инвариантность и ковариантность](#13-что-такое-инвариантность-и-ковариантность)
+ [14. В чем разница между String, StringBuffer, StringBuilder?](#14-в-чем-разница-между-string-stringbuffer-stringbuilder)
+ [15. Каким образом переменные передаются в метода?](#15-каким-образом-переменные-передаются-в-метода)
+ [16. В чем разница между Hashtable и HashMap?](#16-в-чем-разница-между-hashtable-и-hashmap)
+ [17. Как ограничить upcasting типа-параметра](#17-как-ограничить-upcasting-типа-параметра)
+ [18. Сколько может быть стеков в приложении](#18-сколько-может-быть-стеков-в-приложении)
+ [19. Какие классы могут быть статическими](#19-какие-классы-могут-быть-статическими)

### 1. Какие примитивные типы данных есть в Java?

| ТИП     |Размер в байтах |     Диапазон значений     |     Значение по умолчанию     |     Описание  |
|---------|----------------|---------------------------|-------------------------------|-------------- |
| byte    |     1          |   -128 .. 127             |     0                         | Самое маленькое целое — один байт |
| short   |     2          |   -32,768 .. 32,767       |     0                         | Короткое целое, два байта |
| int     |     4          |   -2*10 в 9 .. 2*10 в 9   |     0                         | Целое число, 4 байта |
| long    |     8          |   -9*10 в 18 .. 9*10 в 18 |     0L                        | Длинное целое, 8 байт |
| float   |     4          |   -10 в 38 .. 10 в 38     |     0.0f                      | Дробное, 4 байта |
| double  |     8          |   -10 в 308 .. 10 в 308   |     0.0d                      | Дробное, двойной длины, 8 байт |
| boolean |     1          |   true, false             |     false                     | Логический тип (только true & false) |
| char    |     2          |   0 .. 65,535             |     '\u0000'                  | Символы, 2 байта, все больше 0 |
|  NaN    |                |                           |                               | Не число |

### 2. Какими значения по умолчанию инициализируются поля примитивных типов данных?
- Числовые и char = 0
- Булево = false

### 3. Что такое автоупаковка и автораспаковка?
- Автоупаковка (autoboxing) — это процесс автоматической инкапсуляции данных простого типа, такого как int или double, в эквивалентную ему оболочку типа, как только понадобится объект этого типа. При этом нет необходимости в явном создании объекта нужного типа.
- Автораспаковка (auto-unboxing) — это процесс автоматического извлечения из упакованного объекта значения, когда оно потребуется.

### 4. Что такое класс-обертки?
Обертка - это специальный класс, который хранит внутри себя значение примитива

- int - Integer
- short - Short
- long - Long

Классы обертки позволяют невелировать недостатки, которые есть у примитивных типов</br>
Самый очевидный из них — примитивы не имеют методов.

### 5. Что такое cast?
Приведение типов

### 6. Что такое пул интов?
Java хранит пул интов [-128; 127]

### 7. Какие нюансы у строк в Java?
- Класс реализует Serializable и CharSequence
- Это final класс, который не может иметь потомков
- это immutable класс, его объекты не могут быть изменены после создания. Любые операция приводят к созданию нового объекта
- Благодаря неизменяемости - это потокобезопасный класс
- Каждый объект может быть преобразован в строку с помощью toString

### 8. Что такое пул строк?
- Это набор сктрок, который хранится в Java heap
- Пул строк возможет благодаря неизменяемости строк в Java
- Пул строк помогает экономить большой объем памяти

Когда мы используем двойные кавычки для создания строки, сначала строка ищется в пуле с таким же значением, если находится</br>
то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка</br>

Когда мы используем оператор new мы принуждаем создать новую строку

### 9. Почему строки не рекомендуется использовать для хранения паролей?

Строка хранится в пуле строка до тех пор пока она не будет удалена сборщиком мусора

Даже если мы думаем, что закончили работу с паролем, он остается доступен в памяти

Лучше использовать массив символов для хранения пароля, так как мы можем его очистить после того, как закончим с ним работать

### 10. Почему строка неизменяемый и финализированный класс?
- Строковый пул возможен только потому, что строка неизменна. Таким образом сохраняется много места в памяти
- Изменяемая строка - это угроза приложению: Например параметры для соединения с бд передаются в виде строки и х нельзя изменить
- Неизменная строка безопасна для многопоточности
- Ее hashCode кэшируется в момент создания и нет необходимости расчитывать его снова. Это делает строку отличным кандидатом для ключа в Map
  и ее обработка будет быстрее

### 11. Что делает метод intern() в классе String?
- Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную нашему объекту, тогда возвращается ссылка на строку из пула
- Этот метод возвращает строку, которая имеет то же значение, что и текущая строка, но гарантирует что это будет строка из пула уникальных строк

### 12. Можно ли использовать строку в конструкции Switch
- строки switch чувствительны к регистру
- оператор использует метод `String.equals()` для сравнения полученного значения со значениемя case, поэтому необходима проверка на null
- согласно Java 7 для строк в switch компилятор формирует более эффективный байт код

### 13. Что такое инвариантность и ковариантность
- Ковариантность - случай когда более конкретный тип S может быть подставлен вместо более обобщенного типа Т </br>
Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>
- Инвариантность - случай когда подставлять можно только определенный тип</br>
Если Кошка — это подтип Животные, то Множество<Кошки> не является подтипом Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.

### 14. В чем разница между String, StringBuffer, StringBuilder?
_String_ - это класс для создания объекта типа String</br>
_StringBuffer_ - это класс, который используется для изменения строк и обеспечения безопасности потоков (синхронизирован)</br>
_StringBuilder_ - это класс класс, который используется для изменения строк, не обеспечивающих потокобезопасность (не синхронизирован)

### 15. Каким образом переменные передаются в метода?
_Примитивные_ - копируется само значение</br>
_Ссылочные_ - копируется ссылка

### 16. В чем разница между Hashtable и HashMap?
_Hashtable_ - все методы синхронизированные</br>
_HashMap_ - все методы не синхронизированные

### 17. Как ограничить upcasting типа-параметра
- Upcasting – приведение к типу-родителю. String → Object, Integer → Number.
```
Задача: запретить этому методу принимать параметры разных типов:

<T> void pair(T a, T b) {}

То есть, нужно разрешить вызывать pair(Foo, Foo), но запретить pair(Foo, Bar).
```
- На этапе компиляции это невозможно
- Объект любого типа всегда является объектом типа-родителя
(Решение)
- Единственная возможность добиться желаемого поведения – с помощью getClass() сравнивать классы объектов в рантайме.

### 18. Сколько может быть стеков в приложении
Каждый поток в Java имеет свой собственный стек, который используется для хранения локальных переменных</br>
По умолчанию размер стека составляет несколько мегабайт (1-2мб)

### 19. Какие классы могут быть статическими
Статическим классами могут быть вложенные классы

Статические вложенные классы можно использовать вне своего родительского класса, ели у такого класса стоит модификатор доступа public

Статические классы отличаются от обычных классов
Методы вложенного статического класса имеют доступ ко всем статическим переменным и методам своего класса родителя, даже если те объявлены private

Примеры обращения к статическим классам

| Класс родитель        | вложенные класс | Полное имя вложенного класса |
|-----------------------|-----------------|------------------------------|
| com.javarush.Solution | Point           | com.javarush.Solution.Point  |
| java.util.Map         | Entry           | java.util.Map.Entry          |

Создание объекта - new КлассРодитель.ВложенныйКласс();


## END ---------------- Процедурная Java ----------------

## Потоки ввода/вывода

+ [1. Что такое потоки ввода/вывода](#1-что-такое-потоки-вводавывода)
+ [2. Виды потоков](#2-виды-потоков)
+ [3. Класс InputStream](#3-класс-inputstream)
+ [4. Класс OutputStream](#4-класс-outputstream)
+ [5. Какие классы наследуются от базовых классов](#5-какие-классы-наследуются-от-базовых-классов)
+ [6. Класс File для работы с файловой системой](#6-класс-file-для-работы-с-файловой-системой)

### 1. Что такое потоки ввода/вывода
Это абстрактное понятие источника или приема данных, которые способны передавать информацию</br>

### 2. Виды потоков
- Байтовые - `java.io.InputStream`, `java.io.OutputStream`
- Символьные - `java.io.Reader`, `java.io.Writer`

### 3. Класс InputStream
Получает данные из различных источников
- массив байтов
- строки
- файлы
- каналы pipe</br></br>

Основные методы

| Метод                                 | Описание                                                                                                   |
|---------------------------------------|------------------------------------------------------------------------------------------------------------|
| int read ()                           | чтение во входном потоке очередного доступного символа в виде целого                                       |
| int read (byte b[])                   | чтение во входном потоке b.length байтов в массив b. Возвращает количество прочитанных байтов              |
| int read (byte b[], int off, int len) | чтение len байтов в массиве b, начиная со смещения off; возвращает количество прочитанных из потока байтов |
| int available()                       | получение количества для чтения байтов                                                                     |
| void close()                          | закрытие потока ввода; последующие попытки чтения из потока вызовут IOException                            |

### 4. Класс OutputStream
Определяет байтовый поток вывода
- Классы, определяющие выходные данные, помещаемые в массив байтов, в файл или канал</br>
* Напрямую в объект String вывести данные нельзч, можно создать тестовую строку из массива байтов</br></br> 

Основные методы

| Метод                                   | Описание                                                                  |
|-----------------------------------------|---------------------------------------------------------------------------|
| void write (int b)                      | запись байта в выходной поток                                             |
| void write(byte b[])                    | запись в выходной поток массива объектов                                  |
| void write (byte b[], int off, int len) | запись в поток len байтов массива, начиная с элемента b[off]              |
| void flush()                            | завершение операции вывода и очистка выходных буферов                     |
| void close()                            | закрытие выходного потока; последующие попытки записи вызовут IOException |


### 5. Какие классы наследуются от базовых классов
- Классы-надстройки `InputStream`
  - ByteArrayInputStream - использует байтовый массив в памяти в качестве источника данных для воходного потока
  - FileInputStream - класс для работы с файлами. Конструктор получает путь к файлу
  - FilterInputStream - Абстрактный класс, предоставляющий интерфейс для классов `BufferedInputStream` и `DataInputStream`
  - ObjectInputStream - Входной поток для сериализованных данных
  - PipedInputStream - Класс используемых для связи отдельных программ (потоков) друг с другом внутри одной JVM
- Классы-надстройки `OutputStream`
  - ByteArrayOutputStream - Поток вывода в массив байтов
  - FileOutputStream - Поток вывода массива байтов в файл
  - FilterOutputStream - Абстрактный класс, предоставляющий интерфейс для классов `BufferedOutputStream`, `DataOutputStream` и `PrintStream`
  - ObjectOutputStream - для сериализации объектов при отправлении в поток
  - PipedOutputStream - для установки связи между двумя каналами
- Классы-надстройки `Reader`
  - BufferedReader - Буферизированный входной поток символьных строк
  - CharArrayReader - Входной поток чтения символьного массива
  - StringReader - Входной поток чтения из строки
  - FileReader - Входной поток чтения содержимого файла
  - FilterReader - Входной поток с фильтрацией
  - InputStreamReader - Входной поток преобразования байтов в символы
  - LineNumberReader - Входной поток, подсчитывающий строки
  - PipedReader - Входной поток чтения данных из файла
- Классы-надстройки `Writer`
  - BufferedWriter - Буферизированный выходной символьный поток
  - CharArrayWriter - Входной поток записи в символьный массив
  - StringWriter - Выходной поток записи в строку
  - FileWriter - Выходной поток записи в файл
  - FilterWriter - Выходной поток записи с фильтрацией
  - OutputStreamWriter - Выходной поток преобразования байтов в символы
  - LineNumberWriter - Выходной поток с подсчетом строк
  - PipedWriter - Выходной поток записи в канал

### 6. Класс File для работы с файловой системой
Класс позволяет получить следующие данные о файле
- права доступа
- время и дата создания
- путь к катлогу

| Метод                              | Описание                                               |
|------------------------------------|--------------------------------------------------------|
| File (File dir, String name)       | файл name в каталоге dir                               |
| File (String path)                 | path - полный путь к файлу                             |
| File (String dirPath, String name) | dirPath - путь к директории, name - наименование файла |
| File (URI uri)                     | uri - объект описания файла                            |

```
// Объект каталога File
File dir = new File("с:/dir");
// Объекты файлов
File file1 = new File("c:/dir", "Hello1.txt");
File file2 = new File(dir, "Hello2.txt");
```

## END ---------------- Потоки ввода/вывода ----------------

## ООП в Java

+ [1. Какие виды есть в java?](#1-какие-виды-есть-в-java)
+ [2. Что такое вложенные классы? В каком случаях они применяются?](#2-что-такое-вложенные-классы-в-каком-случаях-они-применяются)
+ [3. Что такое "локальный класс"? Каковы его особенности?](#3-что-такое-локальный-класс-каковы-его-особенности)
+ [4. Что такое "анонимные классы"? Где они применяются?](#4-что-такое-анонимные-классы-где-они-применяются)
+ [5. Каким образом из вложенного класса получить доступ к полю внешнего класса?](#5-каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ [6. Что такое перечисления (enum)?](#6-что-такое-перечисления-enum)
+ [7. Как проблема ромбовидного наследования решена в Java?](#7-как-проблема-ромбовидного-наследования-решена-в-java)
+ [8. Что такое конструктор по умолчанию?](#8-что-такое-конструктор-по-умолчанию)
+ [9. Могу ли быть приватные конструкторы? Для чего они нужны?](#9-могу-ли-быть-приватные-конструкторы-для-чего-они-нужны)
+ [10. Что такое классы-загрузчики и динамическая загрузка классов?](#10-что-такое-классы-загрузчики-и-динамическая-загрузка-классов)
+ [11. Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?](#11-чем-отличаются-конструкторы-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ [12. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.](#12-какие-модификации-уровня-доступа-вы-знаете-расскажите-про-каждый-из-них)
+ [13. Что означает модификатор static?](#13-что-означает-модификатор-static)
+ [14. Могут ли нестатические методы перегрузить статические?](#14-могут-ли-нестатические-методы-перегрузить-статические)
+ [15. Могут ли быть переопределены статические методы?](#15-могут-ли-быть-переопределены-статические-методы)
+ [16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределение метода?](#16-можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределение-метода)
+ [17. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы](#17-что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы)
+ [18. Могут ли классы быть статическими](#18-могут-ли-классы-быть-статическими)
+ [19. Что такое сигнатуры методы?](#19-что-такое-сигнатуры-методы)
+ [20. Что такое переопределение и перегрузка методов?](#20-что-такое-переопределение-и-перегрузка-методов)
+ [21. Когда вызывается конструктор?](#21-когда-вызывается-конструктор)
+ [22. Что означает ключевое слово final?](#22-что-означает-ключевое-слово-final)
+ [23. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?](#23-могут-ли-быть-конструкторы-у-абстрактных-классов-зачем-они-нужны)
+ [24. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#24-что-такое-интерфейсы-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ [25. Может ли интерфейс наследоваться от интерфейса?](#25-может-ли-интерфейс-наследоваться-от-интерфейса)
+ [26. Что такое дефолтные методы интерфейсов?](#26-что-такое-дефолтные-методы-интерфейсов)
+ [27. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default методами?
  ](#27-как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-с-default-методами)
+ [28. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?](#28-каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учетом-иерархии-классов) 
+ [29. Какие бываю и зачем нужны блоки инициализации?](#29-какие-бываю-и-зачем-нужны-блоки-инициализации) 
+ [30. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?](#30-каков-порядок-вызова-конструкторов-и-блоков-инициализации-двух-классов-потомка-и-его-предка) 
+ [31. Что произойдет, если в блоке инициализации возникнет ошибка?](#31-что-произойдет-если-в-блоке-инициализации-возникнет-ошибка) 
+ [32. Какие методы есть у object](#32-какие-методы-есть-у-object) 
+ [33. Что такое метод equals(). Чем он отличается от операции ==. (https://habr.com/ru/post/168195/)](#33-что-такое-метод-equals-чем-он-отличается-от-операции--httpshabrcomrupost168195) 
+ [34. Каким образом реализованы методы equals() и hashCode()](#34-каким-образом-реализованы-методы-equals-и-hashcode) 
+ [35. Правила переопределения equals()](#35-правила-переопределения-equals) 
+ [36. Правила при переопределении hashCode](#36-правила-при-переопределении-hashcode) 
+ [37. Могут ли у разных объектов быть одиннаковые hashCode() ?](#37-могут-ли-у-разных-объектов-быть-одиннаковые-hashcode-) 
+ [38. Чем a.getClass().equals(A.class) отличается от instanceOf A.class](#38-чем-agetclassequalsaclass-отличается-от-instanceof-aclass) 
+ [39. Может ли метод быть одновременно abstract и final?](#39-может-ли-метод-быть-одновременно-abstract-и-final) 
+ [40. Функиональные интерфейсы](#40-функиональные-интерфейсы)
+ [41. Как связаны equals и hashCode? Можно ли их использовать по отдельности?](#41-как-связаны-equals-и-hashcode-можно-ли-их-использовать-по-отдельности-)
+ [42. Дефолтная реализация equals](#42-дефолтная-реализация-equals)
+ [43. Какие есть способы глубокого копирования объекта](#43-какие-есть-способы-глубокого-копирования-объекта)
+ [44. Какие есть способы проверки значения на null](#44-какие-есть-способы-проверки-значения-на-null)
+ [45. Какие иммутабульные классы есть в java?](#45-какие-иммутабульные-классы-есть-в-java)

### 1. Какие виды есть в java?
- Вложенные внутренние классы
- Вложенные статические классы
- Локальные классы
- Анонимные классы

### 2. Что такое вложенные классы? В каком случаях они применяются?
Это классы, которые создаются внутри других классов</br>
Бывает 2 вида вложенных классов: Нестатические и статические</br></br>

   Нестатические в свою очередь делятся на подвиды
    - Анонимные
    - Локальные
      </br></br>
   Внутреннние классы - это классы для выделения в программе некой сущности, которая неразрывно связана с другой сущностью</br>
   Например - Руль, сиденьк, педали - это составные части велосипеда</br></br>

- Объект внутреннего класса не может существовать без объекта "внешнего" класса
- У объеккта внутреннего класса есть доступк переменных "внешнего" класса
- Объект внутреннего класса нельзя создать в статическом методе "внешнего" класса
- Внутренний класс не может содержать статические переменные и методы

### 3. Что такое "локальный класс"? Каковы его особенности?
   Это классы  объявленные внутри других методов</br></br>

- Локальные классы могут работать только с final переменными метода
- Локальные классы нельзя объявлять с модификаторами доступа
- Локальные классы обладают доступом к переменным метода

### 4. Что такое "анонимные классы"? Где они применяются?
- Это обычные нестатические вложенные классы, в более кратком виде. Объявляется класс и сразу создается экземпляр

Используются когда
- тело класса является коротким
- нужен только ожин экземпляр класса
- класс используется в месте его создания или сразу после него
- имя класса не важно

### 5. Каким образом из вложенного класса получить доступ к полю внешнего класса?
Для получения доступа из внутреннего класса к экземпляру его внешнего класса необходимо в ссылке указать имя класса и влючевое слово this
OuterClass.this

### 6. Что такое перечисления (enum)?
enum - это класс java.lang.Enum</br>
Элементы перечисления - экземпляры enum-класса, доступные статически

### 7. Как проблема ромбовидного наследования решена в Java?
В Java нет множественного наследования</br>
Но есть возможность использовать неограниченное количество интерфейсов

### 8. Что такое конструктор по умолчанию?
Если конструктор у класса не задан, то по умолчанию создастся пустой конструктор без реализации, которые будет вызывать super


### 9. Могу ли быть приватные конструкторы? Для чего они нужны?
Может</br>
Защищает класс от явного превращения в экземпляр. Используется в шаблоне "Одиночка"</br>
Обычно для создания объекта требуется вызвать другой метод

### 10. Что такое классы-загрузчики и динамическая загрузка классов?
Есть 2 типа загрузки классов
- Статическая
- Динамическая

_Статическая_ - это привычная загрузка, которая производится автоматически. При запуске программы загрузчик классов рекрсивно загружает все классы, встречающиеся в программе, начиная с main</br>
_Динамическая_ - производится через метод Class.forName(String className) или с использованием ClassLoader</br>
Динамическая загрузка классов имеет смысл, когда требуется загрузить класс во время выполнения программы, когда нужно заменить класс, изменив, например, какую-то логику, не рестартуя приложения</br></br>

// загружаем класс через ClassLoader</br>
``` 
ClassLoader classLoader = MainClass.class.getClassLoader();
Class aClass = classLoader.loadClass("com.jenkov.MyClass");
myClass = (MyClass) aClass.newInstance();
```

### 11. Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?
- Конструктор по-умолчанию не принимает никаких параметров
- Конструктор копирования принимает в качестве параметра объект класса
- Конструктор с параметрами принимает на фход параметры</br></br>

    Конструктор копирования
```
// конструктор копирования
public Circle(Circle circle) {
    this(circle.getName(), circle.getArea(), circle.getPerimeter()); //будет вызван конструктор с параметрами ниже
}
```

### 12. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
- private (закрытый) - доступ не предоставляется никому, кроме методов этого класса
- default, package, friendly - доступ по умолчанию. Открытый внутри собственного пакета
- protected (защищённый) - доступ в пределах пакета и классов наследников
- public (открытый) - доступен всем и везде

### 13. Что означает модификатор static?
Это значит что моле или метод будет относиться к классу, а не к инстансу(объекту) класса

### 14. Могут ли нестатические методы перегрузить статические?
Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.

### 15. Могут ли быть переопределены статические методы?
Переопределить базовый статический метод нельзя: Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс

### 16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределение метода?
нет, можно только расширить

### 17. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы
Можно менять модификатор доступа в стороны расширения</br></br>

- У переопределенного метода должны быть те же аргументы, что и у метода родителя.
- У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
- Модификатор доступа у переопределенного метода также не может отличаться от «оригинального» в меньшую сторону

### 18. Могут ли классы быть статическими
Да

### 19. Что такое сигнатуры методы?
Это имя + параметры (порядок параметров имеет значение)

### 20. Что такое переопределение и перегрузка методов?
переопределение - изменение тела унаследованного метода</br>
перегрузка - несколько вариантом методов с разными аргументами

### 21. Когда вызывается конструктор?
При созданииэксземпляра класса

### 22. Что означает ключевое слово final?
final - у метода, у переменной, у класса</br></br>

Класс нельзя унаследовать</br>
Метод нельзя переопределить</br>
Свойство нельзя переопределить

### 23. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?
Да</br>
Создать экземпляр абстрактного класса нельзя, но все-равно можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе

### 24. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Это контракт описывающий возможности</br>
По умолчанию все методы объявляются как public abstract (начиная с Java 8 - default)</br>
Поля - public static final

### 25. Может ли интерфейс наследоваться от интерфейса?
Интерфейс может наследоваться только от интерфейсов

### 26. Что такое дефолтные методы интерфейсов?
Это реализация метода по умолчанию

### 27. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default методами?
Никак. Будет ошибка на этапе компиляции.

### 28. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
- конструктор созданного класса объекта
- конструктор родителя созданного класса объекта (неявный super в начале конструктора класса)

### 29. Какие бываю и зачем нужны блоки инициализации?
- Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов.
- Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора.
- Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса.</br></br>

    Бываю статические и нестатические</br>
    static {}</br>
    {}</br></br>

    Зачем?
    - более читабельный код
    - внутри блоков можно не только присваивать значение, но и писать команды (вывод в косоль, циклы и т.д.)

### 30. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
- Все статические блоки от первого предка - до последнего наследника
- попарно динамические блоки инициализации и конструктор (от предка до последнего потомка)

### 31. Что произойдет, если в блоке инициализации возникнет ошибка?
- Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется,</br>
чтобы объявления этих исключений были перечислены в throws всех конструкторов класса.</br>
Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции. (java.lang.ExceptionInInitializerError;)</br></br>

- остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте.</br>
   Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</br></br>
    
   ( тип ошибки - Если возникшее исключение - наследник Error,</br>
     то в обоих случаях будет выброшено java.lang.Error.</br>
     Исключение: java.lang.ThreadDeath - смерть потока.</br>
     В этом случае никакое исключение выброшено не будет.</br>
   )

### 32. Какие методы есть у object
wait — поток переходит в режим ожидания в течение указанного времени.</br>
equals — сравнивает объекты.</br>
clone — клонирование объекта</br>
notify — просыпается один поток, который ждет на “мониторе” данного объекта.</br>
finalize — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет. (deprecated)</br>
toString — возвращает строковое представление объекта.</br>
hashCode — возвращает хеш-код</br>
notifyAll — просыпаются все потоки, которые ждут на “мониторе” данного объекта.

### 33. Что такое метод equals(). Чем он отличается от операции ==. (https://habr.com/ru/post/168195/)
При сравнении с помощью `==` идет сравнение по ссылкам</br>
При сравнении по equals() идет сравнение по состоянию объектов</br></br>

Хем-код - это число. Битовая строка фиксированной длины, полученная из массива произвольной длины (ограничена типом int)

### 34. Каким образом реализованы методы equals() и hashCode()

hashCode() - `public native int hashCode();` - реализация на языке С++</br>

equals() -
```
public boolean equals(Object obj) {
    return (this == obj);
}
```

### 35. Правила переопределения equals()
При переопределении обязательно необходимо переопределить hashCode()

### 36. Правила при переопределении hashCode
у них должен быть реализован метод для создания ключа и значения должны быть финализированы

### 37. Могут ли у разных объектов быть одиннаковые hashCode()?
Да, это называется коллизией

### 38. Чем a.getClass().equals(A.class) отличается от instanceOf A.class
- метод getClass () всегда возвращает точно тот класс, от которого был порожден объект.

### 39. Может ли метод быть одновременно abstract и final?
нет

### 40. Функиональные интерфейсы
Функциональным считается интерфейс с одним не реализованным (абстрактным) методом
+ интерфейсы, которые создаются след образом

```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);
}
```
@FunctionalInterface - сообщает компилятору, что данный интерфейс функциональный и должен содержать не более одного метода

* Абстрактные интерфейсы могут иметь методы, которые не входят в ограничения одного метода

Статические методы
```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);

    staitc <T> boolean isNotNull(T t) {
        return t != null;
    }
}
```
+ методы по умолчанию
```
@FunctionalInterface
public interface Converter<T, N> {
  N converter (T t);

  staitc <T> boolean isNotNull(T t) {
    return t != null;
  }

  default void writeToConsole (T t) {
    System.out.println("Текущий объем - " + t.toString());
  }
}
```

### 41. Как связаны equals и hashCode? Можно ли их использовать по отдельности?
- Повторный вызов hashCode для одного и того же объекта должен возвращать одиннаковые хеш-значения
- Если equals() для двух объектов возвращает true, hashCode()  также должен возвращать для них одно и тоже число
- Неравные между собой объекты могут иметь одиннаковый hashCode
- hashCode Используется для ускорения работы хеш-таблиц
- equals и hashCode можно использовать по отдельности

### 42. Дефолтная реализация equals
- две ссылки эквивалентны, если они ссылаются на одну и ту же область памяти
```
public boolean equals(Object x) {
  return(this == y)
}
```

### 43. Какие есть способы глубокого копирования объекта
- Реализовать интерфейс Cloneable и переопределить метод clone() в классе объекта
- Использовать сериализацию и десериализацию объекта
- Использовать сторонние библиотеки, такие как Apache Commons Lang или Gson


### 44. Какие есть способы проверки значения на null
1. С помощью оператора if:
```
   if (value == null) {
   // значение равно null
   } else {
   // значение не равно null
   }
```
2. С помощью метода Objects.isNull() из класса java.util.Objects:
```
boolean isNull = Objects.isNull(value);
```

3. С помощью метода Objects.nonNull() из класса java.util.Objects:
```
boolean isNotNull = Objects.nonNull(value);
```

4. С помощью метода Optional.ofNullable() из класса java.util.Optional:
```
Optional<String> optionalValue = Optional.ofNullable(value);
boolean isPresent = optionalValue.isPresent(); // возвращает true, если значение не равно null
```

### 45. Какие иммутабульные классы есть в java?
Integer, Byte, Character, Short, Boolean, Long, Double, Float, BigInteger, BigDecimal

### END ---------------- ООП в Java ----------------

## Исключения

+ [1. Опишите иерархию исключений?](#1-опишите-иерархию-исключений)
+ [2. Чем отличается Error от Exception?](#2-чем-отличается-error-от-exception)
+ [3. Расскажите про обрабатываемые и необрабатываемые исключения?](#3-расскажите-про-обрабатываемые-и-необрабатываемые-исключения)
+ [4. Какой оператор позволяет принудительно выбросить исключение?](#4-какой-оператор-позволяет-принудительно-выбросить-исключение)
+ [5. Как создать собственное (пользовательское) исключение?](#5-как-создать-собственное-пользовательское-исключение)
+ [6. В каком случае не выполнится блок finally](#6-в-каком-случае-не-выполнится-блок-finally)
+ [7. Может ли метод main выбросить исключение во вне и е](#7-может-ли-метод-main-выбросить-исключение-во-вне-и-е)
+ [8. В каком порядке следует обрабатывать исключения в catch блоках?](#8-в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
+ [9. Что такое try-with-resources?](#9-что-такое-try-with-resources)
+ [10. Что необходимо реализовать для работы try-with-resources?](#10-что-необходимо-реализовать-для-работы-try-with-resources)
+ [11. Что произойдет есть исключение будет выброшено из блока catch после чего другое исключенгие будет выброшено из блока finally
  ](#11-что-произойдет-есть-исключение-будет-выброшено-из-блока-catch-после-чего-другое-исключенгие-будет-выброшено-из-блока-finally)
+ [12. В чем разница между Exception и Error?](#12-в-чем-разница-между-exception-и-error)
+ [13. Можно ли использовать проверяемые исключения в лямбда функциях](#13-можно-ли-использовать-проверяемые-исключения-в-лямбда-функциях)
+ [14. Как определить причину OutOutMemoryError](#14-как-определить-причину-outoutmemoryerror)


### 1. Опишите иерархию исключений?

|                  |                     | Object                   |                                |
|------------------|---------------------|--------------------------|--------------------------------|
|                  |                     | Throwable(checked)       |                                |
| Error            |                     | Exception                |                                |
| OutOfMemoryError | StackOverflowError  | RuntumeException         | IOExeption(checked)            |
| LinkageError     |                     | IllegalArgumentExceprion | FileNotFoundException(checked) |
|                  |                     |                          | SocketException(checked)       |

### 2. Чем отличается Error от Exception?
 - Error - ошибка при выполнении java их нельзя исправить, о ним можно сообщить (рекомендуется вообще не трогать)
 - Exception - это "особые случаи", которые нужно как-то обработать

### 3. Расскажите про обрабатываемые и необрабатываемые исключения?
- контролируемые исключения (checked) - это ошибки, которые можно и нужно обрабатывать в программе
- неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) - не трубуют обязательной обработки, но при желании можно обработать
- исключения времени выполнения (RuntimeExceptions, потомок класса Exception)

### 4. Какой оператор позволяет принудительно выбросить исключение?
throw

### 5. Как создать собственное (пользовательское) исключение?
Создать класси у наследоваться от Exception

### 6. В каком случае не выполнится блок finally
Если в блоке try или catch есть System.exit

### 7. Может ли метод main выбросить исключение во вне и е
да, в стандартный вывод ошибок будет выведено сообщение об ошибке, в котором будет указано имя потока</br>
Если нет запущенных потоков-недемонов, то программа будет завершена, иначе будет ждать завершения всех потоков

### 8. В каком порядке следует обрабатывать исключения в catch блоках?
В порядке от наследников к родителю

### 9. Что такое try-with-resources?
Это оператор, который решает проблему с обязательным вывзовом close()</br>
блоке try указываем операцию, для окончания которой должен быть вызван метод close
```
try (FileReader fr = new FileReader(path);
     BufferedReader br = new BufferedReader(fr)) {
    return br.readLine();
}
```

### 10. Что необходимо реализовать для работы try-with-resources?
Интерфейс AutoCloseable


### 11. Что произойдет есть исключение будет выброшено из блока catch после чего другое исключенгие будет выброшено из блока finally
В finally можно реализовать вложенны try-catch

### 12. В чем разница между Exception и Error?
Error - невозмжноо починить</br>
Exception - можно обработать ошибку

### 13. Можно ли использовать проверяемые исключения в лямбда функциях
Нет

### 14. Как определить причину OutOutMemoryError
- Использовать утилиту jvisualvm, которая идет вместе с JDK
- Использовать Java Flight Recorder - инструмент для записи данных о работе java-приложения
- Изучение стека вызовов и логов приложения
- Установка параметров размера кучи JVM и ограничений на размер объектов, которые могут быть созданы в памяти
- Если проблема связана с больши количеством данных, то можно использовать кешировани
- Использовани е профилировщика для анализацы производительности приложения (TODO)


## END ---------------- Исключения ----------------

## Сериализация и копирование

+ [1. Что такое сериализация и как она реализована в Java?](#1-что-такое-сериализация-и-как-она-реализована-в-java)
+ [2. Для чего нужна сериализация?](#2-для-чего-нужна-сериализация)
+ [3. Опишите процесс сериализации/десериализации с использованием Serializable](#3-опишите-процесс-сериализациидесериализации-с-использованием-serializable)
+ [4. Какие поля не будут сериализованы при сериализации?](#4-какие-поля-не-будут-сериализованы-при-сериализации)
+ [5. Как изменить стандартное поведение сериализации/десериализации?](#5-как-изменить-стандартное-поведение-сериализациидесериализации)
+ [6. Как создать собственный протокол сериализации?](#6-как-создать-собственный-протокол-сериализации)
+ [7. В чем проблема сериализации Singleton?](#7-в-чем-проблема-сериализации-singleton)
+ [8. Как происходит сериализация](#8-как-происходит-сериализация)


### 1. Что такое сериализация и как она реализована в Java?
Сериализация  - это процесс сохранения объекта в последовательный байт</br>
Десериализация  - это процесс восстановления объекта в байт

### 2. Для чего нужна сериализация?
Сериализация нужна для передачи объектов

### 3. Опишите процесс сериализации/десериализации с использованием Serializable
При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:</br></br>

- запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
- рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
- запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
- рекурсивную запись объектов, которые являются полями сериализуемого объекта.</br></br>

   При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.</br></br>

   При имплементации интерфейса Serializable у класса появляется идентификатор версии.</br>
   Он вычисляется по содержимому класса - полям, порядку объявления, методам.</br>
   Соотвественно при десериализации поля, порядок и методы должны совпадать.</br>
   Чтобы избежать возможных ошибок можно вручную задать для класса идентификатор версии (long serialVersionUID)

### 4. Какие поля не будут сериализованы при сериализации?
   Те, которые не помечены как transient</br></br>

   Поля с модификатором final сериализуются как и обычные.</br>
   За одним исключением – их невозможно десериализовать при использовании `Externalizable`.</br>
   Ибо final-поля должны быть инициализированы в конструкторе,</br>
   а после этого в readExternal изменить значение этого поля будет невозможно.</br>
   Соответственно – если вам необходимо сериализовать объект, имеющий final-поле,</br>
   вам придется использовать только стандартную сериализацию.

### 5. Как изменить стандартное поведение сериализации/десериализации?
- Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации.</br>
  Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`.</br>
  Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.</br></br>

- Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,</br>
  а не метод по умолчанию :</br>
  ~ writeObject() - запись объекта в поток;</br>
  ~ readObject() - чтение объекта из потока;</br>
  ~ writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;</br>
  ~ readResolve() - позволяет заменить на себя другой объект после чтения.

### 6. Как создать собственный протокол сериализации?
Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:</br>
`writeExternal()` и `readExternal()`

### 7. В чем проблема сериализации Singleton?
Проблема в том, что после десериализации мы получим другой объект.
Как этого избежать:</br>
    - явный запрет сериализации
    - определение метода с сигнатурой (default/public/private/protected/) Object readResolve() throws ObjectStreamException


### 8. Как происходит сериализация
1. Унаследоваться от интерфейса Serializable</br>
   [Serializable] - маркерный интерфейс

2. Определить переменную
   private static final long serialVersionId = 1;</br>
   Данные поле будет содержать уникальный идентификатор версии сериализованного класса</br></br>

   При сериализации значение serialVersionId сравнивается с десериализованным значением</br>
   ! Если значения не совпадут будет выброшено исключение InvalidClassException

3. Сериализайия внутренних классов</br>
   Все вложенные классы должны имплементировать интерфейс Serializable

4. Для того, чтобы свойство не сериализовалось, необходимо использовать ключевое слово transient


## END ---------------- Сериализация и копирование ----------------

## Дженерики

+ [1. Что такое дженерики?](#1-что-такое-дженерики)
+ [2. Для чего нужны Дженерики?](#2-для-чего-нужны-дженерики)
+ [3. Что такое сырые типы?](#3-что-такое-сырые-типы)
+ [4. Что такое `wildcard`?](#4-что-такое-wildcard)
+ [5. Расскажите про принцы PECS ***](#5-расскажите-про-принцы-pecs-)


### 1. Что такое дженерики?
Дженерики - это типы с параметром

### 2. Для чего нужны Дженерики?
Дженерики помогают упростить реализацию принципа ООП - Полиморфизм</br>
Позволяют на жтапе компиляции узнать о пробелеме типов</br>
Дженерики в основном инвариантны, но через wildcart можно сделать их коваринтными </br>
Дают возможность реализовать общее поведение для нескольких реализаций

### 3. Что такое сырые типы?
Raw type - это класс-дженерик, из которого удалили его тип</br>
Возможность превратить в Raw type оставили для совмещения со старым кодом

### 4. Что такое `wildcard`?
Upper Bounded Wildcards - <? extends Animal> - в такой объект ничего кроме null положить нельзя</br>
Это значит, что метод принимает на вход коллекцию объектов класса Animal либо объектов любого класса-наследника Animal</br></br>

Lower Bounded Wildcards - <? super Animal> - Можно положить:</br>
superZoo.encage(new Elephant("Джимбо", 3));</br>
superZoo.encage(new Animal("", 1))</br>
Это значит, что метод принимает на вход коллекцию объектов класса Animal либо любого другого класса предка Animal</br></br>

extends B — символ подстановки с указанием верхней границы</br>
super B — символ подстановки с указанием нижней границы</br>
где B — представляет собой границу</br></br>

т.е.</br>
Number <=? extends Object</br>
? extends Number <=? extends Object</br>
и</br>
? super Object <=? super Number</br>

### 5. Расскажите про принцы PECS ***
Producer Extends Consumer Super - если у нас есть некая коллеция, типизированная wildcard с верхней границей (extends) то это "продюсер"

## END ---------------- Дженерики ----------------

## Коллекции

+ [1. Что такое коллекция?](#1-что-такое-коллекция)
+ [2. Расскажите про иерархию коллекций?](#2-расскажите-про-иерархию-коллекций)
+ [3. Почему Map - это не Collection, в то время как List и Set являются Collection?](#3-почему-map---это-не-collection-в-то-время-как-list-и-set-являются-collection)
+ [4. В чем разница между классами java.util.Collection и java.util.Collections?](#4-в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
+ [5. Что такое «fail-fast поведение»?](#5-что-такое-fail-fast-поведение)
+ [6. Какая разница между fail-fast и fail-safe?](#6-какая-разница-между-fail-fast-и-fail-safe)
+ [7. Чем различается Enumeration и Iterator?](#7-чем-различается-enumeration-и-iterator)
+ [8. Как между собой связаны Iterable, Iterator и «for-each»?](#8-как-между-собой-связаны-iterable-iterator-и-for-each)
+ [9. Сравните Iterator и ListIterator.](#9-сравните-iterator-и-listiterator)
+ [10. Как поведёт себя коллекция, если вызвать iterator.remove()?](#10-как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
+ [11. Чем Set отличается от List?](#11-чем-set-отличается-от-list)
+ [12. Расскажите про интерфейс Set](#12-расскажите-про-интерфейс-set)
+ [13. Что будет если добавлять элементы в TreeSet по возрастанию?](#13-что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
+ [14. Как устроен HashSet, сложность основных операций (16)](#14-как-устроен-hashset-сложность-основных-операций-16)
+ [15. Как устроен LinkedHashSet сложность основных операций](#15-как-устроен-linkedhashset-сложность-основных-операций)
+ [16. Как устроен TreeSet сложность основных операций](#16-как-устроен-treeset-сложность-основных-операций)
+ [17. Расскажите про интерфейс List](#17-расскажите-про-интерфейс-list)
+ [18. Как устроен ArrayList сложность основных операций](#18-как-устроен-arraylist-сложность-основных-операций)
+ [19. Как устроен LinkedList сложность основных операций](#19-как-устроен-linkedlist-сложность-основных-операций)
+ [20. Почему LinkedList реализует и List и Deque](#20-почему-linkedlist-реализует-и-list-и-deque)
+ [21. Как перестроить Связанный список в HashTable](#21-как-перестроить-связанный-список-в-hashtable)
+ [21. Как перестроить Связанный список в HashTable](#21-как-перестроить-связанный-список-в-hashtable)
+ [22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?](#22-существуют-ли-какие-нибудь-требованию-к-объектам-используемым-в-качестве-ключа-в-hashmap)
+ [23. Как работает HashMap?](#23-как-работает-hashmap)
+ [24. Как строиться красное-черное дерево?](#24-как-строиться-красное-черное-дерево)
+ [25. На чем основана HashSet?](#25-на-чем-основана-hashset)
+ [26. Какая структура подходит для хранения большого количества данных](#26-какая-структура-подходит-для-хранения-большого-количества-данных)
+ [27. Что может быть ключем в HashMap?](#27-что-может-быть-ключем-в-hashmap)

### 1. Что такое коллекция?
Коллекции - это наборы однородных элементов

### 2. Расскажите про иерархию коллекций?

   Первая иерархия</br>
   Collection делится на подколлекции:</br>
    - Set - описывает такую структуру как множество, содержащее неупорядоченные уникальные элементы. Есть стандартные реализации - TreeSet, HashSet,LinkedHashSet</br>
    - List - структура данных, которая хранит упорядоченную последовательность объектов. Реализации - ArrayList, Vector, LinkedList</br>
    - Queue - Хранит элементы в виде очереди, которая следует правилу First In First Out. Реализации - LinkedList, PriorityQueue</br></br>

   Вторая иерархия</br>
   Map делится на подколлекции:</br>
    - HashTable, LinkedHashMap, TreeMap

### 3. Почему Map - это не Collection, в то время как List и Set являются Collection?
Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».

### 4. В чем разница между классами java.util.Collection и java.util.Collections?
java.util.Collections - набор статических методов для работы с коллекциями.</br></br>

java.util.Collection - один из основных интерфейсов Java Collections Framework.

### 5. Что такое «fail-fast поведение»?
fail-fast означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом
</br></br>
Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.</br></br>

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):</br>
- при изменении коллекции счетчик модификаций так же изменяется;
- при создании итератора ему передается текущее значение счетчика;
- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.

### 6. Какая разница между fail-fast и fail-safe?
В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.
</br></br>
Fail-fast коллекции
Когда коллекция модифицируется во время итерации, fail-fast коллекции мгновенно выбрасывают ConcurrentModificationException для предотвращения возможной инконсистентности данных.
ArrayList, HashMap, HashSet
```java
List<String> list = new ArrayList<>();
Iterator<String> iterator = list.iterator();
list.add("element"); // Приведет к ConcurrentModificationException
```
</br></br>
Fail-safe коллекции работают с копией данных во время итерации для предотвращения инконсистентности
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
  map.put("key", 1);
  for (String key : map.keySet()) {
  map.put(key + "new", 2);
  }
```

### 7. Чем различается Enumeration и Iterator?
- с помощью Enumeration нельзя добавлять/удалять элементы;
- в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
- Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.

### 8. Как между собой связаны Iterable, Iterator и «for-each»?
Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.

Iterable
1. Интерфейс Iterable является базовым интерфейсом для любого класса, которые может быть перебираемым
2. Предоставляет метод iterator(), который возвращает объект типа iterator
3. Может быть использован в цикле for-each

Iterator
1. Интерфейс Iterator представляет собой объект, который позволяет последовательно перебирать элементы коллекции
2. Имеет 3 основных метода: hasNext() (проверяет наличие следующего элемента), next() (получает следующий элемент) и remove() (удаляет текущий элемент).

Iterable - используется для указания, что класс может быть пересобираемым
Iterator - используется для перебора элементов в коллеции

### 9. Сравните Iterator и ListIterator.
- ListIterator расширяет интерфейс Iterator
- ListIterator может быть использован только для перебора элементов коллекции List;
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next().</br>
  Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
- ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove().
  Iterator не поддерживает данного функционала.

### 10. Как поведёт себя коллекция, если вызвать iterator.remove()?
Если вызову iterator.remove() предшествовал вызов iterator.next(),</br>
то iterator.remove() удалит элемент коллекции, на который указывает итератор,</br>
в противном случае будет выброшено IllegalStateException().

### 11. Чем Set отличается от List?
List допускает дубликаты</br>
Set имеет только уникальные значения

### 12. Расскажите про интерфейс Set
Интерфейс Set расширяет интерфейс Collection</br>
Представляет набор уникальных элементов</br></br>

Реализации:
- SortedSet - NavigableSet
- AbstractSet - HashSet - LinkedHashSet
- TreeSet

### 13. Что будет если добавлять элементы в TreeSet по возрастанию?
Так как в основе TreeSet будет красное черное дерево, поэтому все элементы буду сбалансированы

### 14. Как устроен HashSet, сложность основных операций (16)
- Реализует интерфейс Set
- Базовой структурой для HashSet является HashTable
- Повторяющиеся элементы не допускаются
- порядок элементов не сохранится, так как для сохранения элементов происходит на основании хеш-кода

### 15. Как устроен LinkedHashSet сложность основных операций
- Реализует интерфейс Set
- Базовой структурой для LinkedHashSet является LinkedList
- Порядок элементов будет сохранен
- Повторяющиеся элементы не допускаются

### 16. Как устроен TreeSet сложность основных операций
- Реализует интерфейс Set
- Базовой структурой для TreeSet является TreeMap
- Используется природный порядок элементов, основанный на Comparator

### 17. Расскажите про интерфейс List</br>
Интерфейс List расширяет интерфейс Collection</br>
Представляет собой список

### 18. Как устроен ArrayList сложность основных операций
- Это список реализованный на основе массива
- Доступ к элементу по индексу за константное время
- Доступ к элементам по значению за линейное время
- Вставка в конеч за константное время
- Удаление из списка варьируется
- Вставка элемента варьируется
- необходимо одно единое пространство для хранения

### 19. Как устроен LinkedList сложность основных операций
- Это двусвязный список, основанный на объектах с ссылками между ними
- на получение элемента по индексу необходимо линейное время
- На добавление и удаление потребуется константное время
- На поиск позиции и вставки или удаления за константное время

### 20. Почему LinkedList реализует и List и Deque
- LinkedList позволяет добавлять элементы в начало и в конец списка, что хорошо согласуется с Deque

### 21. Как перестроить Связанный список в HashTable
Переопределить hashCode и использовать  "адрес в память"

### 22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?
у них должен быть реализован метод для создания ключа и значения должны быть финализированы</br>
equals и hashCode

### 23. Как работает HashMap?
- HashMap представляет собой динамический массив, так как он умеет расширяться
- Пока в HashMap нет ни одного элемента массив не иницализируется
- После инициализации массива, каждый элемент массива будет представлять из себя корзину `bucket`, представленный в виде LinkedList
- Каждый элемент LinkedList представлдяет собой Node, с полями (hash, key, value, next) (односвязанный список)
- При добавлении элемента
  - Вычисляется хэш ключа, который использует hashCode (сделано для оптимизации распределения элементов)
  ```
  // default
  static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```
  - Вычисляется индекс бакета
  ```
  // n - длина массива
  i = (n - 1) & hash
  ```
  - Создается объект Node
  - Получаем список по индексу
    - Если в списке пусто, то размещаем элемент</br>
    - Если в списке есть элементы, то хэш и ключ первого элемента поочередно сравнивается с хэшами элементов из списка
    `(p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))`
    - Если в результате всех проверок всегда был возвращен false, то элемент добавляется в конец листа
    - Если было найдено совпадение, то заменяем текущие значения на новые
  - Увеличиваем количество элементов
  - Проверяем loadFactor - если проверка loadFactor возвращает true, то массив увеличивается в 2 раза
- При удалении элемента
  - Если количество элементов в бакете становится меньше или равно 6, то красное-черное дерево превращается в связанный список
  
### 24. Как строиться красное-черное дерево?
- Элементы сортируется по хеш-коду
- Делятся на 2 ветки, начиная с первого элемента списка
- Остальные элементы распределяются направо и налево в зависимости от значения хешей
- Все левые меньше своего корневого, все правые больше
- Если хеш код элементов совпадает, то вызывается нативный `System.identityHashCode()` для вычисления хеша

### 25. На чем основана HashSet?
HashSet работает так же как и HashMap только для значения она использует объект-заглушку

### 26. Какая структура подходит для хранения большого количества данных
ArrayList

### 27. Что может быть ключем в HashMap?
- любой объект, который реализует интерфейс `java.lang.Object`

- Ключи HashMap должны быть неизменяемым, чтобы гарантировать их уникальность и согласовааное поведение
- Поэтому ArrayList, которая может измениться, может вернуть другой ключ

## END ---------------- Коллекции ----------------

## База данных

+ [1. Что такое схема, таблица](#1-что-такое-схема-таблица)
+ [2. В чем разница между Statement и PreparedStatement?](#2-в-чем-разница-между-statement-и-preparedstatement)
+ [3. План исполнения запроса](#3-план-исполнения-запроса)
+ [4. Как работает индекс в таблице](#4-как-работает-индекс-в-таблице)
+ [5. Блокировка таблицы](#5-блокировка-таблицы)
+ [6. Оптимистическая/пессимистическая блокировки](#6-оптимистическаяпессимистическая-блокировки)
+ [7. Транзакции](#7-транзакции)
+ [8. Пул соединений к БД](#8-пул-соединений-к-бд)
+ [9. Функция vs Процедура](#9-функция-vs-процедура)
+ [10. Что означает ASID](#10-что-означает-asid)
+ [11. Какие ошибки отменяют транзакцию?](#11-какие-ошибки-отменяют-транзакцию)
+ [12. Как удалить все записи из таблицы](#12-как-удалить-все-записи-из-таблицы)
+ [13. Как работает while loop](#13-как-работает-while-loop)
+ [14. Что такое postgres view](#14-что-такое-postgres-view)
+ [15. Какие бывают типы ключей](#15-какие-бывают-типы-ключей)
+ [16. Тип ключа `check`](#16-тип-ключа-check)
+ [17. Тип ключа `not-null`](#17-тип-ключа-not-null)
+ [18. Тип ключа `unique`](#18-тип-ключа-unique)
+ [19. Тип ключа `primary keys`](#19-тип-ключа-primary-keys)
+ [20. Тип ключа `foreign keys`](#20-тип-ключа-foreign-keys)
+ [21. Типы поведений при использовании foreig keys](#21-типы-поведений-при-использовании-foreig-keys)
+ [22.  Тип ключа `exclusion constrains`](#22-тип-ключа-exclusion-constrains)

### 1. Что такое схема, таблица
- Схема - это формальное описание структуры и взаимосвязи таблиц и других объектов в бд
  - определение таблиц
  - определение столбцов
  - определение типов данных
  - определение ограничений
  - определение отношений
  - определение индексов
- Таблицы - основной элемент базы данных. Состоит из:
  - столбцов
  - строк

### 2. В чем разница между Statement и PreparedStatement?
Statement - не защищен</br>
PreparedStatement - переданные параметры защищены от sql инъекций

### 3. План исполнения запроса
Пример Postgresql</br></br>

   Explain [(OPTION [,...])]</br>
- Analyze [boolean] - запрос выполнится и составит план выполнения
- Verbose [boolean] - добавит дополнительную информацию
- Costs [boolean] - добавит стоимость каждого запроса
- Buffer [boolean] - определяет число блоков с диска и из кеша
- Timing [boolean] - Время запуска и время выполнения на каждом узле
- Summary [boolean]
- Format [TEXT|XML|JSON|YAML] - для подготовки отчета

### 4. Как работает индекс в таблице
1. Таблица без индексов выглядит как куча (Heap). При запросе будет сканироваться вся таблица
2. Преимущества индексов
   - Повышают скорость поиска информации и производительность запросов
3. Недостатки
   - Требуют много места на диске и в оперативной памяти
   - Замедляют производительность системы (медленнее выполняются операции вставок, обновлений, удалений)
4. Структура
   - Состоят из:
   - наборов страниц
   - узлов, имеющих древовидную структуру, иерархическую
   - Хранятся в виде сбалансированных B-деревьев
   - При создании индекса создаются указатели на строки таблицы, которые удовлетворяют условию
5. Виды индексов
   - Составной (несколько колонок)
   - Функциональные или индекс по выражению
   - Обычный, по одной колонке
6. Типы индексов
   - B-tree (дефолтное)
   - Hash - хранятся в 32-битной хеш код, полученный из значения индексируемого столбца
     Обрабатывает только операции равенства (медленнее чем B-tree в Posgtresql)
   - Gist - это инфраструктура, в которой можно реализовать множество стратегий индексирования</br>
   Подходит для вычисления гео данных, расстояние, пересечение площадей</br>
   Есть триграм, позволяет искать по вхождению и индексировать (regexp)
   - Sp-gist - это инфраструктура, которая поддерживает различные виды поиска.
     Позволяет реализовать несбалансированные дисковые структуры данных
   - Gin - инвертированные индексы, которые подходят для данных, содержащих компонентные значения, например массивы
   - Brin - хранят сводки о значениях, хранящихся в последовательных диапазонах физических блоков таблицы

### 5. Блокировка таблицы
Виды блокировок
- Разделяемые (shared locks) - блокировка на чтение
- Монолитные (exclusive locks) - блокировка на чтение и запись</br>

   --- Табличная блокировка (exclusive lock)

   `Lock Tables`

| +         | -      | 
|---------------------|-----------------------------|
| требуют небольшого объема памяти  | Отстуствует параллелизм   |
| быстрая работа при блокировке большого количества таблиц     | Все остальные операции ждут |
| быстрая работа при операциях Group by или при полном сканировании |   |
 | Подходит когда данные меняются редко                      |     |


   --- Пользовательская блокировка - конкретной строки
   ```SELECT GET_LOCK(‘key’, 10); - key & timeout```

| +         | -                                                                            | 
|------------------------------------------------------------------------------|-----------------------------|
| одна блокировка для всех приложений  | Небезопасно использовать с репликацией на основе SQL-выражений               |
| Блокировка на уровне приложения | Из-за возможности вызвать сколько угодно lock опасность множества блокировок |
| Подобие транзакции |                                                                              |
| Меньше издержки чем у транзакции |                                                                              |


   ---Глобальная блокировка

   При применении
    - конфликтует с другими блокировками
    - Вызывает снятие всех предыдущих блокировок

| +         | -      | 
|---------------------|-----------------------------|
| Для получения резервной копии  | Нужно быть аккуратным и знать что делать  |
| Эту команду использует для быстрого alter таблиц | Может быть довольно длительной, так как будет дожидаться выполнения всех Select запросов |
| не так затратна как полная остановка сервера, так как большая часть информации кешируется |   |
| Используется для восстановления |     |

   ---Построчные блокировка

| +         | -      | 
|---------------------|-----------------------------|
| Лучшее управление конкуретным доступом  | Максимальные издержки |
| Позволяет одновременно выполнять несколько изменений одного ресурса | Приводит к взаимоблокировки |
| Позволяет заблокировать одну строку на долгое время | Работают медленнее табличных блокировок если используется большая часть таблицы|
| Меньше конфликтов блокировок |  Работают намного медленней при полном сканировании таблицы или для группировок Group by |

### 6. Оптимистическая/пессимистическая блокировки
- **Оптимистическая блокировка** - множество транзакция могут завершиться без влияния друг на друга
    - могут выполняться без блокировок тех ресурсов, на которые влияют
    - Перед коммитом, каждая транзакция проверяет, что ни одна другая транзакция не модифицировала ее данные
    - Если проверка выявила конфликтующие модицикации, транзакция откатывается
- **Пессимистичная блокировка** - параллельные транзакции будут конфликтовать каждая друг с другом и требует блокировки после их чтения и снятия после завершения использования данных

+ [13. Как реализовать блокировки в Hibernate](#13-как-реализовать-оптимистическую-блокировку)

### 7. Транзакции
- Каждая транзация начинается с инструкции
  Begin Transaction и заканчивается
  Commit или Rollback

- Транзакция - это совокупность операций над базов, которые могут быть либо выполнены все вместе либо не будет выполенна ни одна из них

- Транзакции основаны на многоверсионной модели (Multiversion Concurrency Control)
    - каждый Sql оператор видит так называемый снимок данных (snapshot)
    - Снимок - это не физическая копия всей базы, это несколько чисел, которые идентифицируют текущую транзакцию и те транзакции,
      которые уже выполнились в момент начала текущей

**Свойства транзакий**
- Атомарность - транзакция либо выполняется полностью, либо не выполняется совсем
- Согласованность - после успешного выполнения транзакции база данных должны быть приведена из олного состояние в другое
- Изолированность - Во время выполнения транзации другие транзакции должны оказывать минимальное влияние на нее
- Долговечность - После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных

**Риски**
   
  - _Потерянное обновление (lost update)_ - Когда разные транзакции одновременно изменяют ожни и те же данные, то после фиксации изменений может оказаться,
  что одна транзакция перезаписала другую
  - Грязное чтение (dirty read) - Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась.
  Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе
  - _Неповторяющиеся чтение (non-repeatable read)_ - При повторном чтении тех же данных в рамках одной транзакции оказывается, что другая транзакция успела изменить
  и зафиксировать эти данные
  - _Фантомное чтение (phantom read)_ - Транзакция выполняет сборку данных и параллельно другая транзакция добавляет строки
  - _Аномалия сериализации (serialization anomaly)_ - Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одной
  из возможных вариантов упорядочения этих транзакций

**Уровни изоляции**

- Read uncommitted (dirty read)
- Read committed - только зафиксированные изменения - есть в Posgresql (по умолчанию)
- Repeatable read (phantom read) - видим вставленные записи - есть в Posgresql
- Serializable - самый безопасный - есть в Posgresql

| isolation level  | dirty read | nonrepeatable read | phantom read | serialization anomaly |
|------------------|------------|--------------------|--------------|-----------------------|
| read uncommitted | + (not PG) | +                  | +            | +                     |
| read committed   | -          | +                  | +            | +                     |
| repeatable read  | -          | -                  | + (not PG)   | +                     |
| serializable     | -          | -                  | -            | -                     |

### 8. Пул соединений к БД
   Это шаблон доступа к данным, основной целью которого является снижение накладных расходов, связанных с выполнение подключений к бд</br></br>

   Этапы соединения с БД</br>
    - Открытие соединения с БД с помощью драйверов
    - Открытие TCP  сокетов для чтения/записи
    - Чтение/запись данных через сокет
    - Закрытие соединения
    - Закрытие порта</br></br>

   Так как открытие соединения с БД это трудозатратная операция, мы можем настроить ряд соединений при старте приложения,</br>
   которыми мы будем пользоваться в процессе

### 9. Функция vs Процедура

**Функции**
- Имеет возвращаемый тип и возвращаемое значение
- Использование DML(insert, update,delete) запросов внутри функции невозможно.
  Разрешены только SELECT запросы
- Не имеет выходных аргументов
- Вызов хранимой процедуры из функции невозможен
- Вызов функции внутри SELECT запросов возможен

```
   //создает или заменяют функцию с именем
   CREATE [or REPLACE] FUNCTION function_name
   (param_list)
   // возвращаемый тип
   RETURN return_type
   LANGUAGE plpgsql
   as
   $$
   // объявление переменных
   DECLARE
   -- variable declaration
   // начало запроса
   BEGIN
   -- logic
   // окончание запроса
   END;
   $$
```
**Процедура**
- Не имеет возвращаемого типа, но имеет выходные аргументы 
- Использование DML запросов возможно 
- Имеет входные и выходные аргументы 
- Использование или управление транзакциями возможно в хранимой процедуре 
- Вызов процедуры из SELECT запросов невозможен
```
   CREATE [or REPLACE] PROCEDURE procedure_name
   (param_list)
   LANGUAGE language_name
   AS
   $$
   -- stored-procedure-body
   $$
```

### 10. Что означает ASID
- Atomicity - Атомарность
- Consistency - Согласованность
- Isolation - Изолированность
- Durability - Надежность</br>

1. _Атомарность_ гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем</br>
Не допускаются промежуточные состояния
2. _Согласованность_ - транзакция, достигающая своего завершения(EOT - end of transaction) и, тем самым, фиксирующая свои результаты, согхраняет согласованность базы данных</br>
Упорядоченное множество операций, переводщих базу данных из одного согласованного состояние в другое
3. Изолированность - во время выполнения транзакции параллельные транзакции не должны оказывать влияния на ее результат
4. Надежность - Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя

### 11. Какие ошибки отменяют транзакцию?
Error

### 12. Как удалить все записи из таблицы
- Удалить данные из одной таблицы
```
TRUNCATE table_name;
DELETE FROM table_name;
```
- Удалить данные из нескольких таблицы
```
TRUNCATE table_a, table_b, …, table_z;
```

### 13. Как работает while loop
```
DO $$
DECLARE 
_id int :=0;
BEGIN
	WHILE _id < 6 LOOP
	INSERT INTO dummy_insert(id)VALUES(_ID);
	_id := _id+1;
	END LOOP;
END $$;

SELECT * FROM dummy_insert;
```

### 14. Что такое postgres view
view - э виртуальная таблица. Хранит результат выполнения SELECT запроса</br>
С помощью вьюхи можно сохранить SELECT запрос и получить быстрый доступ к часто используемым данным
```
CREATE VIEW influencers AS
  SELECT name, email, created_at
  FROM users
  WHERE follower_count > 1000;
  
DROP view [ IF EXISTS ] view_name;
```

### 15. Какие бывают типы ключей
- check constrains
- not-null constrains
- unique constrains
- primary keys
- foreign keys
- exclusion constrains

### 16. Тип ключа `check`
- Позволяет определить булево выражение
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);
```
- Можно задать отдельное имя ключу
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```
- Определить ключ, который относится к нескольким колонкам
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

### 17. Тип ключа `not-null`
- Колонка всегда должна содержать значение отличное от null
```
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);
```
- Колонка может иметь несколько ключей
```
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price > 0)
);
```

### 18. Тип ключа `unique`
- Значение в каждой строче не должно повторяться, должно быть уникально
```
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);
```
- Группа колонок
```
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);
```
- 2 значения null не считаются одиннаковыми, поэтому стоит добавлять `NULLS NOT DISTINCT`
```
CREATE TABLE products (
    product_no integer UNIQUE NULLS NOT DISTINCT,
    name text,
    price numeric
);
```

### 19. Тип ключа `primary keys`
- Колонка или группа колонок может использоваться как уникальный идентификатор
```
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
```
идентично
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

### 20. Тип ключа `foreign keys`
- Обозначает, что данное значение связано с колонкой в другой таблице
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```
- Если мы хотим хранить ключи только на те элементы, которые действительно есть в другой таблице
```
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
```
- Группа ключей
```
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```
- Реализация many-to-many
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

### 21. Типы поведений при использовании foreig keys
- `ON DELETE RESTRICT` Запрет на удаление элементов
- `ON DELETE CASCADE` При удалении удалить все связанные элементы
- `ON DELETE NO ACTION` - дефолтное поведение, ничего не происходит, при проверке ключа будет выброшена ошибка
- `ON DELETE SET NULL` - При удалении будут выставлены нуловые значения
- `ON DELETE SET DEFAULT` - При удалении будут выставлены дефолтные значения (если дефолтное значение не будет соотвествовать условиям, то операция не будет выполнена)
```
CREATE TABLE tenants (
    tenant_id integer PRIMARY KEY
);

CREATE TABLE users (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    user_id integer NOT NULL,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE TABLE posts (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    post_id integer NOT NULL,
    author_id integer,
    PRIMARY KEY (tenant_id, post_id),
    FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL (author_id)
);
```

### 22. Тип ключа `exclusion constrains`
- При сравнении колонок, ни одно из сравнений не вернет true
```
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &&)
);
```

## END ---------------- База данных ----------------

## Concurrency

+ [1. В чем разница между sleep() и wait()?](#1-в-чем-разница-между-sleep-и-wait)
+ [2. От какого количества начинается многопоточность?](#2-от-какого-количества-начинается-многопоточность)
+ [3. Какие есть издержки у многопоточности?](#3-какие-есть-издержки-у-многопоточности)
+ [4. Какие потоки создает JVM при запуске?](#4-какие-потоки-создает-jvm-при-запуске)
+ [5. Какой класс является потокобезопасным?](#5-какой-класс-является-потокобезопасным)
+ [6. Какие операции являются атомарными](#6-какие-операции-являются-атомарными)
+ [7. Что может являться монитором?](#7-что-может-являться-монитором)
+ [8. Как обезопасить использование объектов](#8-как-обезопасить-использование-объектов)
+ [9. Как создать потокобезопасный класс](#9-как-создать-потокобезопасный-класс)
+ [10. Что происходит при использовании synchronized](#10-что-происходит-при-использовании-synchronized)
+ [11. Как работает неблокирующая read блокировка](#11-как-работает-неблокирующая-read-блокировка)
+ [12. Как работает Оптимистическая блокировка](#12-как-работает-оптимистическая-блокировка)
+ [13. Как работают классы Atomic из пакета java.util.concurrent.atomic](#13-как-работают-классы-atomic-из-пакета-javautilconcurrentatomic)
+ [14. Чем отличается Runnable от Callable](#14-чем-отличается-runnable-от-callable)
+ [15. Конкурентные коллекции - классы для работы с коллекциями внутри потоков](#15-конкурентные-коллекции---классы-для-работы-с-коллекциями-внутри-потоков)
+ [16. `ConcurrentHashMap`](#16-concurrenthashmap)
+ [17. `CopyOnWriteArrayList`](#17-copyonwritearraylist)
+ [18. Блокирующие очереди](#18-блокирующие-очереди)
+ [19. Паттерн "Производитель-потребитель"](#19-паттерн-производитель-потребитель)
+ [20. Паттерн "Кража работ"](#20-паттерн-кража-работ)
+ [21. Блокирующие и прерываемые методы](#21-блокирующие-и-прерываемые-методы)
+ [22. Синхронизаторы - Классы для создания синхронизирующих точек](#22-синхронизаторы---классы-для-создания-синхронизирующих-точек)
+ [23. Синхронизатор - Защелки - latch](#23-синхронизатор---защелки---latch)
+ [24. `CountDawnLatch`](#24-countdawnlatch)
+ [25. `ReentrantLock`](#25-reentrantlock)
+ [26. `ReentrantReadWriteLock`](#26-reentrantreadwritelock)
+ [27. Синхронизаторы - FutureTask](#27-синхронизаторы---futuretask)
+ [28. Синхронизаторы - Семафоры](#28-синхронизаторы---семафоры)
+ [29. `Semaphore`](#29-semaphore)
+ [30. Синхронизаторы - Барьеры](#30-синхронизаторы---барьеры)
+ [31. `CyclicBarrier`](#31-cyclicbarrier)
+ [32. Какие недостатки у неограниченного количества потоков](#32-какие-недостатки-у-неограниченного-количества-потоков)
+ [33. Executors](#33-executors)
+ [34. Методы Executors](#34-методы-executors)
+ [35. Методы жизненного цикла Executors](#35-методы-жизненного-цикла-executors)
+ [36. Что такое "утечка потока"](#36-что-такое-утечка-потока)
+ [37. Жизненный цикл задачи, выполняемой исполнителем](#37-жизненный-цикл-задачи-выполняемой-исполнителем)
+ [38. Что такое `CompletionService`](#38-что-такое-completionservice)
+ [39. `ExecutorCompletionService`](#39-executorcompletionservice)
+ [40. Сколько куч будет при множественных потоках]()

### 1. В чем разница между sleep() и wait()?
wait - освобождает монитор</br>
sleep- не освобождает монитор

### 2. От какого количества начинается многопоточность?
- от двух

### 3. Какие есть издержки у многопоточности?
- Context switches - контекстные переключения</br>
Приостановка работы активных потоков для работы других потоков</br>
Они сохраняют и восстанавливают контекст выполнения, но приводят к потере локальности и процессорного времени

### 4. Какие потоки создает JVM при запуске?
- Главный поток main
- Потоки для служебных задач (например сбора мусора)

### 5. Какой класс является потокобезопасным?</br>
Если он ведет себя правильно во время допуска из многочисленных потоков, независимо от того, как выполнение этих потоков планируется или перемещается рабочей средой</br>
и без дополнительной синхронизации или другой координации со стороны вызывающего</br>
Инкапсулируют любую логику необходимую для синхронизации сами и не нуждаются в помощи клиента

### 6. Какие операции являются атомарными</br>
Операции являются атомарными если с точки зрения потока, выполняющего операцию А, операция В либо была выполнена целиком другим потоком, </br>
либо не выполнена даже частично

### 7. Что может являться монитором?</br>
Каждый объект Java может неявно действовать как замок для целей синхронизации, то есть внутренним замком (intrinsic lock)</br>
или мониторным замком (monitor locks)</br></br>

Внутренние замки действуют как взаимоисключающие замки - мьютексы(mutual exclusion locks)

### 8. Как обезопасить использование объектов
- Ограничение одним потоком
- Совместный доступ только для чтения
- Совместная потокобезопасность - объект выполняет синхронизацию внутренне, поэтому потоки свободно обращаются к нему через его публичный интерфейс
- Защищенность - с удержанием конкретного замка можно обращаться к объекту, инкапсулированному в другие потокобезопасные объекты, а также к опубликованному объекту, защищенному замком

### 9. Как создать потокобезопасный класс
- Ограничение одним экземпляром - объект инкапсулируется в другой объект, к коорому имеют доступ только некоторые известные ветки кода (Collections.synchronizedList)
- Мониторный шаблон Java (HashTable) - состояние под защитой внутреннего замка

### 10. Что происходит при использовании `synchronized`
- Попытка блокирования монитора
- Блокировка потока
- Разблокировка монитора
- Разблокировка потока

### 11. Как работает неблокирующая read блокировка
- Не ожидает пока данные будут готовы для чтения
- Если данные не готовы в момент обращения, то возвращается пустой ответ или код ошибки
- Операция является асинхронной

### 12. Как работает Оптимистическая блокировка
- Основана на идее, что два потока могут изменить один и тот же ресурс

1. Поток сначала делает копию ресурса в локальный буффер
2. Изменяет ресурс
3. Сравнивает с оригинальным ресурсом
4. Если никакой другой поток не изменил ресурс, то изменения применяются
5. Если ресурс был изменен, то поток сбрасывает свои изменения и потовряет все с пункта 1

### 13. Как работают классы Atomic из пакета `java.util.concurrent.atomic`
- Использует "Оптимистическую блокировку"

### 14. Чем отличается Runnable от Callable
| Runnable                                                                                 | Callable                                                                         |
|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Возвращает значение                                                                      | Может вернуть результат вычисления                                               |
| Содержит только 1 метод run(), который не принимает аргументов и не возвращает результат | Содержит метод call(), который может выбразывать исключения, не требуя обработки |
| Для выполнения можно использовать   ExecutorService и Thread лассы                       | Для выполнения можно использовать ExecutorService и FutureTask классы            |

### 15. Конкурентные коллекции - классы для работы с коллекциями внутри потоков
- `ConcurrentHashMap`
    - При записи блокируется только часть (сегмент)
- `CopyOnWriteArrayList`
    - Блокирующий на запись
    - Не блокирующий на запись
- `CopyOnWriteArraySet`
    - CopyOnWriteArrayList без значений
- `ConcurrentSkipListMap`
- `ConcurrentSkipListSet`
    - ConcurrentSkipListMap без значений
- `Queue`
  - Для временногого хранений множества элементов во время ожидания ими обработки
  - `ConcurrentLinkedQueue` - традиционная очередь с дисциплиной доступа FIFO
  - `PriorityQueue` - неконкурентная упорядоченная очередь с приоритетом
- `DelayQueue`
    - PriorityBlockingQueue разрешающая получить элемент только после определенной задержки
- `LinkedTransferQueue`

### 16. `ConcurrentHashMap`
- Это хешировання ассоциациативный массив Map
- Не использует синхронизацию каждого метода на общем замке и ограничение доступа одним потоком за раз
- Использует **замковое расщепление на полосы (lock striping)**
- Обеспечивает конкурентность между читающими потоками, между читателями и писателями
- Предоставляет итераторы, которые не выдают исключение `ConcurrentModificationException`

### 17. `CopyOnWriteArrayList`
- Принцип "Копировать при записи"
- При создании и публикации копии коллекции после каждого ее изменения реализуется мутируемость
- Итераторы сохраняют ссылку на резервный массив, который был актуальным в начале итератичного обхода

### 18. Блокирующие очереди
- `BlockingQueue`
    - Если очередь пустая, то операция извлечения заблокирована
    - Если ограниченная очередь заполнена, то операция вставки будет заблокирована
- `LinkedBlockingQueue`
  - Однонаправленный BlockingQueue
- `ArrayBlockingQueue`
    - четкая очередь для передачи сообщений из одного потока в другой
    - Запрещает null значения
    - Емкость очереди указывается при создании
- `LinkedBlockingQueue`
    - Однонаправленный BlockingQueue
- `PriorityBlockingQueue`
- `SynchronousQueue`
  - не содержит места для хранения элементов
  - поддерживает список потоков, ожидающих постановки элемента в очередь или его удаления
( Двухсторонные очереди )
- `LinkedBlockingDeque`
    - Двунаправленный BlockingQueue
- `BlockingDeque`

### 19. Паттерн "Производитель-потребитель"
- Производители помещают данные в очередь, ничего не зная о потребителях, которые будут извлекать эти данные
- Потребитель не должны знать откуда берется работа
- Паттерн поддерживает **серийное ограничение одним потоком (serial thread confinement)** мутируемых объектов
  - Если пул содержит внутреннюю синхронизацию, 
  - а кликенты не собираются публиковать принадлежащий пулу объект или использовать его после возвращения в пул
  - владение может безопасно передаваться из потока в поток

```
public class FileCrawler implements Runnable {
    private final BlockingQueue<File> fileQueue;
    private final FileFilter fileFilter;
    private final File root;
    ...
    public void run () {
        try {
            crawl(root);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void crawl (File root) throws InterruptedException {
        File[] entries = root.listFiles(fileFilter);
        if (entries != null) {
            for (File entry : entries) {
                if (entry.isDirectory()) {
                    crawl(entry);
                } else if (!alreadyIndexed(entry)) {
                    fileQueue.put(entry);
                }
            }
        } 
    }
}

public class Indexer implements Runnable {
    private final BlockingQueue<File> queue;
    
    public Indexer (BlockingQueu<File> queue) {
        this.queue = queue;
    }
    
    public void run () {
        try {
            while (true) {
                indexFile(queue.take());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

}

public static void startIndexing (File[] roots) {
    BlockingQueue<File> queue = new LinkedblockingQueue<File>(BOUND);
    FileFilter filter = new FileFilter(){
        public boolean accept (File file) { return true; }
    };
    
    for (File root : roots) {
        new Thread (new FileCrawler(queue, filter, root)).start();
    }
    
    for (int i = 0; i < N_CONSUMERS, i++) {
        new Thread (new Indexer(queue)).start();
    }
}
```

### 20. Паттерн "Кража работ"
- Двухсторонняя очередь позволяет эффективно вставлять и удалять как голову очередь так и ее хвост
- Каждый потребитель исчерпывает работу в своей очередь
- Может украсть работу из чужой очереди
- Просмотр чужой очереди начинается с конца
( Используется )
- В алгоритмах разведывания графов - маркировка кучи во время сборки мусора

### 21. Блокирующие и прерываемые методы
- Прерывание представляет собой кооперативный механизм
  - Когда поток А пытается прерывать поток В, то просто просит поток В прекратить это делать
- При вызове метода interrupt нужно учитывать
1. **Распространить исключение** InterruptedException
   - неотлавливание исключение
   - или отлавливание и его повторная выдача после обработки
2. **Восстановить прерывание**
   - Когда невозможно распространить исключение необходимо перехватить исключение и восстановить статус прерванности (например в Runnable)

### 22. Синхронизаторы - Классы для создания синхронизирующих точек
- Это любой объект, координирующий поток управления в остальных потоках, основываясь на их состоянии
- Синхронизаторы инкапсулируют состояние, которое определяет пропускать или отправлять в ожидание поступающие потоки

### 23. Синхронизатор - Защелки - latch
- Синхронизатор, который может зардерживать продвижение потоков до достижения своего конечного состояния
- Предназначены для ожидания событий

- `CountDownLatch`
- `ReentrantLock`
- `ReentrantReadWriteLock`

1. Состояние защелки состоит из счетчика, инициализируемого положительным числом ожидаемых событий 
2. Метод `countDown` уменьшает счетчик, сигнализируя о том, что произошло событие
3. Метод `await` ожидают до тех пор, пока счетчик не достигнет нуля

### 24. `CountDawnLatch`
- Позволяет ожидать завершения других потоков
- При инициализации указывается количество блокирующих операций
- Как только CountDawnLatch.countDown будет вызван указанное количество раз и счетчик станет равен 0, тогда поток разблокируется
- Не зависимо от того, сколько раз будет вызван `await` в рамках одного потока, достаточно одного вызова `countDown` для освобождения счетчика

```
public class TestHarness {
    public long timeTasks (int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        
        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread () {
                public void run () {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            
            t.start();
        }
        
        long start = System.nanotTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
```

### 25. `ReentrantLock`
- Блокировка
    - Может блокировать доступ к ресурсу на нескольких уровнях
    - При использовании метода `lockInterruptibly` блокировка может быть прервана
- Свободный доступ
    - Метод tryLock позволяет проверить свободен ли ресурс и попытаться захватить если он свободен
- Инкремент счетчика блокировок
    - Создержит внутренний счеткик блокировок, что позволяет увеличивать его каэдый раз, когда поток пытается захватить блокировку
    - Таким образом может блокировать доступ к ресурсу только тому же потоку, который блокировал его ранее
    - Если другой поток запросит доступ к ресурсу, пока он заблокирован, он будет заброкирован, пока первый поток не освободит блокировку

```
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
  private final ReentrantLock reentrantLock = new ReentrantLock();

  public void accessResource() {
    reentrantLock.lock();
    try {
      // Доступ к общему ресурсу
    } finally {
      reentrantLock.unlock();
    }
  }
}
```

```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
  private final ReentrantLock lock = new ReentrantLock();
  private final Condition condition = lock.newCondition();

  public void accessResource() throws InterruptedException {
    lock.lock();
    try {
      while (!conditionIsMet()) {
        condition.await();
      }
      // Доступ к общему ресурсу
    } finally {
      lock.unlock();
    }
  }

  public void notifyCondition() {
    lock.lock();
    try {
      // Изменение состояния условия
      condition.signalAll();
    } finally {
      lock.unlock();
    }
  }

  private boolean conditionIsMet() {
    // Проверка условия
  }
}
```

### 26. `ReentrantReadWriteLock`
- Read lock - Если ни один поток не пишет, то любое число потоков может читать
- Write Lock - Если ни один поток не читает, то один поток может писать

### 27. Синхронизаторы - FutureTask
- Реализует `Future`, описывающий абстрактные вычсисления, приносящие результат, котоыре реализуется с помощью интерфейса `Callable`
- Могут находиться в состоянии ожидания выполнения
* Не рекомендуется запускать поток из конструктора или статического инициализатора
```
public class Preloader {
    private final FutureTask<ProductInfo> future = 
        new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    
    private final Thread thread = new Thread(future);
    
    public void start () { thread.start(); }
    
    public ProductInfo get () throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) {
                throw (DataLoadException) cause;
            } else {
                throw launderThrowable(cause);
            }
        }
    }
}
```

### 28. Синхронизаторы - Семафоры
- Регулируют число действий, способных обращаться к определенному ресурсу или выполнять одну и ту же задачу в одной и то же время

- `Semaphore`

### 29. `Semaphore`
- ограничивает количество потоков, которые могут получить доступ до секции
- Управляет набором вируальных разрешений (permits)
- Начальное число значений передается конструктору
- Действия могут приобретать разрешения (`acquire`)
- Действия могут освобождать разрешения (`release`)
- Превращает любую коллекцию в блокирубющуя связанную коллекцию

### 30. Синхронизаторы - Барьеры
- Блокируют группу потоков до наступления какого-то события
- Заствялют потоки вместе проходить барьерную точку в одно и то же время
- Предназначены для ожидания других потоков

- `CyclicBarrier`
- `Exchanger` - двухсторонний барьер
- `Phaser` - расширяет функциональность `CyclicBarrier`

### 31. `CyclicBarrier`
- Выполняет синхронизацию заданного количества потоков в одной точке

### 32. Какие недостатки у неограниченного количества потоков
- создание каждого потока занимает время и требует некоторой обрабатывающей деятельности
- Ресурсопотребление - Потоки потребляют системные ресурсы, в особенности память
- Стабильность - есь лимит на число создаваемых потоков

### 33. Executors
Использование Executor является одним из способов реализации паттерна "производитель-потребитель"</br>

- Помогает повторно использовать освободившиеся потоки
- Помогает организовывать очереди из пула потоков
- Помогает подписываться на результат выполнения задачи

1. `ThreadPoolExecutor` - пул потоков с возможностью указывать рабочее и максимальное кол-во потоков в пуле
2. `ScheduledThreadPoolExecutor` - расширяет фунционал `ThreadPoolExecutor` возможностью выполнять задачи отложенно или регулярно
3. `ThreadPoolExecutor` - Более легкий пул потоков для "самовоспроизводящихся" задач

### 34. Методы Executors
- newFixedThreadPool - пул потоков фиксированного размера создает определенного число потоков по мере предоставления задач, а зачем стараетсяч держать размер пула
- newCachedThreadPool - кэшированный пул потоков убирает простаивающие потоки и при необходимости добавляет новые
- newSingleThreadExecutor - Создает один поток для последовательной обработки задач
- newScheduledThreadPool - пул потоков фиксированного размера, который поддерживает отложенное и переодическое выполнение задач

### 35. Методы жизненного цикла Executors
- Жизненный цикл имеет три состояния
  - работает
  - выключается
  - терминирован
```
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    ...
}
```

### 36. Что такое "утечка потока"
Timer - Поток не может отлавливать непроверяемое исключение, выдаваемое из задачи TimeTask, которое его терминирует

### 37. Жизненный цикл задачи, выполняемой исполнителем
- создана
- предоставлена
- запущена
- завершена
```
public interface Callable<V> {
    V call() throws Exception;
}

public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException, CancellationException;
    V get(long timeout, TimeUnit unit) thows InterruptedException, ExecutionException, CancellationException, TimeoutException;
}
```

### 38. Что такое `CompletionService`
- Сочетает в себе функционал исполнителя `Executor` и блокирующей очереди `BlockingQueue`
- Можно передавать ей задачи `Callable` на выполнение и использовать методы `take` и `poll`

### 39. `ExecutorCompletionService`
- может использовать один исполнитель `Executor` совместно
- В данном кейсе `CompletionService` действует как дескриптор для пакета вычислений.
  - Запоминает число задач
  - Подсчитывает число извлеченных завершенных результатов
- Можно узнать когда все результаты для данного пакеты были извлечены благодаря работе `CompletionService`

### 40. Сколько куч будет при множественных потоках
Куча всегда общая для всех потоков и все потоки имеют к ней доступ


## END ---------------- Concurrency ----------------

## Spring изнутри

+ [1. Ключевые понятие Spring](#1-ключевые-понятие-spring)
+ [2. Какая структура у Spring контейнера](#2-какая-структура-у-spring-контейнера)
+ [3. Какая структура у Spring](#3-какая-структура-у-spring)
+ [4. Что такое автоконфигурация в контексте Spring](#4-что-такое-автоконфигурация-в-контексте-spring)
+ [5. Условия создания бина](#5-условия-создания-бина)
+ [6. Что содержит аннотация `@SpringBootApplication`](#6-что-содержит-аннотация-springbootapplication)
+ [7. Что делает метод `SpringApplication.run()`](#7-что-делает-метод-springapplicationrun)
+ [8. Что такое `AnnotationConfigEmbeddedWebApplicationContext`](#8-что-такое-annotationconfigembeddedwebapplicationcontext)
+ [9. За что отвечает аннотация `EnableAutoConfiguration`](#9-за-что-отвечает-аннотация-enableautoconfiguration)
+ [10. Какие есть этапы инициализации](#10-какие-есть-этапы-инициализации)
+ [11. Этап Парсирование конфигурациии создание 'BeanDefinition'](#11-этап-парсирование-конфигурациии-создание-beandefinition)
+ [12. Этап Настройка созданных 'BeanDefinition'](#12-этап-настройка-созданных-beandefinition)
+ [13. Что содержит фабрика `BeanFactoryPostProcessor`](#13-что-содержит-фабрика-beanfactorypostprocessor)
+ [14. Этап Создание кастомных `FactoryBean`](#14-этап-создание-кастомных-factorybean)
+ [15. Этап Создание экземпляров бинов](#15-этап-создание-экземпляров-бинов)
+ [16. Этап Настройка созданных бинов](#16-этап-настройка-созданных-бинов)
+ [17. Как создаются контекст и бины? Опишите флоу создания спринг приложения](#17-как-создаются-контекст-и-бины-опишите-флоу-создания-спринг-приложения)
+ [18. Жизненный цикл бина](#18-жизненный-цикл-бина)
+ [19. Жизненный цикл spring](#19-жизненный-цикл-spring)
+ [20. Какой тип наследования используется при расширении бина](#20-какой-тип-наследования-используется-при-расширении-бина)
+ [21. Типы расширения бинов](#21-типы-расширения-бинов)

### 1. Ключевые понятие Spring
- Бины - это обычный объект, который живет внутри DI-контейнера
- DI-контейнер - Ключевой и фундаментальный механизм Spring.

Спринт - это по сути набор бинов, связанных вместе через DI контейнер</br>
При конфигурации например 'OAuth' в 'application.properties' спринт предоставляет бин 'OAuth2RestTemplate'</br>
При этом этот бин при обращении к внешнему API будет знать, куда и как пойти, чтобы получить OAuth токен</br>
как его обновлять, в какое место нашего запроса его добавлять и т.д.</br>
То есть контейнер - это механизм общения между нашим кодом и библиотеками, подключенными к проекту</br></br>

Использование инъекций зависимостей не подразумевает создания интерфейсов для каждого компонента.</br></br>

- Контекст - Представлен интерфейсом 'ApplicationContext'. Позволяет реагировать на различные события,</br>
  которые происходят внутри приложения, управлять жизненным циклом

- Конфигурация - описание доступных бинов</br>
  Бины могут быть описаны как в одном файле, так как и в разных

- Сканирование компонентов - спринг сканирует приложений на предмет таких аннотаций как @Component, @Service и т.д. и создает из них бины</br>
  при этом это считается неявным изменением контекста приложения</br></br>

### 2. Какая структура у Spring контейнера
- Можно представить в виде древовидной структуры
- Каждый узел представляет бин
- Родительский узел представлен контекстом

1. Класс "ApplicationContext" - это основной класс контекста Spring
   Содержит ссылки на все созданные бины
2. Класс "BeanDefinition" - это класс представляет метаданные о бине, такие как его класс зависимости, область видимости
   Содержит информацию для создания и настройки бина
3. Класс "BeanFactory" - это интерфейс, который определяет функциональность контейнера для создания, хранения и предоставлении бинов
Содержит методы для регистрации бинов и получения доступа к ним
4. Класс "DefaultListableBeanFactory" - Предоставляет реализацию интерфейса `BeanFactory` и предоставляет основную функицональность контейнера
Содержит структуры данных, такие как HashMaps для хранения и доступа к бинам
5. Класс "HierarchicalBeanFactory" - Интерфейс, который определяет иерархическую структуру контейнера, где контейнеры могут иметь родитеские контексты

### 3. Какая структура у Spring
1. Бины - Это объекты, которые управляются контейнером Spring
Бины создаются, настраиваются и внедряются в приложение. Представляют компоненты, такие как сервисы, репозитории, контроллеры
2. Конфигурационный метаданные (Configuration Metadata) - информация, необходимая для создания и настройки бинов
3. Контекст (Context) - среда, в которой бины создаются, настраиваются и связываются друг с другом
Обеспечивает доступ к бинам и контролирует их жизненные цикл</br>
Может быть иерархическим, то есть может иметь родительский контекст
4. Контроллеры (Controllers) - Компоненты, которые обрабатывают входящие запросы и возвращают соотвествующий ответ
5. Сервисы (Services) - Компоненты, которые содержат бизнес-логику
6. Репозитории (Repositories) - Предоставляют абстракцию для доступа к базе данных или другому источнику данных

### 4. Что такое автоконфигурация в контексте Spring
Это набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении.</br>
Можно сказать, что сам Embedded Servler Container - это тоже еще один бин</br></br>

- Включается аннотацией `@EnableAutoConfiguration`
- Работает в последнюю очередь, после регистрации пользовательских бинов
- Принимает решение о конфигурации на основании доступных в classpath классов, свойств в 'application.properties'
- Можно включать и выключать разные аспекты автоконфигурации
- Всегда отдает приоритет пользовательским бинам</br></br>

### 5. Условия создания бина
Логика при регистрации бинов управляется набором `@ConditionalOn*` аннотаций </br>
Можно указать, чтобы быин создавался при наличии в classpath (@ConditionalOnClass), </br>
наличии существующего бина (@ConditionalOnBean), отсутствии бина (@ConditionalOnMissingBean)

```
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

### 6. Что содержит аннотация `@SpringBootApplication`
 мета аннотация, алиас для нескольких аннотаций
- @SpringBootConfiguration
- @EnableAutoConfiguration
- @ComponentScan

### 7. Что делает метод `SpringApplication.run()`
это хелпер, который используя список предоставленных конфигураций создает 'ApplicationContext',</br>
конфигурирует его, выводит баннер в консоли и засекает время старта приложения</br>

### 8. Что такое `AnnotationConfigEmbeddedWebApplicationContext`
Наследник Spring Boot - знает о embedded servlet container-ах и умеет их запускать

### 9. За что отвечает аннотация `EnableAutoConfiguration`
включает автоконфигурацию
```
@Import(EnableAutoConfigurationImportSelector.class)
    public @interface EnableAutoConfiguration {
        ...
    }
}
```

`EnableAutoConfigurationImportSelector` - это конфигурация, которая добавит несколько бинов в контекст.</br>
Этот класс не объявляет бины сам, а использует так называемые фабрики.</br>
Класс смотрит в файл 'spring.factories' и загружает оттуда список значений, которые являются именами классов ((авто)конфигураций),</br>
которые Spring Boot импортирует</br></br>

### 10. Какие есть этапы инициализации
1. Парсирование конфигурациии создание 'BeanDefinition'
2. Настройка созданных 'BeanDefinition'
3. Создание кастомных `FactoryBean`
4. Создание экземпляров бинов
5. Настройка созданных бинов

### 11. Этап Парсирование конфигурациии создание 'BeanDefinition'
Задача данного этапа - это создание всех 'BeanDefinition'.</br>
'BeanDefinition' - это специальный интерфейсы, через который можно получить доступ к метаданным будущего бина

### 12. Этап Настройка созданных 'BeanDefinition'
После первого этапа у нас имеется Map, в котром хранятся 'BeanDefinition'</br>
Спринт дает нам возможность повлиять на то, какими будут наши бины еще до их создания,</br>
то есть мы можем получить доступ к метаданным класса.</br>
Для получения доступа к метаданным есть специальный интерфейс 'BeanFactoryPostProcessor'</br>
```
public interface BeanFactoryPostProcessor {
`void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
```

### 13. Что содержит фабрика `BeanFactoryPostProcessor`
фабрика содержит такие методы как 'getBeanDefinitionNames', через который можно получить все 'BeanDefinitionNames',</br>
а потом по конкретному имени получить 'BeanDefinition' для дальнейшей обработки метаданных</br></br>

Например, если в классе есть поля, которые должны быть заполнены из файла '.propeties' </br>
то после постпроцессинга они будут добавлены к класс бина</br></br>

### 14. Этап Создание кастомных `FactoryBean`
актуально если бины до сих пор создаются через xml и нужно создать ряд бинов, </br>
у которых не сильно отличаются настройки

### 15. Этап Создание экземпляров бинов
Созданием экземпляров бинов занимается 'BeanFactory' при этом можно дерегировать это кастомным 'FactoryBean'</br>
Экземпляры бинов создаются на основе ранее созданных 'BeanDefinition'</br>
После создания бина он добавляется в Map<BeanName, Bean></br></br>

### 16. Этап Настройка созданных бинов
Интерфейс 'BeanPostProcessor' позволяет вклиниться в процесс настройки бинов, до того как они попадут в контейнер
```
public interface BeanPostProcessor {
  Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // до init метода
  Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; // после init метода
}
```

* Если нужно сделать прокси над объектом, то лучше это делать в `postProcessAfterInitialization`
* `BeanPostProcessor` обязательно должен быть бином

### 17. Как создаются контекст и бины? Опишите флоу создания спринг приложения
- Application -> StartingEvent
  Когда мы пишем `SpringApplication.run`
    - Находит всех слушателей и кидает событие, что приложение начало строиться
- Application -> EnvironmentPreparedEvent, EnvironmentPostProcessor's
    - Слушателели находят `EnvironmentPostProcessor` и дают им настроить environment
- Application -> PreparedEvent, Application ContextInitializer's
    - В этот момент environment уже настроен и начинает строиться контекст
    - В этот же момент всем `ApplicationInitializer` получают возможность с данным контекстом что-то сделать
- Context -> RefreshEvent
    - Контекст настроен и начинают работать `BeanFactoryPostProcessor`, `BeanPostProcessor`
- EmbeddedServler -> Container InitializedEvent
- Application -> ReadyEvent

### 18. Жизненный цикл бина
1. Контекст приложения создает экземпляр бина
2. Если у бина есть зависимости на другие бины, контекст приложения рекурсивно создает их
3. Зависимости бинов внедряются
4. Если бин реализует интерфейс `InitializingBean`, он вызывает метод `afterPropertiesSet()`, который может быть использован для настройки бина
5. Если бин определен с аннотацией `@PostConstruct`, метод, помеченный этой аннотацией, вызывается для инициализации бина
6. Бин готов для использования в приложении
7. Когда контекст приложения завершает работу, он вызывает методы `destroy()` для бинов реализующих интерфейс `DisposableBean`
8. Если бин определен с использованием аннотации `@PreDestroy`, метод, помеченный аннотацией, вызывается пперд уничтожением бина

### 19. Жизненный цикл spring
1. **Загрузка контекста** - контейнер IoC загружает и инициализирует контекст приложения
Происходит считывание и обработка конфигурационных файлов приложения
2. **Создание бинов** - Контейнер IoC создает экземпляры бинов. Используется рефлексия и механизм инъекции зависимостей
3. **Внедрение зависимочтей** - Контейнер IoC внедряет зависимости бинов на основе их конфигурции. 
Может быть выполнение через конструктор, сеттеры или аннотации
4. **Инициализация бинов** - Если у бина есть методы инициализации (например помеченные `@PostConstruct`) они вызываются для подготовик бина к использованию
5. **Работа с приложением**
6. **Уничтожение приложения** - Контейнер IoC вызывает методы уничтожения бинов (например помеченные `@PreDestroy`)

### 20. Какой тип наследования используется при расширении бина
- JDK Dynamic Proxies (динамические прокси JDK)
- CGLIB (Code Generation Library)</br>

- JDK Dynamic Proxies - для интерфейсных бинов Spring создает динамические прокси. 
  - Работает путем создания объекта, который реализует тот же интерфейс, что и бин, и оборачивает вызовы методов вокруг оригинального объекта
- CGLIB - выполняет байтовую кодогенерацию и создает подклассы оригинального класса, котолрые оборачивают вызовы методов
  - Позволяет создавать прокси-объекты для публичиных и для защищенных/приватных методов класса</br>

Spring сам выбирает какой способ использовать
- Если класс имплементирует интерфейс, используется JDK Dynamic Proxies
- Если класс не импелемнтирует интерфейс или задан флаг `proxy-target-class` в настройках Spring, используется CGLIB

### 21. Типы расширения бинов
- `BeanPostProcessor` - позволяет вмешиваться в процесс создания бинов до и после и инициализации.
  - `postProcessBeforeInitialization` - перед иницализацией
  - `postProcessAfterInitialization` - после иницализации
- `BeanFactoryPostProcessor` - позволяет изменить метаданные бинов перед созданием их фабрикой (BeadnFactory)
  - `postProcessBeanFactory` - определяет метод, которые принимает BeanFactory в качестве аргумента
- `FactoryBean` - позволяет создавать бины, которые могут быть созданы специальной фабрикой, вместо непосредственного создания экземпляра бина
  - `getObject` - должен вернуть созданный бин
- `BeanDefinitionRegistryPostProcessor` - позволяет изменить конфигурации бинов всего приложения.
  - Работает аналогично `BeanFactoryPostProcessor`, но позволяет добавить, изменить или удалять дополнительные `BeanDefinitions` до и после фактории бинов
- `ApplicationListener` - позволяет реагировать на события, происходящие в контексте, например, события запуска и остановки контекста
- `InitializingBean` и `DisposableBean` - позволяют определить пользовательскую логику иницализации и уничтожения бинов
  - `InitializingBean.afterPropertiesSet` - выполяется после установки свойств бина
  - `DisposableBean.destroy` - выполняется перед уничтожением бина

## END ----------------- Spring изнутри -----------------

## Spring

+ [1. Что такое Autowiring и как работает](#1-что-такое-autowiring-и-как-работает)
+ [2. Плюсы и минусы @Autowired](#2-плюсы-и-минусы-autowired)
+ [3. В чём разница между @Component, @Service и @Repository аннотациями?](#3-в-чём-разница-между-component-service-и-repository-аннотациями)
+ [4. AOP](#4-aop)
+ [5. Spring boot](#5-spring-boot)
+ [6. RestTemplate](#6-resttemplate)
+ [7. Как активировать/деактивировать Бин](#7-как-активироватьдеактивировать-бин)
+ [8. Spring Filters](#8-spring-filters)
+ [9. @PreDestroy что это такое и зачем он нужен](#9-predestroy-что-это-такое-и-зачем-он-нужен)
+ [10. Кто уничтожает бин со Scope prototype](#10-кто-уничтожает-бин-со-scope-prototype)
+ [11. Аннотация @Cachable](#11-аннотация-cachable)
+ [12. Аннотация @Async](#12-аннотация-async-)
+ [13. Типы Repository](#13-типы-repository)
+ [14. Модули spring Session](#14-модули-spring-session)
+ [15. Какой аннотацией включается сессия](#15-какой-аннотацией-включается-сессия)
+ [16. Пример своего `WebSecurityConfig`](#16-пример-своего-websecurityconfig)
+ [17. Как заинджектить несколько бинов по одному интерфейсу](#17-как-заинджектить-несколько-бинов-по-одному-интерфейсу)
+ [18. @Primary](#18-primary)
+ [19. @Qualifier](#19-qualifier)

### 1. Что такое `Autowiring` и как работает
**IOC** - Inversion of control</br>
делегирование части обязанностей внешнему компоненту</br>
Управление отдается на сторону, но мы получаем возможность гибко конфигурировать и подменять модули</br></br>

Бин - создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект</br></br>

ApplicationContext - Это сердце спринга. Как правило, он создается в самом начале работы приложения</br></br>

По умолчанию каждый бин имеет внутриспринговое свойство 'scope' в значении 'singleton',</br>
то есть создается ровно один экземпляр класса
```
Определение бина
ИЛИ В файле xml
<bean id="product" class="main.java.Product"></bean>
// Указание места сканирования
<context:component-scan base-package="main"/>
// Поднять контекст из файл xml
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```
Как работает</br>
При поднятии контекста создается бин-объект всех объектов, которые помечены аннотациями `@Component`, `@Service`, `@Controller`, `@Repository`</br>
Когда спринг видит аннотацию @Autowired он начинает искать подходящий бин. Если бин только один, то он без проблем его инжектит</br></br>

Аннотация `@Autowired` можно ставить
- На поле
- На сеттеры
- На определенные методы</br></br>

Если оддинаковых бинов несколько
- Для определения конкретного бина необходимо использовать аннотацию '@Qualifier("dependency1") ServiceDependency'
- Для использования всех бинов
```
@Autowired
public void setDependency(ServiceDependency[] dependencies)
```

### 2. Плюсы и минусы `@Autowired`

| +  | -   | 
|-----|-----|
|  Требует меньше кода  | Менее экспрессивный, чем явное инжектирование |
|  Уменьшает время разработки | Усложняет автонаписание инструкций |
|    | Множетвенные инъекции могут пересекаться с названием конкруктора|

**Ограничения**
- Явные зависимости и аргументы конструктора и свойства всегда переписывают инъекции
- Инъекции через констркутор всегда переписывают инекции свойств
- Нельзя переписать примитивы
- Сложно ориентироваться при большом количестве инъекций

### 3. В чём разница между @Component, @Service и @Repository аннотациями?
**@Component** - универсальный компонент</br></br>

**@Repository** - компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.class</br>
умеет перехватывать спецефичные для платфомы исключения и повторно генерирует их как одно из унифицированных непроверенных исключений Spring</br>
Бин проксируется и ему добавляются exception handlers</br></br>

**@Service** - фасад для некоторой бизнес логики</br></br>

**@Controller** - класс, в котором указываются контроллеры приложения</br>
Для получения объекта body внутри методов необходимо дополнительно использовать аннотацию @RequestBody</br>
Используется для возврата view
```
@Controller
@RequestMapping("books")
public class SimpleBookController {

    @GetMapping("/{id}", produces = "application/json")
    public @ResponseBody Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```

**@RestController** - Это специализированная сервис контроллера. Включает в себя @Controller и @ResponseBody аннотации</br>
Необходим при написании REST запросов
```
@RestController
@RequestMapping("books-rest")
public class SimpleBookRestController {
    
    @GetMapping("/{id}", produces = "application/json")
    public Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```

**@Configuration** - класс для настройки приложения, объявления бинов

### 4. AOP
Аспектно-ориентированное программирование - это парадигма программирования, являющейся в дальнейшем развитием процедурно и объектно-ориентированного программирования</br></br>

**Join Point** - это точки наблюдения, присоединения к коду, где планируется введение функциональности

```
@Pointcut("execution(* com.example.spring._10.AOP_order.dao.*.*(..)))")
public void forDaoPackage () {}
```
**Pointcut** - Это срез, запрос точек присоединения</br></br>

**Advice**  - набор инстракций выполняемых на точках среза (может быть несколько для одного Pointcut)
- Before - Перед вызовом метода
- After - После вызовом метода
- After returning - После возврата значения
- After throwing - В случае exception
- After finally - В случае выполения блока finally
- Around - можно сделать пред, пост обработку перед вызовом метода, а также вообще обойти вызов метода

**Aspect**</br>
модуль, в котором собраны описанные Pointcut и Advice

### 5. Spring boot
В базе используется сервер Tomcat</br></br>

Без Spring Boot
- Импортировать необходимые Spring-модули
- Импортировать библиотеку web-контейнеров (в случае web-приложения)
- Импортировать сторонние библиотеки (Hibernate, Jackson)
- Искать версии, совместимые со Spring
- Конфигурировать компонент DAO, такие как источник данных, управление транзакциями ит т.д.
- Конфигурировать компоненты web-слоя, такие как диспетчер ресурсов, view resolver
- Определить класс, который щагрузит все необходимые конфигурации</br></br>

  Основные особенности
    1. Управленияе зависимостями
    2. Автоматическая конфигурация
    3. Встроенные контейнеры сервлетов
    4. Создание архива, который можно запускать

- Spring упаковывает необходимые сторонние зависимости для каждого типа приложения посредством starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa)
- Spring автоматически конфигурирует зарегистрированные бины в зависимости от подключенного стартера
- Каждое Spring-boot приложение включает встроенные web-сервлеты
  Spring ам настроивает контейнер сервлетов.
  Приложение может запускаться как jar-файл</br></br>

Основной класс приложения

**@SpringBootApplication** - включает в себя
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan

### 6. RestTemplate
```
@Bean
public RestTemplate restTemplate (RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofMills(3000))
        .setReadTimeout(Duration.ofMills(3000))
        .build();
}

@Bean
public RestTemplate restTemplate () {
    RestTemplate restTemplate = new RestTemplate();
    return restTemplate;
}
```

### 7. Как активировать/деактивировать Бин
@Profile("dev")</br>
@Profile("production")</br></br>

Добавляет возможность включать/выключать бины для разных окружений</br></br>

В файлу 'application.properties'</br>
spring.profiles.active=dev</br></br>

Дополнительно в интерфейсе 'ConfigurableEnvironment' можно установить настройки активных профилей вызвав 'SpringApplication.setAdditionalProdiles(...)'

### 8. Spring Filters

Для создания фильтры необходимо создать бин и заинжектить интерфейс 'Filter'
```
@Component
@Order(1)
public class TransactionFilter implements Filter {
    @Override
    public void doFilter (
        ServlerRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOExeprion, ServlerException {
        HTTPServlerRequest req = (HTTPServlerRequest) request;
        
        LOG.info("Staring a transaction for req: {}");
        
        req.getRequestURI();
        
        chain.doFilter(request, response);
        
        LOG.info("Commiting a transaction for req: {}");
        
        req.fetRequestURI();
    }
}
```
Мы можем извлечь

`url = req.getRequestURI();`

`method = req.getMethod();`

`contentType = res.getContentType();`

Регистрация бина
```
@Bean
public FilterRegistrationBean<RequestResponseLoggingFilter> loggingFilter () {
FilterRegistrationBean<RequestResponseLoggingFilter> registrationBean = new FilterRegistrationBean<>();

    registrationBean.setFilter(new RequestResponseLoggingFilter());
    registrationBean.addUrlPattern("users");
    registrationBean.setOrder(2);

    return registrationBean;
}
```

### 9. @PreDestroy что это такое и зачем он нужен
Если мы указывем аннотацию @PreDestroy над методом, то этот метод будет вызван при закрытии контекста

### 10. Кто уничтожает бин со Scope prototype
Он уничтожается garbage collector после того как все ссылки на него будут уничтожены</br>
В некоторых случаях советую явно уничтожать подобные бины</br>
Для этго можно написать пост процессор, методы которого будут явно уничтожать компоненты прототипа

### 11. Аннотация `@Cachable`
https://habr.com/ru/companies/rosbank/articles/694768/ </br>
Если мы хотим закешировать методы, мы ставим данную аннотацию, которая создать мапу с закешированными значениями
```
@Cacheable(cacheNames = {"signature"},  key = "{#userId}")
public Set<SignatureLevel> getSignatureLevels(long userId) {
      //логика
}
```

### 12. Аннотация `@Async`
Позволяет запускать методы в фоновом потоке </br>
- Для активации необходимо добавить аннотацию `@EnableAsync` над основным классом приложения
```
@Configuration
@EnableAsync
public class AsyncConfiguration extends AsyncConfigurerSupport {
//…. 
}
```
- Аннотация применяется только на публичных методах
- Нельзя вызывать метод из того же класса, к которому он принадлежит
- Если метод должен что-то возвращать, то возвращаемый тип должен быть `CompletableFuture`

### 13. Типы Repository
- `CrudRepository` - базовый интерфейс репозитория. Предоставляет методы для создания, чтения, обновления и удаление объектов
- `PagingAndSortingRepository` - Расширяет `CrudRepository` и добавляет методы для поддержки постраничного и сортированного доступа к данным
- `JpaRepository` - предоставляет дополнительную функциональность для работы с сущностями JPA(Java Persistence API)</br>
  Включает методы для поиска объектов по клитериям, обновления группы объектов и более удобного использования отношений между сущностями
- `JpaSpecificationExecutor` - добавляет возможность выполнять запросы с использовнием спецификаций. Дает возможность создать критерии поиска с использованием логических операторов
- `ReactiveCrudRepository` - Предоставляет асинхронную поддержку для чтения, записи и удаления оьбъектов

### 14. Модули spring Session 
Сессия спринга состоит из следующих модулей
- Spring Session core - Предоставляет основные API и функции для работы
- Spring Session Data Redis - предоставляет `SessionRepository` и `ReactiveSessionRepository` для Redis
- Spring Session JDBC - предоставляет реализации для реалиционных бд
- Spring Session Hazelcast - предоставляет реализации для Hazelcast
- Spring Session MongoDB - предоставляет реализации для MongoDB

### 15. Какой аннотацией включается сессия
`@EnableJdbcHttpSession`

### 16. Пример своего `WebSecurityConfig`
```
@EnableWebSecurity
@EnableJdbcHttpSession
@RequiredArgsConstructor
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    private final UserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationFailureHandler securityErrorHandler;
    private final ConcurrentSessionStrategy concurrentSessionStrategy;
    private final SessionRegistry sessionRegistry;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .cors().and()
                //для защиты о csrf атак
                .csrf().and()
                .httpBasic().and()
                .authorizeRequests()
                .anyRequest()
                .authenticated().and()
                //Логаут
                .logout()
                .logoutRequestMatcher(new AntPathRequestMatcher("/api/logout"))
                //Возвращаем при логауте 200(по умолчанию возвращается 203)
                .logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler(HttpStatus.OK))
                //Инвалидируем сессию при логауте
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                //Удаляем всю информацию с фронта при логауте(т.е. чистим куки, хидеры и т.д.)
                .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(Directive.ALL)))
                .permitAll().and()
                //Включаем менеджер сессий(для контроля количества сессий)
                .sessionManagement()
                //Указываем макимальное возможное количество сессий(тут указано не 1, т.к. мы будем пользоваться своей кастомной стратегией)
                .maximumSessions(3)
                //При превышение количества активных сессий(3) выбрасывается исключение  SessionAuthenticationException
                .maxSessionsPreventsLogin(true)
                //Указываем как будут регестрироваться наши сессии(тогда во всем приложение будем использовать именно этот бин)
                .sessionRegistry(sessionRegistry).and()
                //Добавляем нашу кастомную стратегию для проверки кличества сессий
                .sessionAuthenticationStrategy(concurrentSessionStrategy)
                //Добавляем перехватчик для исключений
                .sessionAuthenticationFailureHandler(securityErrorHandler);
    }

    //для инвалидации сессий при логауте
    @Bean
    public static ServletListenerRegistrationBean httpSessionEventPublisher() {
        return new ServletListenerRegistrationBean(new HttpSessionEventPublisher());
    }

    @Bean
    public static SessionRegistry sessionRegistry(JdbcIndexedSessionRepository sessionRepository) {
        return new SpringSessionBackedSessionRegistry(sessionRepository);
    }

    @Bean
    public static PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

}
```

### 17. Как заинджектить несколько бинов по одному интерфейсу
1. Создать несколько бинов имплементирующий один интерфейс
2. Заинджектить бин по интерфейсу
```
@Autowired
private List<Test> testList;
```

### 18. @Primary
- Используется в случае если мы хотим использовать бин, который был унаследован от ранее созданного бина
```
@Component
public class ParentBean {
  // properties and methods
}

@Component
@Primary
public class ChildBean extends ParentBean {
  // overridden properties and methods
}
```

### 19. @Qualifier
- Используется для конкретизации какую конкретно реализацию интерфейса следует использовать

## END ----------------- Spring -----------------

## Spring Кеш

+ [1. Как активировать кеширование в Spring](#1-как-активировать-кеширование-в-spring)
+ [2. Как отметить данные, которые будут кешироваться](#2-как-отметить-данные-которые-будут-кешироваться)
+ [3. Как обновить данные в кеше?](#3-как-обновить-данные-в-кеше)
+ [4. Какую структуру по умолчанию Spring использует для кеша](#4-какую-структуру-по-умолчанию-spring-использует-для-кеша)

### 1. Как активировать кеширование в Spring
Для активации кеширование достаточно добавить аннотацию `@EnableCaching`
```
@SpringBootApplication
@EnableCaching
public class DemoCacheAbleApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoCacheAbleApplication.class, args);
	}
}
```

### 2. Как отметить данные, которые будут кешироваться
Добавить аннотацию `@Cacheable`
```
@Cacheable(cacheNames="person")
public Person findCacheByName(String name) {
  //...
}
```
```
@Component
public class PersonRepository {

    private static final Logger logger = LoggerFactory.getLogger(PersonRepository.class);
    private List<Person> persons  = new ArrayList<>();

    public void initPersons(List<Person> persons) {
       this.persons.addAll(persons);
    }

    private Person findByName(String name) {
        Person person = persons.stream()
                .filter(p -> p.getName().equals(name))
                .findFirst()
                .orElse(null);
        return person;
    }

    @Cacheable(cacheNames="person")
    public Person findCacheByName(String name) {
        logger.info("find person ... " + name);
        final Person person = findByName(name);
        return person;
    }
}
```
Можно обозначить `key` - имя параметра, какой использовать в качестве ключа
```
@Cacheable(cacheNames="person", key="#name")
public Person findByKeyField(String name, Integer age) {
```

### 3. Как обновить данные в кеше?
1. Использовать аннотацию `@CachePut`</br>
Фунция с этой аннотацией будет всегда вызываться код, а результат помещать в кеш
```
@CachePut(cacheNames="person")
public Person findByNameAndPut(String name) {
    logger.info("findByName and put person ... " + name);
    final Person person = findByName(name);
    logger.info("put in cache person " + person);
    return person;
}
```

2. Использовать аннотацию `@CacheEvict`</br>
Позволяет не просто посещать хранилище кеша, но и выселять. Полезно для удаления устаревших и неиспользуемых данных из кеша</br>
```
@SpringBootApplication
@EnableCaching
public class DemoCacheAbleApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoCacheAbleApplication.class, args);
	}

	@Bean
	public CacheManager cacheManager() {
		SimpleCacheManager cacheManager = new SimpleCacheManager();
		cacheManager.setCaches(Arrays.asList(
				new ConcurrentMapCache("person"),
				new ConcurrentMapCache("addresses")));
		return cacheManager;
	}
}
```

### 4. Какую структуру по умолчанию Spring использует для кеша
ConcurrentMapCache

## END ----------------- Spring Кеш -----------------

## Spring Transactional

+ [1. Как включить транзакции](#1-как-включить-транзакции)
+ [2. Какие настройки может иметь аннотация `@EnableTransactionManager`](#2-какие-настройки-может-иметь-аннотация-enabletransactionmanager)
+ [3. Что делает аннотация `@Transactional`](#3-что-делает-аннотация-transactional)
+ [4. Какие настройки есть у `@Transactional`](#4-какие-настройки-есть-у-transactional)
+ [5. Как создавать транзакцию без Spring](#5-как-создавать-транзакцию-без-spring)
+ [6. Как `TransactionInterceptor` обрабатывает транзакционный метод](#6-как-transactioninterceptor-обрабатывает-транзакционный-метод)
+ [7. Что такое `TransactionManager`](#7-что-такое-transactionmanager)

### 1. Как включить транзакции
Добавить над конфигурацией аннотацию `@EnableTransactionManager`

### 2. Какие настройки может иметь аннотация `@EnableTransactionManager`
- `proxyTargetClass` - (по умолчанию false) - будет ли прокси создаваться через CGLIB(true) или через interface-based proxies (false)
- `mode` - (по умолчанию `AdviceMode.PROXY`)  -как будут применены ADVICE
  - `AdviceMode.PROXY` или
  - `AdviceMode.ASPECTJ` - если выбрать и настроить, то при компиляции будет сгенерирован код так, что лело метода будет уже обернуто кодом, управляющим транзакцией
- `order` - (по умолчанию `LOWEST_PRECEDENCE`) когда будет применен advice, по умолчанию последним в цепочке

### 3. Что делает аннотация `@Transactional`
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(TransactionManagementConfigurationSelector.class)
public @interface EnableTransactionManagement {...}
```

### 4. Какие настройки есть у `@Transactional`
- `propagation` - способ распространения транзакций
  - `MANDATORY` - если есть текущая активная транзакция, выполняется в ней, иначе выбрасывается исключение
  - `NESTED` - выполняется внутри вложенной транзакции, если есть активная, если нет - то аналогично `REQUIRED`
  - `NEVER` - выполняется вне транзакции, если есть активная - выбрасывается исключение
  - `NOT_SUPPORTED` - выполняется вне транзакции - если есть активная, она приостанавливается
  - `REQUIRED` - (по умолчанию) если есть активная, то выполняется в ней, если нет, то создается новая
  - `REQUIRES_NEW` - всегда создается новая транзакция, если есть активная - то она приостанавливается
  - `SUPPORTS` - если есть активная, то выполняется в ней, есои нет - то выполняется не транзакционно
- Правила управления откатом
  - `noRollbackFor` `noRollbackForClassName` - определяет исключения при которых транзакция НЕ будет откатана
  - `rollbackFor` `rollbackForClassName` - определяет исключения при которых транзакция БУДЕТ откатана

### 5. Как создавать транзакцию без Spring
1. Создаем соединение  - DriverManager.getConnection(...)
2. Выполняем запросы
3. Если нет ошибок, то выполняется commit
4. Если были ошибки - изменения откатываются 
```
Connection connection = DriverManager.getConnection(...);
try {
  connection.setAutoCommit(false);
  PreparedStatement firstStatement = connection.prepareStatement(...);

  firstStatement.executeUpdate();

  PreparedStatement secondStatement = connection.prepareStatement(...);

  secondStatement.executeUpdate();
  connection.commit();
} catch (Exception e) {
  connection.rollback();
}
```

### 6. Как `TransactionInterceptor` обрабатывает транзакционный метод
1. Получаем соединение/транзакцию - createTransactionIfNecessary
2. Выполняем необходимые запросы - invocation.proceedWithInvocation
3. Если не было ошибок - выполяем commitTransactionAfterReturning
4. Если были ошибки - откатываем изменения completeTransactionAfterThrowing
```
protected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)

  // получаем TransactionManager tm и TransactionAttribute txAttr
  // ...

  if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) {
    //код для работы с реактивным стэком
    // ...
  }

PlatformTransactionManager ptm = asPlatformTransactionManager(tm);
final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) {
  // начинаем транзакцию, если нужно
  TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);

  Object retVal;
  try {
    // выполняем работу внутри транзакции
    retVal = invocation.proceedWithInvocation();
  } catch (Throwable ex) {
    // откатываемся, если нужно
    completeTransactionAfterThrowing(txInfo, ex);
    throw ex;
  } finally {
    // чистим ThreadLocal переменные
    cleanupTransactionInfo(txInfo);
  }

  if (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {
    //код для библиотеки vavr
    // ...
  }

  // выполняем commit, если не было ошибок
  commitTransactionAfterReturning(txInfo);
  return retVal;
} else {
  // код для WebSphere
  // ...
}
}
```

### 7. Что такое `TransactionManager`
- Это маркировачный интерфейс, не содержащий никаких методов
    - Его наследуют `ReactiveTransactionManager` и `PlatformTransactionManager`

## END ----------------- Spring Transactional -----------------

## Hibernate & JPA

+ [1. Что такое Hibernate](#1-что-такое-hibernate)
+ [2. Проблема n+1 в Hibernate](#2-проблема-n1-в-hibernate)
+ [3. Как решить проблему n+1](#3-как-решить-проблему-n1)
+ [4. Плюсы и минусы](#4-плюсы-и-минусы)
+ [5. Hibernate ленивая инициализация (LazyInitialization)](#5-hibernate-ленивая-инициализация-lazyinitialization)
+ [6. Как реализовать пользовательский интерфейс repository](#6-как-реализовать-пользовательский-базовый-repository)
+ [7. Как добавить пользовательскую реализацию репозитория](#7-как-добавить-пользовательскую-реализацию-репозитория)
+ [8. Изменить поведение уже существующего метода](#8-изменить-поведение-уже-существующего-метода)
+ [9. Как использовать `Query` в запросах](#9-как-использовать-query-в-запросах)
+ [10. Что представляет собой EntityManager](#10-что-представляет-собой-entitymanager)
+ [11. В чем отличие merge от persist](#11-в-чем-отличие-merge-от-persist)
+ [12. Что такое Persistence Context](#12-что-такое-persistence-context)
+ [13. Как реализовать оптимистическую блокировку](#13-как-реализовать-оптимистическую-блокировку)
+ [14. Как реализовать пессимистическую блокировку](#14-как-реализовать-пессимистическую-блокировку)
+ [15. В чем преимущество испльзования JPQL синтаксиса](#14-как-реализовать-пессимистическую-блокировку)
+ [16. Уровни кешей](#16-уровни-кешей)
+ [17. Реализация составного ключа](#17-реализация-составного-ключа)

### 1. Что такое Hibernate
ORM - Object-relational mapping - это отображение объектов какого-либо объектно-ориентированного языка в структуры реляционных баз данных

Hibernate - заботится о связи Java классов с таблицами бд, а также предоставляет средства для автоматического построения запросов и извлечения данных

Внутри используется собственный язык запросов Query Language или HQL

### 2. Проблема n+1 в Hibernate
-Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.</br>
-При использовании `FetchType.EAGER` все данные не будут загружены в одном запросе, а бадут загружаться отдельными запросами на каждую сущность
```
SELECT
    pc.id AS id1_1_,
    pc.post_id AS post_id3_1_,
    pc.review AS review2_1_
FROM
    post_comment pc
 
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4
```
- При работе с кешом второго уровня
```
List<PostComment> comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    order by pc.post.id desc
    """, PostComment.class)
.setMaxResults(10)
.setHint(QueryHints.HINT_CACHEABLE, true)
.getResultList();
```
Если PostComment не находится в кэше второго уровня, то будет выполнено N запросов для получения каждого отдельного PostComment:
```
SELECT pc.id AS id1_1_0_,
       pc.post_id AS post_id3_1_0_,
       pc.review AS review2_1_0_
FROM post_comment pc
WHERE pc.id = 3
  
SELECT pc.id AS id1_1_0_,
       pc.post_id AS post_id3_1_0_,
       pc.review AS review2_1_0_
FROM post_comment pc
WHERE pc.id = 2
  
SELECT pc.id AS id1_1_0_,
       pc.post_id AS post_id3_1_0_,
       pc.review AS review2_1_0_
FROM post_comment pc
WHERE pc.id = 1
```

### 3. Как решить проблему n+1
1. Использовать `FetchType.LAZY` - по сути откладывает проблему до момента обращения к lazy
2. Использовать `JOIN FETCH`
```
List<PostComment> comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    join fetch pc.post p
    """, PostComment.class)
.getResultList();
 
for(PostComment comment : comments) {
    LOGGER.info(
        "The Post '{}' got this review '{}'",
        comment.getPost().getTitle(),
        comment.getReview()
    );
}
```
```
SELECT
    pc.id as id1_1_0_,
    pc.post_id as post_id3_1_0_,
    pc.review as review2_1_0_,
    p.id as id1_0_1_,
    p.title as title2_0_1_
FROM
    post_comment pc
INNER JOIN
    post p ON pc.post_id = p.id
     
-- The Post 'High-Performance Java Persistence - Part 1' got this review
-- 'Excellent book to understand Java Persistence'
 
-- The Post 'High-Performance Java Persistence - Part 2' got this review
-- 'Must-read for Java developers'
 
-- The Post 'High-Performance Java Persistence - Part 3' got this review
-- 'Five Stars'
 
-- The Post 'High-Performance Java Persistence - Part 4' got this review
-- 'A great reference book'
```

### 4. Плюсы и минусы
(+)
1. Превращает sql запросы в объекты java 
2. Маппит результат sql запроса в класс

(-)
1. Не подходит при работе с большим количеством данных, так как на каждую сущность создает объект
2. Есть проблемы n+1

### 5. Hibernate ленивая инициализация (LazyInitialization)
@OneToMany(fetch=FetchType.Lazy)

Для акцивации такой связи необходимо проверить било ли инициализировано</br>
boolean success = Hibernate.isInitialized(products);</br></br>

Инициализировать</br>
Hibernate.initialize(post);

### 6. Как реализовать пользовательский базовый repository
- Создать свой интерфейс, который будет экстендиться от CrudRepo
```
@NoRepositoryBean
public interface BaseRepository <T extends BaseEntity, ID extends Serializable>
        extends JpaRepository<T, ID> {

    void delete(T entity);
}
```
- Реализовать интерфейс
```
//Базовый пользовательский класс имплементирующий BaseRepository
public class BaseRepositoryImpl <T extends BaseEntity, ID extends Serializable>
        extends SimpleJpaRepository<T, ID>
        implements BaseRepository<T, ID> {

    private final EntityManager entityManager;

    public BaseRepositoryImpl(JpaEntityInformation<T, ?> entityInformation,
                     EntityManager entityManager) {
        super(entityInformation, entityManager);
        this.entityManager = entityManager;
    }

    @Transactional
    @Override
    public void delete(BaseEntity entity) {
        entity.setDeleted(true);
        entityManager.persist(entity);
    }
}
```

### 7. Как добавить пользовательскую реализацию репозитория
- Объявляем интерфейс
```
public interface CustomizedEmployees<T> {

    List<T> getEmployeesMaxSalary();

}
```
- Имплементируем интерфейс
```
public class CustomizedEmployeesImpl implements CustomizedEmployees {

    @PersistenceContext
    private EntityManager em;

    @Override
    public List getEmployeesMaxSalary() {
        return em.createQuery("from Employees where salary = (select max(salary) from Employees )", Employees.class)
                .getResultList();
    }
}
```
- Расширяем репозиторий
```
@Repository
public interface CustomizedEmployeesCrudRepository extends CrudRepository<Employees, Long>, CustomizedEmployees<Employees> 
```

### 8. Изменить поведение уже существующего метода
```
public interface CustomizedEmployees<T> {

    void delete(T entity);
    // ...
}
// Имплементация CustomizedEmployees
public class CustomizedEmployeesImpl implements CustomizedEmployees {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    @Override
    public void delete(Object entity) {
        Employees employees = (Employees) entity;
        employees.setDeleted(true);
        em.persist(employees);
    }
}
```

### 9. Как использовать `Query` в запросах
- Используется если нужен специфичный метод или его реализация, которую нельзя описать через имя метода
```
@Repository
public interface CustomizedEmployeesCrudRepository extends CrudRepository<Employees, Long>, CustomizedEmployees<Employees> {

    @Query("select e from Employees e where e.salary > :salary")
    List<Employees> findEmployeesWithMoreThanSalary(@Param("salary") Long salary, Sort sort);
    // ...
}
```
** Если запросы должны лишь модифицируеющие, то можно использовать аннотацию `@Modifying`
```
@Modifying
@Query("update Employees e set e.firstName = ?1 where e.employeeId = ?2")
int setFirstnameFor(String firstName, String employeeId);
```

Пример: Получить список объектов с признаком "удален" или "активный"
```
@NoRepositoryBean
public interface ParentEntityRepository<T> extends Repository<T, Long> {

    @Query("select t from #{#entityName} t where t.deleted = ?1")
    List<T> findMarked(Boolean deleted);
}
```

### 10. Что представляет собой EntityManager
- Это интерфейс из Java Persistence API (JPA)
- Является основным объектом для работы с объектами сущностей в контексте управления сущностями
- Представляет собой набор методов для выполнения операций с сущностями, такими как создание, чтение, обновление и удаление
- Позволяет управлять жизненным циклом сущностей, отслеживать изменения и сохранять их в базе данных

### 11. В чем отличие merge от persist
- persist - используется для сохранения нового объекта в бд
Если объект уже есть в бд, то будет сгенерировано исключение</br>
Устанавливает идентификатор объекта после сохранени в бд</br>
Не возвращает измененное состояние объекта, после сохранения в бд</br>
Требует, чтобы объект находился в текущем сеансе
- merge - используется для обновления существующего объекта в бд
Если объект уже есть в бд, то его значения будут обновлены, иначе объект будет сохранен как новый</br>
Если объект уже существует, но не связан с текущим сеансом Hibernate, то его состояние будет сгенерировано в объект, связанный с текущим сеансом</br>
Возвращает копию объекта с обновленным состоянием

### 12. Что такое Persistence Context
Это механизм, который отслеживает состояние объектов, связанных с бд</br>
Предоставляет управление и кеширование объектов, в также обеспечивает обнаружение изменений и синхронизацию с бд

- Каждая сессия имеет свой собственный контекст сохранения, который представляет собой некоторое хранилище для объектов
- Когда вы загружаете или сохраняете объекты, Hibernate помещает их в контекст сохранения

Преимущества:</br>
- Обеспечивает кеширование объектов
- Отслеживает изменения в объектах и автоматически сихронизириует их с бд при необходимости
- Обеспечивает согласованность данных между объектами и бд, обеспечивая целостность данных в рамках транзакций
- Позволяет использовать отложенную загрузку (lazy loading)

### 13. Как реализовать оптимистическую блокировку
1. Использовать `@Version`
- Версия мапится в колонку OPTLOCK
- менеджер сущностей использует ее для выявления конфликтующих обновлений и предотвращения потери обновлений
```
@Entity
public class Flight implements Serializable {
...
@Version
@Column(name="OPTLOCK")
public Integer getVersion() { ... }
}
```
- Возможные параметры

| Имя                                    | Описание                                                                                               |
|----------------------------------------|--------------------------------------------------------------------------------------------------------|
| column<version_column>                 | Имя колонки, в которой находится номер версии (опционально)                                            |
| name<propertyName>                     | Имя свойства персистентного класса                                                                     |
| type<typename>                         | Тип номера версии (опционально - default: integer)                                                     |
| access<field/property/ClassName>       | Стратегия Hibernate для доступа к значению свойства (опционально - default: property)                  |
| unsaved-value<null/negative/undefined> | Показывает, что экземпляр только что создан и тем самым не сохранен (опционально - default: undefined) |
| generated<never/always>                | Показывает, что свойство версии должно генерироваться базой данных (опционально - default: never)      |
| insert                                 | Включать или нет колонку версии в выражение SQL-insert (опционально - default: true)                   |

Версия в hbm.xml
```
<version
        column="version_column"
        name="propertyName"
        type="typename"
        access="field|property|ClassName"
        unsaved-value="null|negative|undefined"
        generated="never|always"
        insert="true|false"
        node="element-name|@attribute-name|element/@attribute|."
        />
```
2. Использовать `@Timestamp`
```
@Entity
public class Flight implements Serializable {
...
@Version
public Date getLastUpdate() { ... }
}
```
- Возможные параметры

| Имя                                    | Описание                                                                                                                    |
|----------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| column<version_column>                 | Имя колонки, в которой находится номер версии (опционально)                                                                 |
| name<propertyName>                     | Имя JavaBeans-свойства типа Date или Timestamp у персистентного свойства                                                    |
| access<field/property/ClassName>       | Стратегия Hibernate для доступа к значению свойства (опционально - default: property)                                       |
| unsaved-value<null/negative/undefined> | Показывает, что экземпляр только что создан и тем самым не сохранен (опционально - default: undefined)                      |
| generated<never/always>                | Показывает, что свойство версии должно генерироваться базой данных (опционально - default: never)                           |
| source                                 | Извлекает ли Hibernate метку из БД или из текущей JVM. Метку нужно запрашивать из БД каждый раз для определения инкремента  |

Timestamp в hbm.xml
```
<timestamp
        column="timestamp_column"
        name="propertyName"
        access="field|property|ClassName"
        unsaved-value="null|undefined"
        source="vm|db"
        generated="never|always"
        node="element-name|@attribute-name|element/@attribute|."
        />
```

### 14. Как реализовать пессимистическую блокировку
- Класс `LockMode` для определения уровня блокировки
  - `LockMode.WRITE` - захватываются автоматичсеки, когда Hibernate обновляет или вставляет строку
  - `LockMode.UPGRADE` - захватывается после явного запроса пользователя с использованием `SELECT...FOR UPDATE`
  - `LockMode.UPGRADE_NOWAIT` - захватывается после явного запроса пользователя с испоьзованием `SELECT… FOR UPDATE NOWAIT` (oracle)
  - `LockMode.READ` - захватывается автоматически когда Hibernate читает данные под уровнями изоляции Repeatable Read или Serializable
  - `LockMode.NONE` - Все объекты переключается на этот режим в конце транзакции

### 15. В чем преимущество испльзования JPQL синтаксиса
- Запросы кешируются
- Универсальны при изменение драйвера базы данных (созданный запрос не нужно переписывать)

### 16. Уровни кешей
- Кеш первого уровня (First-level cache); (по умолчанию)
- Кеш второго уровня (Second-level cache);
- Кеш запросов (Query cache);

1. Кеш первого уровня привязан к объекту сессии
2. Кеш второго уровня привязан к объекту-фабрике сессий
3. Кеш запросов привязан к параметрам запросаRfr

### 17. Реализация составного ключа
```java
@Entity
@org.hibernate.annotations.Table(appliesTo = House.TABLE_NAME,
    indexes = {
            @Index(name = "IDX_XDN_DFN",
                    columnNames = {House.XDN, House.DFN}
            )
    }
)
@Table(name="house")
public class House {
    ...

  @Index(name = "index1")
  public String getFoo();
  @Index(name = "index1")
  public String getBar();
}
```

## END ----------------- Hibernate & JPA -----------------

## Kafka

+ [1. Основной принцип работы kafka](#1-основной-принцип-работы-kafka)
+ [2. Если у нас есть несколько инстансов одного микросервиса сообщений, как отправить только одно сообщение](#2-если-у-нас-есть-несколько-инстансов-одного-микросервиса-сообщений-как-отправить-только-одно-сообщение)
+ [3. Максимальный объем сообщения](#3-максимальный-объем-сообщения)
+ [4. Какие гарантии Kafka дает](#4-какие-гарантии-kafka-дает)
+ [5. Подходит ли Kafka для пересылки больших сообщений](#5-подходит-ли-kafka-для-пересылки-больших-сообщений)
+ [6. Что произойдет если Kafka отправит большое сообщение (Poison Message)](#6-что-произойдет-если-kafka-отправит-большое-сообщение-poison-message)
+ [7. Что означает Идемпотентность](#7-что-означает-идемпотентность)
+ [8. Как настроить отправку только одного сообщения (exactly one)](#8-как-настроить-отправку-только-одного-сообщения-exactly-one-)
+ [9. Из чего состоит](#9-из-чего-состоит)
+ [10. Жизненный цикл сообщений](#10-жизненный-цикл-сообщений)
+ [11. Как долго kafka хранит сообщения](#11-как-долго-kafka-хранит-сообщения)
+ [12. Какая структура сообещения Kafka](#12-какая-структура-сообещения-kafka)
+ [13. Как организованы и как хранятся сообщения](#13-как-организованы-и-как-хранятся-сообщения)
+ [14. Как организованы Партиции](#14-как-организованы-партиции)
+ [15. Что такое consumer group](#15-что-такое-consumer-group)
+ [16. Каким образом обозначить сообщения в партиции, как обработанные](#16-каким-образом-обозначить-сообщения-в-партиции-как-обработанные)

### 1. Основной принцип работы kafka
- Kafka использует pull (получатели сами достают из топика сообщения)</br>
  (+)
    - сами отправляют запрос раз в n секунд на сервер для получения новой порции сообщений</br>
    - Позволяет группировать сообщения в батчи, таким образом достигая лучшей пропускной способности
  
  (-)
    - Потенциальная разбалансированность нагрузки между разными консьюмерами, а также более высокую задержку обработки данных
  
- Другие сервисы используют push ратегию (отправляют сообщения получателям)
  - сервер делает запрос к клиенту, посылая ему новую порцию данных
  - Позволяет эффективно балансировать распределение сообщений по консьюмерам

### 2. Если у нас есть несколько инстансов одного микросервиса сообщений, как отправить только одно сообщение
- consumer group концепция
- Назначить consumer group id для инстансов, после чего кафка сама позаботится о разделении сообщения для разных инстансов
- Необходимо чтобы все инстансы одного микросервиса имели один и тот же group id

### 3. Максимальный объем сообщения
10 мб

### 4. Какие гарантии Kafka дает
Что сообщение будет доставлено как минимум одному получателю

### 5. Подходит ли Kafka для пересылки больших сообщений
Нет, Kafka заточена под пересылку большого количества сообщений небольшого размера</br>
Если необходимо отправить большой файл, то нужно его сохранить в какое-то хранилище и в сообщении передать ссылку на него

### 6. Что произойдет если Kafka отправит большое сообщение (Poison Message)
У получателя произойдет ошибка, которую скорее всего он не обрабатывает. Эта ошибка повлияет на последющие сообщения</br>
Для избежания таких ситуаций можно добавить кастомную обработку при получении сообщений

### 7. Что означает Идемпотентность
https://habr.com/ru/companies/badoo/articles/333046/ </br>
свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом (чистые функции)

### 8. Как настроить отправку только одного сообщения (exactly one)
```
enable.idempotence=true
```
Каждый пакет, отправленный Kafka, будет содержать порядковый номер, при помощи которого блокер сможет устранить дублирование данных

### 9. Из чего состоит
1. Сервер
2. Продюсеры, которые отправляют сообщения в некую именованную очередь, заранее сконфигурированную администратором на сервере
3. Консьюмеры, который считывают те же самые сообщения по мере их появления

### 10. Жизненный цикл сообщений
1. Продюсер отправляет сообщение на сервер
2. Консьюмер фетчит сообщение и его уникальный идентификатор сервера
3. Сервер помечает сообщение как in-flight. Сообщения в таком состоянии все еще хранятся на сервере, но временно не доставляются другим консьюмерам.</br>
Таймаут этого состояния контролируется специальной настройкой
4. Консьюмер обрабатывает сообщение, следуя бизнес-логике. Затем отправляет ack или nack-запрос обратно на сервер, используя уникальный идентификатор,</br>
полученный ранее - тем самым либо подтверждая успешную обработку сообщения, либо сигнализируя об ошибке
5. В случае успеха сообщение удаляется с сервера навсегда. В случае ошибки или таймаута состояния in-flight сообщение доставляется консьюмеру для повторной обработки

### 11. Как долго kafka хранит сообщения
- Сообщения в Kafka не удаляется брокерами по мере их обработки комнсьюмерами - данные в Kafka могут храниться днями, неделями, годами
- Одно и то же сообщение может быть обработано сколько угодно раз разными консьюмерами и в разных контекстах

### 12. Какая структура сообещения Kafka
- Каждое сообщение состоит из ключа, значения, таймстампа и опционального набора метаданных (хедеров)
```
{
 key: "Alice",
 Value: "Registered on out website",
 Timestamp: "Jun 25, 2023",
 Headers: [{"X-Generated-By": "web"}]
}
```

### 13. Как организованы и как хранятся сообщения
- Сообщения организованы и хранятся в именованных топиках (Topic)
- Каждый топик состояит из одной более партиций (Partition), распределенных между брокерами внутри одного кластера
- Когда новое сообщение добавляется в топик, оно записывается в одну из партиций этого топика
- Сообщения с одинаковыми ключами всегда записываются в одну и ту же партицию, тем самым гарантируя очередность или порядок записи и чтения

### 14. Как организованы Партиции
- У каждой партиции есть "лидер" - брокер, который работает с клиентами. Лидер работает с продюсерами и в общем случае отдает сообщения консьюмерам
- К лидеру осуществляют запросы фолловеры - брокеры, которые хранят реплику всех данных партиций
- партиция - это распределенный, реплицируемый лог

### 15. Что такое consumer group
- Каждый консьюмер обычно является частью какой-нибудь консьюмер-группы
- Каждый группа имеет уникальное название и регистрируется брокерами в кластере Kafka
- Данные из одного и того же топика могут считываться множеством консьюмер-групп одновременно
- Когда несколько консьюмеров читают данные и являются членами одной и той же группы, то каждый из них получает сообещния из разных партиций топика

* Внутри одной группы партиции назначаются консьюмерами уникально, чтобы избежать повторной обработки
* Если консьюмер не справляется с текущим объемом данных, то следует добавить новую партицию в топик

### 16. Каким образом обозначить сообщения в партиции, как обработанные
- Для этого используется механизм консьюмеров-офсетов
- Каждое сообщение партиции имеет свой собственный, уникальный, монотонно возрастающий офсет
- Консьюмер делает запрос к брокеру (offset-commit) с указанием своей группы, идентификатора топик-партиции и офсета, который должен быть отмечен как обработанный
  - Сдвигается относительно consumer-group, чтобы сообщения обрабатывались последовательно
- Брокер сохраняет эту информацию в собственном топике
- При рестарте консьюмер запрашивает у сервера последний закомиченный офсет для нужной топик-партиции и продолжает чтения с этой позиции

## END ----------------- Kafka -----------------

## Stream

+ [1. Стримы Общее](#1-стримы-общее)
+ [2. Collectors](#2-collectors)
+ [3. Функциональный интерфейсы](#3-функциональный-интерфейсы)
+ [4. Меняет ли начальные данные stream?](#4-меняет-ли-начальные-данные-stream)
+ [5. Почему стримы, в чем основная фишка](#5-почему-стримы-в-чем-основная-фишка)
+ [6. Как можно обработать исключение, выброшенное в ходе работы Stream](#6-как-можно-обработать-исключение-выброшенное-в-ходе-работы-stream)

### 1. Стримы Общее
1. Stream из массива</br>
   Arrays.stream(array)</br></br>

2. Stream из ArrayList</br>
   list.stream()</br></br>

3. Stream из Map</br>
   map.entrySet.stream()</br></br>

4. Stream из указанных элементов</br>
   Stream.of("1", "2", "3")</br></br>

5. Лист из указанных элементов</br>
   Arrays.asList("a1", "a2", "a3").stream()</br></br>

6. Стрим из файла</br>
   Files.lines(Paths.get("file.txt"))</br></br>

7. Стрим из строки</br>
   "123".chars()</br></br>

8. Создание из Stream.builder</br>
   Stream.builder().add("a1").add("a2").add("a3").build()</br></br>

9. Создание параллельного стрима</br>
   collection.parallelStream()</br></br>

10. Создание бесконечного стрима</br>
    Stream.iterate(1, n -> n +1)</br></br>

11. Создание бесконечных стримов с помощью</br>
    Stream.generate(() -> "a1"))</br></br>

   Методы
   1. Конвейерные - возвращают другой stream, то есть работают как builder
   2. Терминальные - Возвращают другой объект, такой как коллекция, примитивы, объекты, Optional</br></br>

        ! У стрима может быть сколько угодно вызовов конвейерных методов  и в конце один терминальный</br>
        При этом все конвеейрные методы выполняются лениво и пока не будет вызван терминальный, никаких действий не происходит</br>

```
Конвейерные методы
   'filter'
   collection.stream()
    .filter("a1"::equals)
    .count()

    'skip' - позволяет пропускать первые N элементов
    collection.stream()
        .skip(collection.size() - 1)
        .findFirst()
        .orElse("1")

    'distinct' - возвращает стрим без дубликатов
    collection.stream()
        .distinct()
        .collect(Collectors.toList())

    'map' - преобразует каждый элемент массива
    collection.stream()
        .map((s) -> s + "_1")
        .collect(Collectors.toList())

    'peek' - возвращает тот же стрим, но применяет функцию к каждому элементу
    collection.stream()
        .map(String::toUpperCase)
        .peek((e) -> System.out.println("," + e))
        .collect(Collectors.toList())

    'limit' - ограничивает выборку определенным количеством элементов
    collection.stream()
        .limit(2)
        .collect(Collectors.toList())

    'sorted' - позволяет сортировать значения либо в натуральном порядке либо задавая Comparable
    collection.stream()
        .sorted()
        .collect(Collectors.toList())

    'mapToInt' - аналог map, но возвращает числовой стрим
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .toArray()

    'mapToDouble'
    'mapToLong'

    'flatMap' - похоже на map, о может создавать из одного элемента несколько
    'flatMapToInt'
    'flatMapToDouble'
    'flatMapToLong'

    collection.stream()
        .flatMap((p) -> Arrays.asList(p.split(",").stream()))
        .toArray(String[]::new)

    'reduce' - позволяет выполнять агрегатные функции на всей коллекцией, возвращает одно значение для стрима (Optional)
    collection.stream()
    .reduce((s1, s2) -> s1 + s2)
    .orElse(0)
```
```
Терминальные методы

    'findFirst' - возвращает первый элемент из стрима (Возвращает Optional)
    collection.stream()
        .findFirst()
        .orElse("1")

    'findAny' - возвращает плюбой подходящий элемент из стрима (Возвращает Optional)
    collection.stream()
        .findAny()
        .orElse("1")

    'collect' - представление результатов в виду коллекций и других структур данных
    collection.stream()
        .filter((s) -> s.contains("1"))
        .collect(Collectors.toList())

    'anyMatch' - возвращает true если условие выполняется хотя бы для одного значения
    collection.stream()
        .anyMatch("a1"::equals)

    'count' - возвращает количество элементов в стриме
    collection.stream()
        .filter((s) -> s.contains("1"))
        .count()

    'noneMatch' - возвращает true если условие не выполняется ни для одного элемента
    collection.stream()
        .noneMatch((s) -> s.contains("1"))

    'allMatch' - возвращает true если условие выполняется для всех элементов
    collection.stream()
        .allMatch((s) -> s.contains("1"))

    'min' - возвращает минимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .min(String::compareTo)
        .get()

    'max' - возвращает максимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .max(String::compareTo)
        .get()

    'forEach' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
    set.stream()
        .forEach((p) -> p.append("_1"))

    'forEachOrdered' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении гарантируется
    list.stream()
        .forEachOrdered((p) -> p.append("_1"))

    'toArray' - возвращает массив значений стрима
    collection.stream()
        .map(String::toUpperCase)
        .toArray(String[]::new)
```
```
Дополнительные методы числовых стримов

    'sum' - Возвращает сумму чисел
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .sum()

    'average' - Возвращает среднее арифметическое
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .average()

    'mapToObj' - Преобразует числовой стрим обратно в объект
    Stream.mapToObj((id) -> new Key(id))
        .toArray()
```
```
Другие методы
   'isParallerl' - Узнать является ли стрим параллельным

    'parallel' - Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
    
    collection.stream()
        .peek(...) // операция последовательная
        .parallel()
        .map(...) // операция мождет выполняться параллельно
        .sequential()
        .reduce(...) // операция снова последовательна
```

### 2. Collectors
   Методы стататические

   `toList` - Представляет стрим в виде списка
   `toCollection` - Представляет стрим в виде коллекции
   `toSet` - Представляет стрим в виде множества</br></br>

   `toConcurrentMap` - Преобразовывает стрим в Map
   `toMap` - Преобразовывает стрим в Map</br></br>

   `averagingInt` - Среднее значение
   `averagingDouble`
   `averagingLong`</br></br>

   `summingInt` - Возвращает сумму
   `summingDouble`
   `summingLong`</br></br>

   `partitioningBy` - разделяет коллекцию на две части по соответствующему условию</br>
   и возвращает как Map<Boolean, List></br></br>

   `groupingBy` - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>></br></br>

   `mapping` - дополнительные преобразования значений для сложных Collector-ов</br></br>

```
strings.stream()
    .collect(Collectors.joining(" "), "<b>", "</b>")

string.stream()
    .collect(Collectors.groupingBy((p) -> p.substring(0, 1)))
```

### 3. Функциональный интерфейсы

`Predicate`(filter) - означает, что он будет пропускать только те элементы, которые возвращают true
```
public static void main(String[] args) {
    List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
        .filter(x -> x % 2==0)
        .collect(Collectors.toList());
}
```

`Consumer`(peek, forEach)
```
public static void main(String[] args) {
    List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
        .peek(x -> System.out.println("Hello " + x + " !!!"))
        .collect(Collectors.toList());
}
```
`Supplier`(generate)
```
public static void main(String[] args) {
    ArrayList<String> nameList = new ArrayList<>();
    nameList.add("Elena");
    nameList.add("John");
    nameList.add("Alex");
    nameList.add("Jim");
    nameList.add("Sara");
    
    Stream.generate(() -> {
        int value = (int) (Math.random() * nameList.size());
        return nameList.get(value);
    }).limit(5).forEach(System.out::println);
}
```
`Function`(map)
```
public static void main(String[] args) {
    List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
}
```
`UnaryOperator`(iterate)

1. Элемент, с котрого начинается генерация
2. Указывает принцип генерации новых элементов
```
public static void main(String[] args) {
    Stream.iterate(9, x -> x * x)
        .limit(4)
        .forEach(System.out::println);
}
```

### 4. Меняет ли начальные данные stream?
   нет

### 5. Почему стримы, в чем основная фишка
При одиннаковых получаемых аргументах всегда возвращает один и тот же результат</br>
Являются потокобекзопасными, так как работают или с атомарными значениями или финализированными значениями </br>
Лучше всего подходит для манипуляции над одной структурой, без ее изменения

- Параллелизм - Stream способен автоматически распределять операции на несколько потоков
- Лаконичность
- Нестрокое выполнение - Stream не привязан к размеру исходных данных, что дает возможность его использования во время выполнения программы
- Изолированность - не изменяются исходные данные
- Тестирование

### 6. Как можно обработать исключение, выброшенное в ходе работы Stream
- С помощью блока try-catch
```
Runnable runnable = () -> {
  try {
    // код, который может сгенерировать исключение
  } catch (Exception e) {
    // обработка исключения
  }
};
```
- Обертывание лямбда-выражения в метод, который объявляет исключение:
```
@FunctionalInterface
interface MyRunnable {
  void run() throws Exception;
}

MyRunnable myRunnable = () -> {
  // код, который может сгенерировать исключение
};

try {
  myRunnable.run();
} catch (Exception e) {
  // обработка исключения
}
```
- Использование функционального интерфейса, который объявляет исключение:
```
@FunctionalInterface
interface MyFunction<T, R> {
  R apply(T t) throws Exception;
}

MyFunction<String, Integer> myFunction = (s) -> {
  // код, который может сгенерировать исключение
  return Integer.parseInt(s);
};

try {
  int result = myFunction.apply("42");
} catch (Exception e) {
  // обработка исключения
}
```


## END ---------------- Stream ----------------

## SOLID

- Single Responsibility Principle (Принцип единственной ответственности).
- Open Closed Principle (Принцип открытости/закрытости).
- Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
- Interface Segregation Principle (Принцип разделения интерфейса).
- Dependency Inversion Principle (Принцип инверсии зависимостей).</br></br>

'Single Responsibility Principle' - никогда не должно быть больше одной причины изменить класс.
</br></br>
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс
</br></br>
Пример:</br>
    Представьте себе модуль, который обрабатывает заказы.</br>
    Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа
</br></br>
Данный класс протировечит SRP так как он отвечает за 3 обязанности.</br>
В идеале это должны быть 3 отдельных класса, каждый из которых отвечает за свою область</br></br>

`Open Closed Principle` - программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.</br>
Должна быть возможность изменять внешнее поведеление класс, не внося физические изменения в сам класс.</br>
Класс должны разрабатываться так, чтобы для поднастройки класс к конкретным условиям применения было доставточно расширить его или переопределить некоторые функции
</br></br>
`Liskov’s Substitution Principle` - объекты в программе можно заменить их наследниками без изменения свойств программы.</br>
Класс, разработанный путем расширения на основании базового класса, должен переопределять его метода так, чтобы не нарушалась функциональность</br>
с точки зрения клиента. То есть не должно меняться ожидаемое поведение
</br></br>
`Interface Segregation Principle` - клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.</br>
Слишком "толстые" интерфейсы необходимо разделять на более мелкие, спецефические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе</br>
</br></br>
`Dependency Inversion Principle` - зависимости внутри системы строятся на основе абстракций.</br>
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономны и соединялись друг с другом с помощью абстракций


## END ---------------- SOLID ----------------

## ENUM

+ [1. Зачем нужен enum?](#1-зачем-нужен-enum)
+ [2. Что такое enum?](#2-что-такое-enum)
+ [3. Как указать значения для свойсты и как их получить](#3-как-указать-значения-для-свойсты-и-как-их-получить)

### 1. Зачем нужен enum?
Это класс для создания некоторого ограниченного круга значений
```
public enum DayOfWeek {
   SUNDAY,
   MONDAY,
   TUESDAY,
   WEDNESDAY,
   THURSDAY,
   FRIDAY,
   SATURDAY
}
```

### 2. Что такое enum?
Это финализированный класс, от него нельзя наследоваться

### 3. Как указать значения для свойств и как их получить
```
public enum DayOfWeek {

   SUNDAY ("Воскресенье"),
   MONDAY ("Понедельник"),
   TUESDAY ("Вторник"),
   WEDNESDAY ("Среда"),
   THURSDAY ("Четверг"),
   FRIDAY ("Пятница"),
   SATURDAY ("Суббота");

   private String title;

   DayOfWeek(String title) {
       this.title = title;
   }

   public String getTitle() {
       return title;
   }

   @Override
   public String toString() {
       return "DayOfWeek{" +
               "title='" + title + '\'' +
               '}';
   }
}
```
Получение всех значений `DayOfWeek.values()`
Получение индекса константы `int sundayIndex = DayOfWeek.SUNDAY.ordinal();`
Получение индекса по значению `DayOfWeek sunday = DayOfWeek.valueOf("SUNDAY");`


## END ---------------- ENUM ----------------

## Maven

+ [1. Как запускать jar file](#1-как-запускать-jar-file)
+ [2. Как запускать war file](#2-как-запускать-war-file)
+ [3. Чем отличается package от install](#3-чем-отличается-package-от-install)
+ [4. Какие есть команды у Maven](#4-какие-есть-команды-у-maven)
+ [5. Области действия зависимостей (scope)](#5-области-действия-зависимостей-scope)
+ [6. Плагины](#6-плагины)

### 1. Как запускать jar file
- java -jar main.jar

### 2. Как запускать war file
- Unwrap `jar -xvf MyWar.war`
- move into directory
- Run `java -classpath "lib/*:classes/." my.packages.destination.FileToRun`

### 3. Чем отличается package от install
- `package` - собирает проект и упаковывает его в формате (например jar, war)</br>
Она не устанавлиает собранный проект в локальный Maven озиторий или удаленный репозиторий, просто создает аптефакт

- `install` - собирает и упаковывает проект, а затем устанавливает его в локальный репозиторий Maven

### 4. Какие есть команды у Maven
- mvn clean
- mvn package
- mvn deploy - (установить артифакт в локальный репозиторий)
- mvn dependency:tree
- mvn archetype:generate - (создать проект из прототипа/шаблона проекта)
- mvn compile
- mvn -f dir/pom.xml package - (Форсировать использование зависемостей из другого pom файла)
- mvn -q package - (Упаковка в тихом режиме, показывает только ошибки)
- mvn -v
- mvn -DskipTests package - (Упаковка без тестов)
- mvn compiler:compile - (Компиляться только основные классы)
- mvn install
- mvn validate - (Провалидировать проект)
- mvn dependency:analyze
- mvn -help
- mvn test
- mvn verity - (Запускает проверку интеграционных тестов)
- mvn -o package - (Упаковка в режиме оффлайн)
- mvn -X package - (Упаков в режиме debug)
- mvn -V package - (Упаковка с отображением версий)
- mvn -T 4 clean install - (Параллельная упаковка в 4х потоках)

### 5. Области действия зависимостей (scope)
- test - зависимость будет использована при выполнении компиляции части проекта, которая содержит тесты, а также при запуске тестов
- compile - Настройка по умолчанию. Зависимость доступна для компиляции приложения и тестов
  - Для запуска тестов `mvn test`
  - для запуска приложения используется плагин `exec`
- provided - Аналогично `compile` за исключением того, что артефакт будет использоваться на этапе компиляции и тестирования, но не включается в сборку
  - например `hibernate`, `jsf` - необходимы только на этапе разработки
- runtime - артефакт нужен только на стадии выполнения приложения
- system - аналогично `provided` за исключением того, что артефакт будет указываться явно в виде абсолютного пути к файлу определенногому в теге systemPath
```
<dependencies>
    <dependency>
        <groupId>ru.carousel</groupId>
        <artifactId>carousel-lib</artifactId>
        <version>1.0</version>
        <scope>system</scope>
        <systemPath>
               /projects/libs/carousel-lib.jar
        </systemPath>
    </dependency>
</dependencies>
```

### 6. Плагины
- maven-compiler-plugin - плагин компиляции
- maven-resources-plugin - плагин включения ресурсов
- maven-source-plugin - плагин включения исходных кодов
- maven-dependency-plugin - плагин копирования зависимостей
- maven-jar-plugin - плагин создания jar-файла
- maven-surefire-plugin - плагин запуска тестов
- buildnumber-maven-plugin - плагин генерации номера сборки</br></br>

- `maven-compiler-plugin` - Плагин компиляции
  - Позволяет управлять версией компилятора
  - Позволяет определить версию java машины
  - source - версия java-кода
  - target - версия java машины
  - encoding - Кодировка исходного кода
```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.1</version>
    <configuration>
        <source>1.7</source>
        <target>1.7</target>
        <encoding>UTF-8</encoding>
    </configuration>
</plugin>
```

- `maven-resources-plugin` - плагин включения ресурсов
  - Перед сборкой копирует все ресурсы (файлы изображений, файлы .properties) в директорию таргет
```
<plugin>
    <artifactId>maven-resources-plugin</artifactId>
    <version>2.6</version>
    <executions>
        <execution>
            <id>copy-resources</id>
            <phase>validate</phase>
            <goals>
                <goal>copy-resources</goal>
            </goals>
            <configuration>
                <outputDirectory>
                       ${basedir}/target/resources
                </outputDirectory>
                <resources>
                    <resource>
                        <directory>src/main/resources/props</directory>
                        <filtering>true</filtering>
                        <includes>
                            <include>**/*.properties</include>
                        </includes>
                    </resource>
                    <resource>
                        <directory>src/main/resources/images</directory>
                        <includes>
                            <include>**/*.png</include>
                        </includes>
                    </resource>
                </resources>
            </configuration>
        </execution>
    </executions>
</plugin>
```

- `maven-source-plugin` - Плагин включения сходных кодов
  - позволяет включать в сборку проекта исходный код
```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-source-plugin</artifactId>
    <version>2.2.1</version>
    <executions>
        <execution>
            <id>attach-sources</id>
            <phase>verify</phase>
            <goals>
                <goal>jar</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

- `maven-dependency-plugin` - для копирования зависимостей в директорию сборки
  - outputDirectory - определение директории, в которую будут копироваться зависимости
  - overWriteReleases(default: false) - флаг необходимости перезаписывания зависимостей при создании релиза
  - overWriteSnapshots - флаг необходимости перезаписывания неокончательных зависимостей, в которых присутствует SNAPSHOT
  - overWriteIfNewer(default: true) - флаг необходимости перезаписывания библиотек с наличием более новых версий
```
<plugin> 
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>2.5.1</version>
    <configuration>
        <outputDirectory>
            ${project.build.directory}/lib/
        </outputDirectory>
        <overWriteReleases>false</overWriteReleases>
        <overWriteSnapshots>false</overWriteSnapshots>
        <overWriteIfNewer>true</overWriteIfNewer>
    </configuration>
    <executions>
        <execution> 
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
                <goal>copy-dependencies</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

- `maven-jar-plugin` - плагин создания jar-файла
  - позволяет сформировать манифест, 
  - описать дополнительные ресурсы, необходимые для включения в jar-файл
  - упаковать проект в jar-файл
  - `excludes` - блокирует включение в сборку определенных файлов изображений
```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <includes>
            <include>**/properties/*</include>
        </includes>
        <excludes>
            <exclude>**/*.png</exclude>
        </excludes>
        <archive>
           <manifestFile>src/main/resources/META-INF/MANIFEST.MF</manifestFile>
        </archive>
    </configuration>
</plugin>
```
* Может создать и включить в сборку MANIFEST.MF самостоятельно
  * В секцию `archive` включить тег `manifest`
    * addClasspath - определяет необходимость добавления в манифест CLASSPATH
    * classpathPrefix - позволяет дописывать префикс перед каждым ресурсом
    * mainClass - указывает на главный исполяемый класс
```
<configuration>
    <archive>
        <manifest>
            <addClasspath>true</addClasspath>
            <classpathPrefix>lib/</classpathPrefix>
            <mainClass>ru.company.AppMain</mainClass>
        </manifest>
    </archive>
</configuration>
```

- `maven-surefire-plugin` - плагин для запуска тестов и генерации отчетов по результатам их выполнения
```
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>2.12.4</version>
        <configuration>
            <includes>
                <include>Sample.java</include>
            </includes>
        </configuration>
    </plugin>
</plugins>
```

## END ---------------- Maven ----------------

## Servlet

+ [1. Что такое servlet в java](#1-что-такое-servlet-в-java)
+ [2. Что такое контейнер сервлетов](#2-что-такое-контейнер-сервлетов)
+ [3. Какие функции выполняет контейнер сервлетов](#3-какие-функции-выполняет-контейнер-сервлетов)
+ [4. Контейнер сервлетов в контексте Spring](#4-контейнер-сервлетов-в-контексте-spring)
+ [5. Что делает `DispatcherServlet`](#5-что-делает-dispatcherservlet)

### 1. Что такое servlet в java
- Это класс, который используется для расширения возможностей серверных приложений, для обработки запросов и генерации ответов в протоколе HTTP
- Выполняются на сервере и работуют внутри контейнера сервлетов
- Когда на сервер HTTP-запрос от кликнта, контейнер сервлектов вызывает соответствующий сервлет для обработки запроса
- Могут обрабатывать различные типы запросов GET, POST, PUT, DELETE
- Обычно реализуют интерфейс `javax.servlet.Servlet` или расширяют абстрактный класс `javax.servlet.http.HttpServlet`
```
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.IOException;

public class HelloWorldServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html>");
        out.println("<body>");
        out.println("<h1>Hello, World!</h1>");
        out.println("</body>");
        out.println("</html>");
    }
}
```

### 2. Что такое контейнер сервлетов
Представляет собой часть веб-интерфейса или java-сервера приложений, которая управляет жизненным циклом сервлетов</br>
обрабатывает HTTP-запросы и генерирует HTTP-ответы

### 3. Какие функции выполняет контейнер сервлетов
- **Загрузка и инициализация сервлетов** - отвечает за загрузку соответствующих классов сервлетов и выполняет их инициализацию
- **Управление жизненным циклом сервлетов** - Создает экземпляры сервлетов, управляет их состоянием и освобождает ресурсы после завершения
- **Маршрутизация запросов** - При получении запроса определяет какому сервлету он должен быть направлен на основе URL или других параметров запроса
- **Передача данных запроса сервлету** - Предоставляет потоки ввода/вывода, такие как `HttpServletRequest` и `HttpServletResponse` чтобы сервлет мог получать данные от клиента и генерировать ответ
- **Управление потоками и масштабирование** - обрабатывает одновременные запросы от множества клиентов, управляет потоками и обеспечивает масштабируемость

Пример контейнеров Apache Tomcat, Jetty, IBM WebSphere, Oracle WebLogic

### 4. Контейнер сервлетов в контексте Spring
- Spring MVC предоставляет свой собственный контейнер сервлетов, который называется `DispatcherServlet`
- Он является посредником между клиенскими запросами и обрабатывающими их компонентами (контроллерами)

### 5. Что делает `DispatcherServlet`
- обрабатывает входящие запросы, основываясь на конфигурации приложения и на основе маппинга
- Определяет какой контроллер будет вызван для обработки каждого запроса
- Предоставляет поддержку для внедрения зависимостей в контроллеры и обработку исключений

## END ---------------- Servlet ----------------

## Swagger

+ [1. Какие аннотации используются для swagger документации](#1-какие-аннотации-используются-для-swagger-документации)

### 1. Какие аннотации используются для swagger документации
- `@Operation` - описывает операцию или обычно метод HTTP для определенного пути
- `@Parameter` - представляет один параметр в операции OpenAPI
- `@RequestBody` - представляет тело запроса в операции
- `@ApiResponse` - представляет ответ в операции
- `@Tag` - представляет теги для операции или определения OpenAPI
- `@Server` - представляет серверы для операции или для определения OpenAPI
- `@Callback` - исывает набор запросов
- `@Link` - представляет возможную ссылку времени разработки для ответа
- `@Schema` - позволяет определять входные и выходные данные
- `@ArraySchema` - позволяет определять входные и выходные данные для типов массивов
- `@Content` - позволяет схему и примеры для определенного типа мультимедиа
- `@Hidden` - скрывает ресурс, операцию или свойство
```
@Tag(name = "User", description = "The User API")
@RestController
public class UserController {}
    @Operation(summary = "Gets all users", tags = "user")
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Found the users",
            content = {
                @Content(
                    mediaType = "application/json",
                    array = @ArraySchema(schema = @Schema(implementation = UserApi.class)))
            }
        )
    })
    @GetMapping("/users")
    public List<UserApi> getUsers()
```


## END ---------------- Swagger ----------------

## Nginx

+ [1. Что такое Nginx](#1-что-такое-nginx)
+ [2. Как работает Nginx](#2-как-работает-nginx)
+ [3. Отличие Nginx от Apache](#3-отличие-nginx-от-apache)
+ [4. Конфигурация](#4-конфигурация)
+ [5. Основные команды](#5-основные-команды)

### 1. Что такое Nginx
Это веб-сервер, который обрабатывает запросы пользователя от браузера и присылает ту страницу, которая была запрошена

### 2. Как работает Nginx
Умеет:
- Принимает, обрабатываает и отдает клиентам запросы
  - Обработка происходит внутри специального модуля
  - Каждый запрос Nginx делит на небольшие однотипные структуры - рабочие соединение и обрабатывает несколько соединений параллельно
  - После выполнения они сливаются в единый блок и возвращаются в качестве ответа
- Выступает в качестве прокси-сервера
  - В микросервисной структуре Nginx-у сложно обрабатывать множество клиенских запросов, поэтому он работает в качестве "пересыльщика"
    - Принимает запрос от клиента
    - Передает его отдельному серверу для обработки
    - Получает ответ от сервера
    - Отправляет клиенту

### 3. Отличие Nginx от Apache
|                                 | Nginx           | Apache                               |
|---------------------------------|-----------------|--------------------------------------|
| Работа с динамическим контентом | уступает        | лучше работает с контентом с сервера |
| Работа со статическим контентом | Лучше работает  | хуже работает со статикой            |

### 4. Конфигурация
| Директива                                                                                      | Расшифровка                                                                                                                                                      |
|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| listen 8080;                                                                                   | Сервер будет запускаться на порте 8080                                                                                                                           |
| ```server {listen 8080; root /data/up1; location / {}}```                                      | Сложная директива можевключать в себя несколько простых<br/>Он прослушивает порт 8080 и отдает статические файлы из data при обращении к корневой странице сайта |
| ```server {location / { proxy_pass http://localhost:8080;} location /images/ {root /data;}}``` | Перенаправление запроса                                                                                                                                          |
| ```location ~ \.(git jpg png)$ { root /data/images;}```                                        | Фильтр по типу файла                                                                                                                                             |
|                                                                                                |                                                                                                                                                                  |

### 5. Основные команды
| Команда | Описание                             | Пример            |
|---------|--------------------------------------|-------------------|
| stop    | быстро завершить                     | nginx -s stop     |
| quit    | плавно завершить                     | nginx -s quit     |
| reload  | перезагрузить конфигурационный файл  | nginx -s reload   |
| reopen  | открыть лог-файлы заново             | nginx -s reopen   |

## END ---------------- Nginx ----------------

## Java 8

+ [1. Методы интерфейсов по умолчанию](#1-методы-интерфейсов-по-умолчанию)
+ [2. Лямбда-выражения](#2-лямбда-выражения)
+ [3. Функциональные интерфейсы](#3-функциональные-интерфейсы)
+ [4. Ссылки на методы и конструкторы](#4-ссылки-на-методы-и-конструкторы)
+ [5. Области действия лямбд](#5-области-действия-лямбд)
+ [6. Доступ к полям и статическим переменным](#6-доступ-к-полям-и-статическим-переменным)
+ [7. Доступ к методам интерфейсом по умолчанию](#7-доступ-к-методам-интерфейсом-по-умолчанию)
+ [8. Stream](#8-stream)
+ [9. Апи для работы с датами](#9-апи-для-работы-с-датами)
+ [10. Аннотации](#10-аннотации)

### 1. Методы интерфейсов по умолчанию
```
interface Formula {
    double calculate(int a);
    
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```

### 2. Лямбда-выражения
```
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```

### 3. Функциональные интерфейсы
```
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```

### 4. Ссылки на методы и конструкторы
```
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);
```

### 5. Области действия лямбд
Лямбды могут ссылаться на переменные, обхявленные как final, на экземплярные поля класса и статические переменные
```
final int num = 1;
Converter<Integer, String> stringConverter = (from) -> String.valueOf(from + num);

stringConverter.convert(2);
```
переменная num не обязательно должна быть final, но должна быть неизменяемой

### 6. Доступ к полям и статическим переменным

### 7. Доступ к методам интерфейсом по умолчанию
Внутри лямбда-выражений запрещено обращаться к методам по умолчанию

### 8. Stream

### 9. Апи для работы с датами
- Clock
- Часовые пояса
- LocalTime
- LocalDate
- LocalDateTime

### 10. Аннотации
    @Repeatable


## END ---------------- Java 8 ----------------

## Аутентификация и авторизация

+ [1. Аутентификация](#1-аутентификация)
+ [2. Авторизация](#2-авторизация)


### 1. Аутентификация
- Цель: Аутентификация представляет собой процесс установления и подтверждения подлинности личности или субъекта, например пользователя, системы или оборудования
- Пример: В процессе аутентификации польователь предоставляет учетные данные (логин/пароль, отпечаток пальца) для проверки подлинности, чтобы подтвердить, что он действительно тот, за кого себя выдает

### 2. Авторизация
- Цель: Авторизация - это процесс управления доступом, который определяет, что имеет право делать аутентифицированный субъект. То есть, определяет, какие ресурсы и операции могут быть доступны для этого субъекта
- Пример: После того как пользоваетль аутентифицирован, авторизация определяет его достпные возможности - может ли он просматривать, создавать, удалять определенную информацию или выполнять определенные функции


## END ---------------- Аутентификация и авторизация ----------------



26. Можно ли увеличить размер массива после его инициализации?
нет, только пересоздать новый массив


27. Как создать собственный иммутабельный класс?
final и без геттеров