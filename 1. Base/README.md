https://github.com/johnivo/job4j/blob/master/interview_questions/Core.md#4-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-JDK

+ [1. Протоколы](#1-протоколы)
   <details>
       <summary>Навигация</summary>
   
   + [1.1. REST vs SOAP](#11-rest-vs-soap)
       <details>
           <summary>Навигация</summary>
   
       + [1.1.1. Как расшифровывается REST](#111-как-расшифровывается-rest)
       + [1.1.2. Что такое REST](#112-что-такое-rest)
       + [1.1.3. Какие принципы есть у REST](#113-какие-принципы-есть-у-rest)
       + [1.1.4. Что такое SOAP](#114-что-такое-soap)
       + [1.1.5. Как SOAP и REST используют HTTP протокол](#115-как-soap-и-rest-используют-http-протокол)
       + [1.1.6. В каком формате должны возвращаться данные при REST и SOAP](#116-в-каком-формате-должны-возвращаться-данные-при-rest-и-soap)
       + [1.1.7. С чем работает SOAP и REST](#117-с-чем-работает-soap-и-rest)
       + [1.1.8. Когда лучше использовать SOAP](#118-когда-лучше-использовать-soap)
       + [1.1.9. Когда лучше использовать REST](#119-когда-лучше-использовать-rest)
       + [1.1.10. Как работает кеширование REST](#1110-как-работает-кеширование-rest)
       + [1.1.11. Что такое идентификатор ресурса](#1111-что-такое-идентификатор-ресурса)
       + [1.1.12. Что такое многоуровневая система](#1112-что-такое-многоуровневая-система)
       + [1.1.13. Что такое HATEOAS и как он применяется в REST](#1113-что-такое-hateoas-и-как-он-применяется-в-rest)
       + [1.1.14. Как сравнить безопасность REST и SOAP](#1114-как-сравнить-безопасность-rest-и-soap)
       + [1.1.15. Какие стратегии версионирования API существуют для REST](#1115-какие-стратегии-версионирования-api-существуют-для-rest)
       + [1.1.16. Как обрабатывать ошибки в REST и SOAP](#1116-как-обрабатывать-ошибки-в-rest-и-soap)
       + [1.1.17. Что такое идемпотентность и как она реализована в REST](#1117-что-такое-идемпотентность-и-как-она-реализована-в-rest)
       + [1.1.18. Как реализовать пагинацию в REST API](#1118-как-реализовать-пагинацию-в-rest-api)
       + [1.1.19. Сравнение REST с GraphQL и gRPC](#1119-сравнение-rest-с-graphql-и-grpc)
       + [1.1.20. Как REST применяется в микросервисной архитектуре](#1120-как-rest-применяется-в-микросервисной-архитектуре)
       </details>
   + [1.2. HTTP](#12-http)
       <details>
           <summary>Навигация</summary>
   
       + [1.2.1. Коды ответов](#121-коды-ответов)
       + [1.2.2. HTTP/2 vs HTTP/1.1](#122-http2-vs-http11)
       + [1.2.3. HTTP/2 vs HTTP/3](#123-http2-vs-http3)
       + [1.2.4. CSRF токен](#124-csrf-токен)
       + [1.2.5. Основные HTTP методы](#125-основные-http-методы)
       + [1.2.6. HTTP заголовки](#126-http-заголовки)
       + [1.2.7. Cookies и Sessions](#127-cookies-и-sessions)
       + [1.2.8. HTTPS и SSL/TLS](#128-https-и-ssltls)
       + [1.2.9. HTTP кеширование](#129-http-кеширование)
       + [1.2.10. CORS (Cross-Origin Resource Sharing)](#1210-cors-cross-origin-resource-sharing)
       + [1.2.11. WebSockets vs HTTP](#1211-websockets-vs-http)
       + [1.2.12. Подробно о статус-кодах](#1212-подробно-о-статус-кодах)
       </details>
   </details>

+ [2. Java](#2-java)
  <details>
     <summary>Навигация</summary>
  
  + [2.1. Основы](#21-основы)
  	<details>
  		<summary>Навигация</summary>

  	+ [2.1.1. Какие преимущества у Java?](#211-какие-преимущества-у-java)
  	+ [2.1.2. Какие недостатки у Java?](#212-какие-недостатки-у-java)
  	+ [2.1.3. Что такое JVM, JDK, JRE? В чем отличия?](#213-что-такое-jvm-jdk-jre-в-чем-отличия)
  	+ [2.1.4. Что такое byte code?](#214-что-такое-byte-code)
  	+ [2.1.5. Что такое загрузчик классов (ClassLoader)?](#215-что-такое-загрузчик-классов-classloader)
  	+ [2.1.6. Что такое JIT-компилятор?](#216-что-такое-jit-компилятор)
  	+ [2.1.7. Что такое String[] args в методе main()?](#217-что-такое-string-args-в-методе-main)
  	+ [2.1.8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?](#218-что-такое-пакеты-зачем-они-нужны-какие-пакеты-по-умолчанию-подключены)
  	+ [2.1.9. Какой дефолтный модификатор доступа у класса?](#219-какой-дефолтный-модификатор-доступа-у-класса)
  	+ [2.1.10. Какие типы принимает System.out.println()?](#2110-какие-типы-принимает-systemoutprintln)
  	+ [2.1.11. Что такое модули в Java (JPMS)?](#2111-что-такое-модули-в-java-jpms)
  	+ [2.1.12. В чем разница между JAR, WAR и EAR?](#2112-в-чем-разница-между-jar-war-и-ear)
  	+ [2.1.13. Что такое Java Memory Model (JMM)?](#2113-что-такое-java-memory-model-jmm)
  	+ [2.1.14. Как работает сборщик мусора (GC) в Java? Какие алгоритмы используются?](#2114-как-работает-сборщик-мусора-gc-в-java-какие-алгоритмы-используются)
  	</details>

    + [2.2. Примитивные типы, строки и базовые структуры](#22-примитивные-типы-строки-и-базовые-структуры)
      <details>
      	<summary>Навигация</summary>

        + [2.2.1. Какие примитивные типы данных есть в Java?](#221-какие-примитивные-типы-данных-есть-в-java)
        + [2.2.2. Какими значениями по умолчанию инициализируются поля примитивных типов данных?](#222-какими-значениями-по-умолчанию-инициализируются-поля-примитивных-типов-данных)
        + [2.2.3. Что такое автоупаковка и автораспаковка?](#223-что-такое-автоупаковка-и-автораспаковка)
        + [2.2.4. Что такое классы-обертки (Wrapper classes)?](#224-что-такое-классы-обертки-wrapper-classes)
        + [2.2.5. Что такое приведение типов (cast)?](#225-что-такое-приведение-типов-cast)
        + [2.2.6. Что такое пул интов (Integer pool)?](#226-что-такое-пул-интов-integer-pool)
        + [2.2.7. Какие нюансы у строк в Java?](#227-какие-нюансы-у-строк-в-java)
        + [2.2.8. Что такое пул строк (String pool)?](#228-что-такое-пул-строк-string-pool)
        + [2.2.9. Почему строки не рекомендуется использовать для хранения паролей?](#229-почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
        + [2.2.10. Почему класс String неизменяемый (immutable) и final?](#2210-почему-класс-string-неизменяемый-immutable-и-final)
        + [2.2.11. Что делает метод intern() в классе String?](#2211-что-делает-метод-intern-в-классе-string)
        + [2.2.12. Можно ли использовать строки в конструкции switch?](#2212-можно-ли-использовать-строки-в-конструкции-switch)
        + [2.2.13. Что такое инвариантность, ковариантность и контравариантность в контексте дженериков?](#2213-что-такое-инвариантность-ковариантность-и-контравариантность-в-контексте-дженериков)
        + [2.2.14. В чем разница между String, StringBuffer и StringBuilder?](#2214-в-чем-разница-между-string-stringbuffer-и-stringbuilder)
        + [2.2.15. Каким образом переменные передаются в методы (pass-by-value vs pass-by-reference)?](#2215-каким-образом-переменные-передаются-в-методы-pass-by-value-vs-pass-by-reference)
        + [2.2.16. В чем разница между Hashtable и HashMap?](#2216-в-чем-разница-между-hashtable-и-hashmap)
        + [2.2.17. Как ограничить upper bounding типа-параметра в дженериках?](#2217-как-ограничить-upper-bounding-типа-параметра-в-дженериках)
        + [2.2.18. Сколько может быть стеков в JVM?](#2218-сколько-может-быть-стеков-в-jvm)
        + [2.2.19. Какие классы могут быть статическими (static nested classes)?](#2219-какие-классы-могут-быть-статическими-static-nested-classes)
        + [2.2.20. Что такое финальный класс (final class)?](#2220-что-такое-финальный-класс-final-class)
        + [2.2.21. Что такое поверхностное копирование (shallow copy)?](#2221-что-такое-поверхностное-копирование-shallow-copy)
        + [2.2.22. Что такое глубокое копирование (deep copy)?](#2222-что-такое-глубокое-копирование-deep-copy)
        + [2.2.23. Какие иммутабельные классы есть в Java?](#2223-какие-иммутабельные-классы-есть-в-java)
        + [2.2.24. Как проверить значение на null в Java 8+ (Optional, etc.)?](#2224-как-проверить-значение-на-null-в-java-8-optional-etc)
        + [2.2.25. Что такое var в Java 10+ и когда его использовать?](#2225-что-такое-var-в-java-10-и-когда-его-использовать)
      </details>

    + [2.3. Потоки ввода/вывода (I/O)](#23-потоки-вводавывода-io)
      <details>
      	<summary>Навигация</summary>

        + [2.3.1. Что такое потоки ввода/вывода в Java?](#231-что-такое-потоки-вводавывода-в-java)
        + [2.3.2. Какие виды потоков существуют (byte vs character streams)?](#232-какие-виды-потоков-существуют-byte-vs-character-streams)
        + [2.3.3. Что такое класс InputStream?](#233-что-такое-класс-inputstream)
        + [2.3.4. Что такое класс OutputStream?](#234-что-такое-класс-outputstream)
        + [2.3.5. Какие классы наследуются от базовых классов InputStream и OutputStream?](#235-какие-классы-наследуются-от-базовых-классов-inputstream-и-outputstream)
        + [2.3.6. Что такое класс File для работы с файловой системой?](#236-что-такое-класс-file-для-работы-с-файловой-системой)
        + [2.3.7. В чем разница между FileInputStream и FileReader?](#237-в-чем-разница-между-fileinputstream-и-filereader)
        + [2.3.8. Как работает NIO (New I/O) в Java? Что такое Channels и Buffers?](#238-как-работает-nio-new-io-в-java-что-такое-channels-и-buffers)
        + [2.3.9. Что такое Path и Files в java.nio.file?](#239-что-такое-path-и-files-в-javaniofile)
        + [2.3.10. Как обрабатывать большие файлы без загрузки в память (streaming)?](#2310-как-обрабатывать-большие-файлы-без-загрузки-в-память-streaming)
      </details>

    + [2.4. Объектно-ориентированное программирование (ООП)](#24-объектно-ориентированное-программирование-ооп)
      <details>
      	<summary>Навигация</summary>

        + [2.4.1. Какие принципы ООП поддерживает Java (инкапсуляция, наследование, полиморфизм, абстракция)?](#241-какие-принципы-ооп-поддерживает-java-инкапсуляция-наследование-полиморфизм-абстракция)
        + [2.4.2. Что такое вложенные классы? В каких случаях они применяются?](#242-что-такое-вложенные-классы-в-каких-случаях-они-применяются)
        + [2.4.3. Что такое локальный класс? Каковы его особенности?](#243-что-такое-локальный-класс-каковы-его-особенности)
        + [2.4.4. Что такое анонимные классы? Где они применяются?](#244-что-такое-анонимные-классы-где-они-применяются)
        + [2.4.5. Каким образом из вложенного класса получить доступ к полю внешнего класса?](#245-каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
        + [2.4.6. Что такое перечисления (enum)?](#246-что-такое-перечисления-enum)
        + [2.4.7. Как проблема ромбовидного наследования решена в Java (default methods)?](#247-как-проблема-ромбовидного-наследования-решена-в-java-default-methods)
        + [2.4.8. Что такое конструктор по умолчанию?](#248-что-такое-конструктор-по-умолчанию)
        + [2.4.9. Могут ли быть приватные конструкторы? Для чего они нужны?](#249-могут-ли-быть-приватные-конструкторы-для-чего-они-нужны)
        + [2.4.10. Чем отличаются конструктор по умолчанию, конструктор копирования и конструктор с параметрами?](#2410-чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
        + [2.4.11. Какие модификаторы доступа вы знаете? Расскажите про каждый из них.](#2411-какие-модификаторы-доступа-вы-знаете-расскажите-про-каждый-из-них)
        + [2.4.12. Что означает модификатор static?](#2412-что-означает-модификатор-static)
        + [2.4.13. Могут ли нестатические методы перегрузить статические?](#2413-могут-ли-нестатические-методы-перегрузить-статические)
        + [2.4.14. Могут ли быть переопределены статические методы?](#2414-могут-ли-быть-переопределены-статические-методы)
        + [2.4.15. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?](#2415-можно-ли-сузить-уровень-доступа-или-тип-возвращаемого-значения-при-переопределении-метода)
        + [2.4.16. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы?](#2416-что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы)
        + [2.4.17. Что такое сигнатура метода?](#2417-что-такое-сигнатура-метода)
        + [2.4.18. Что такое переопределение (overriding) и перегрузка (overloading) методов?](#2418-что-такое-переопределение-overriding-и-перегрузка-overloading-методов)
        + [2.4.19. Когда вызывается конструктор?](#2419-когда-вызывается-конструктор)
        + [2.4.20. Что означает ключевое слово final?](#2420-что-означает-ключевое-слово-final)
        + [2.4.21. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?](#2421-могут-ли-быть-конструкторы-у-абстрактных-классов-зачем-они-нужны)
        + [2.4.22. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#2422-что-такое-интерфейсы-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
        + [2.4.23. Может ли интерфейс наследоваться от другого интерфейса?](#2423-может-ли-интерфейс-наследоваться-от-другого-интерфейса)
        + [2.4.24. Что такое дефолтные методы (default methods) в интерфейсах?](#2424-что-такое-дефолтные-методы-default-methods-в-интерфейсах)
        + [2.4.25. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default-методами?](#2425-как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-с-default-методами)
        + [2.4.26. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?](#2426-каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учетом-иерархии-классов)
        + [2.4.27. Какие бывают блоки инициализации и зачем они нужны?](#2427-какие-бывают-блоки-инициализации-и-зачем-они-нужны)
        + [2.4.28. Каков порядок вызова конструкторов и блоков инициализации для класса-потомка и его предка?](#2428-каков-порядок-вызова-конструкторов-и-блоков-инициализации-для-класса-потомка-и-его-предка)
        + [2.4.29. Что произойдет, если в блоке инициализации возникнет ошибка?](#2429-что-произойдет-если-в-блоке-инициализации-возникнет-ошибка)
        + [2.4.30. Какие методы есть у класса Object?](#2430-какие-методы-есть-у-класса-object)
        + [2.4.31. Что такое метод equals()? Чем он отличается от операции ==?](#2431-что-такое-метод-equals-чем-он-отличается-от-операции-)
        + [2.4.32. Каким образом реализованы методы equals() и hashCode() в Object?](#2432-каким-образом-реализованы-методы-equals-и-hashcode-в-object)
        + [2.4.33. Какие правила переопределения equals()?](#2433-какие-правила-переопределения-equals)
        + [2.4.34. Какие правила переопределения hashCode()?](#2434-какие-правила-переопределения-hashcode)
        + [2.4.35. Могут ли у разных объектов быть одинаковые hashCode()?](#2435-могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
        + [2.4.36. Чем a.getClass().equals(A.class) отличается от instanceof A?](#2436-чем-agetclassequalsaclass-отличается-от-instanceof-a)
        + [2.4.37. Может ли метод быть одновременно abstract и final?](#2437-может-ли-метод-быть-одновременно-abstract-и-final)
        + [2.4.38. Что такое функциональные интерфейсы?](#2438-что-такое-функциональные-интерфейсы)
        + [2.4.39. Как связаны equals() и hashCode()? Можно ли их использовать по отдельности?](#2439-как-связаны-equals-и-hashcode-можно-ли-их-использовать-по-отдельности)
        + [2.4.40. Какая дефолтная реализация equals() в Object?](#2440-какая-дефолтная-реализация-equals-в-object)
        + [2.4.41. Какие есть способы глубокого копирования объекта?](#2441-какие-есть-способы-глубокого-копирования-объекта)
        + [2.4.42. Как избежать ромбовидного наследования в Java?](#2442-как-избежать-ромбовидного-наследования-в-java)
        + [2.4.43. Что такое sealed classes в Java 17?](#2443-что-такое-sealed-classes-в-java-17)
      </details>

    + [2.5. Исключения (Exceptions)](#25-исключения-exceptions)
      <details>
      	<summary>Навигация</summary>

        + [2.5.1. Опишите иерархию исключений в Java.](#251-опишите-иерархию-исключений-в-java)
        + [2.5.2. Чем отличается Error от Exception?](#252-чем-отличается-error-от-exception)
        + [2.5.3. Расскажите про checked (обрабатываемые) и unchecked (необрабатываемые) исключения.](#253-расскажите-про-checked-обрабатываемые-и-unchecked-необрабатываемые-исключения)
        + [2.5.4. Какой оператор позволяет принудительно выбросить исключение (throw)?](#254-какой-оператор-позволяет-принудительно-выбросить-исключение-throw)
        + [2.5.5. Как создать собственное (пользовательское) исключение?](#255-как-создать-собственное-пользовательское-исключение)
        + [2.5.6. В каком случае не выполнится блок finally?](#256-в-каком-случае-не-выполнится-блок-finally)
        + [2.5.7. Может ли метод main() выбросить исключение наружу?](#257-может-ли-метод-main-выбросить-исключение-наружу)
        + [2.5.8. В каком порядке следует обрабатывать исключения в catch-блоках?](#258-в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
        + [2.5.9. Что такое try-with-resources?](#259-что-такое-try-with-resources)
        + [2.5.10. Что необходимо реализовать для работы try-with-resources (AutoCloseable)?](#2510-что-необходимо-реализовать-для-работы-try-with-resources-autocloseable)
        + [2.5.11. Что произойдет, если исключение будет выброшено из блока catch, а затем другое — из finally?](#2511-что-произойдет-если-исключение-будет-выброшено-из-блока-catch-а-затем-другое--из-finally)
        + [2.5.12. Можно ли использовать checked-исключения в лямбда-выражениях?](#2512-можно-ли-использовать-checked-исключения-в-лямбда-выражениях)
        + [2.5.13. Как определить причину OutOfMemoryError?](#2513-как-определить-причину-outofmemoryerror)
        + [2.5.14. Что такое suppressed exceptions в Java?](#2514-что-такое-suppressed-exceptions-в-java)
        + [2.5.15. Как правильно логировать исключения в production-коде?](#2515-как-правильно-логировать-исключения-в-production-коде)
      </details>

    + [2.6. Сериализация и копирование](#26-сериализация-и-копирование)
      <details>
      	<summary>Навигация</summary>

        + [2.6.1. Что такое сериализация и как она реализована в Java?](#261-что-такое-сериализация-и-как-она-реализована-в-java)
        + [2.6.2. Для чего нужна сериализация?](#262-для-чего-нужна-сериализация)
        + [2.6.3. Опишите процесс сериализации/десериализации с использованием Serializable.](#263-опишите-процесс-сериализациидесериализации-с-использованием-serializable)
        + [2.6.4. Какие поля не будут сериализованы при сериализации (transient)?](#264-какие-поля-не-будут-сериализованы-при-сериализации-transient)
        + [2.6.5. Как изменить стандартное поведение сериализации/десериализации (readObject, writeObject)?](#265-как-изменить-стандартное-поведение-сериализациидесериализации-readobject-writeobject)
        + [2.6.6. Как создать собственный протокол сериализации (Externalizable)?](#266-как-создать-собственный-протокол-сериализации-externalizable)
        + [2.6.7. В чем проблема сериализации Singleton? Как ее решить?](#267-в-чем-проблема-сериализации-singleton-как-ее-решить)
        + [2.6.8. Как происходит десериализация? Что такое serialVersionUID?](#268-как-происходит-десериализация-что-такое-serialversionuid)
        + [2.6.9. В чем разница между Serializable и Externalizable?](#269-в-чем-разница-между-serializable-и-externalizable)
        + [2.6.10. Какие проблемы безопасности связаны с десериализацией?](#2610-какие-проблемы-безопасности-связаны-с-десериализацией)
      </details>

    + [2.7. Дженерики (Generics)](#27-дженерики-generics)
      <details>
      	<summary>Навигация</summary>

        + [2.7.1. Что такое дженерики в Java?](#271-что-такое-дженерики-в-java)
        + [2.7.2. Зачем нужны дженерики? Какие проблемы они решают?](#272-зачем-нужны-дженерики-какие-проблемы-они-решают)
        + [2.7.3. Что такое типовая эрасура (type erasure)?](#273-что-такое-типовая-эрасура-type-erasure)
        + [2.7.4. В чем разница между bounded и unbounded wildcards?](#274-в-чем-разница-между-bounded-и-unbounded-wildcards)
        + [2.7.5. Что такое PECS (Producer Extends, Consumer Super)?](#275-что-такое-pecs-producer-extends-consumer-super)
        + [2.7.6. Можно ли использовать примитивные типы в дженериках?](#276-можно-ли-использовать-примитивные-типы-в-дженериках)
        + [2.7.7. Что такое рекурсивные дженерики?](#277-что-такое-рекурсивные-дженерики)
        + [2.7.8. Как работает super в дженериках?](#278-как-работает-super-в-дженериках)
      </details>

    + [2.8. Коллекции](#28)
      <details>
      	<summary>Навигация</summary>

        + [2.8.1. Что такое коллекция?](#281-что-такое-коллекция)
        + [2.8.2. Расскажите про иерархию коллекций?](#282-расскажите-про-иерархию-коллекций)
        + [2.8.3. Почему Map - это не Collection, в то время как List и Set являются Collection?](#283-почему-map---это-не-collection-в-то-время-как-list-и-set-являются-collection)
        + [2.8.4. В чем разница между классами java.util.Collection и java.util.Collections?](#284-в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
        + [2.8.5. Что такое «fail-fast поведение»?](#285-что-такое-fail-fast-поведение)
        + [2.8.6. Какая разница между fail-fast и fail-safe?](#286-какая-разница-между-fail-fast-и-fail-safe)
        + [2.8.7. Чем различается Enumeration и Iterator?](#287-чем-различается-enumeration-и-iterator)
        + [2.8.8. Как между собой связаны Iterable, Iterator и «for-each»?](#288-как-между-собой-связаны-iterable-iterator-и-for-each)
        + [2.8.9. Сравните Iterator и ListIterator.](#289-сравните-iterator-и-listiterator)
        + [2.8.10. Как поведёт себя коллекция, если вызвать iterator.remove()?](#2810-как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
        + [2.8.11. Чем Set отличается от List?](#2811-чем-set-отличается-от-list)
        + [2.8.12. Расскажите про интерфейс Set](#2812-расскажите-про-интерфейс-set)
        + [2.8.13. Что будет если добавлять элементы в TreeSet по возрастанию?](#2813-что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
        + [2.8.14. Как устроен HashSet, сложность основных операций](#2814-как-устроен-hashset-сложность-основных-операций)
        + [2.8.15. Как устроен LinkedHashSet сложность основных операций](#2815-как-устроен-linkedhashset-сложность-основных-операций)
        + [2.8.16. Как устроен TreeSet сложность основных операций](#2816-как-устроен-treeset-сложность-основных-операций)
        + [2.8.17. Расскажите про интерфейс List](#2817-расскажите-про-интерфейс-list)
        + [2.8.18. Как устроен ArrayList сложность основных операций](#2818-как-устроен-arraylist-сложность-основных-операций)
        + [2.8.19. Как устроен LinkedList сложность основных операций](#2819-как-устроен-linkedlist-сложность-основных-операций)
        + [2.8.20. Почему LinkedList реализует и List и Deque](#2820-почему-linkedlist-реализует-и-list-и-deque)
        + [2.8.21. Как перестроить Связанный список в HashTable](#2821-как-перестроить-связанный-список-в-hashtable)
        + [2.8.22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?](#2822-существуют-ли-какие-нибудь-требованию-к-объектам-используемым-в-качестве-ключа-в-hashmap)
        + [2.8.23. Как работает HashMap?](#2823-как-работает-hashmap)
        + [2.8.24. Как строиться красное-черное дерево?](#2824-как-строиться-красное-черное-дерево)
        + [2.8.25. На чем основана HashSet?](#2825-на-чем-основана-hashset)
        + [2.8.26. Какая структура подходит для хранения большого количества данных](#2826-какая-структура-подходит-для-хранения-большого-количества-данных)
        + [2.8.27. Что может быть ключем в HashMap?](#2827-что-может-быть-ключем-в-hashmap)
        + [2.8.28. Параметры ArrayList](#2828-параметры-arraylist)
        + [2.8.29. Stack](#2829-stack)
        + [2.8.30. Comparator vs Comparable](#2830-comparator-vs-comparable)
        + [2.8.31. Какие есть конкурентные коллекции в Java?](#2831-какие-есть-конкурентные-коллекции-в-java)
        + [2.8.32. Как работает Stream API с коллекциями?](#2832-как-работает-stream-api-с-коллекциями)
      </details>

+ [3. Memory Management](#3-memory-management)
  <details>
  	<summary>Навигация</summary>

    + [3.1. Garbage Collection](#31-garbage-collection)
      <details>
      	<summary>Навигация</summary>

        + [3.1.1. Как устроена память в Java?](#311-как-устроена-память-в-java)
        + [3.1.2. Что является мусором (garbage) в Java?](#312-что-является-мусором-garbage-в-java)
        + [3.1.3. Этапы сборки мусора](#313-этапы-сборки-мусора)
        + [3.1.4. Что означают поколения объектов?](#314-что-означают-поколения-объектов)
        + [3.1.5. Зачем нужны поколения объектов?](#315-зачем-нужны-поколения-объектов)
        + [3.1.6. Как происходит заполнение областей памяти?](#316-как-происходит-заполнение-областей-памяти)
        + [3.1.7. Какие есть сборщики мусора в Java?](#317-какие-есть-сборщики-мусора-в-java)
        + [3.1.8. Как работает сборщик CMS GC (Concurrent Mark Sweep)?](#318-как-работает-сборщик-cms-gc-concurrent-mark-sweep)
        + [3.1.9. Как работает G1 GC (Garbage First)?](#319-как-работает-g1-gc-garbage-first)
        + [3.1.10. Что такое Minor GC и Major GC?](#3110-что-такое-minor-gc-и-major-gc)
        + [3.1.11. Как настроить параметры сборки мусора?](#3111-как-настроить-параметры-сборки-мусора)
        + [3.1.12. Какие бывают ссылки в Java и в чем их отличия?](#3112-какие-бывают-ссылки-в-java-и-в-чем-их-отличия)
        + [3.1.13. Чистит ли GC String Pool?](#3113-чистит-ли-gc-string-pool)
      </details>

    + [3.2. Java Memory Model (JMM)](#32-java-memory-model-jmm)
      <details>
      	<summary>Навигация</summary>

        + [3.2.1. Что обозначает JMM?](#321-что-обозначает-jmm)
        + [3.2.2. Зачем нужен JMM?](#322-зачем-нужен-jmm)
        + [3.2.3. Ключевые концепции JMM](#323-ключевые-концепции-jmm)
        + [3.2.4. Что такое happens-before в JMM?](#324-что-такое-happens-before-в-jmm)
        + [3.2.5. Как избежать race conditions с помощью JMM?](#325-как-избежать-race-conditions-с-помощью-jmm)
        + [3.2.6. Что такое volatile в контексте JMM?](#326-что-такое-volatile-в-контексте-jmm)
        + [3.2.7. Как JMM влияет на производительность?](#327-как-jmm-влияет-на-производительность)
      </details>

    + [3.3. Ссылки и Области Памяти](#33-ссылки-и-области-памяти)
      <details>
      	<summary>Навигация</summary>

        + [3.3.1. Какие бывают ссылки в Java и в чем их отличия?](#331-какие-бывают-ссылки-в-java-и-в-чем-их-отличия)
        + [3.3.2. Что такое soft, weak, phantom ссылки?](#332-что-такое-soft-weak-phantom-ссылки)
        + [3.3.3. Чистит ли GC String Pool?](#333-чистит-ли-gc-string-pool)
        + [3.3.4. Что такое Heap, Stack и Metaspace?](#334-что-такое-heap-stack-и-metaspace)
        + [3.3.5. Как происходит переполнение стека (StackOverflowError)?](#335-как-происходит-переполнение-стека-stackoverflowerror)
        + [3.3.6. Что такое ReferenceQueue и зачем она нужна?](#336-что-такое-referencequeue-и-зачем-она-нужна)
        + [3.3.7. Как области памяти влияют на производительность и GC?](#337-как-области-памяти-влияют-на-производительность-и-gc)
      </details>

    + [3.4. Профилирование и Мониторинг](#34-профилирование-и-мониторинг)
      <details>
      	<summary>Навигация</summary>

        + [3.4.1. Какие инструменты для профилирования памяти в Java?](#341-какие-инструменты-для-профилирования-памяти-в-java)
        + [3.4.2. Как выявить утечку памяти?](#342-как-выявить-утечку-памяти)
        + [3.4.3. Что такое heap dump и как его анализировать?](#343-что-такое-heap-dump-и-как-его-анализировать)
        + [3.4.4. Что такое JFR (Java Flight Recorder) и как его использовать?](#344-что-такое-jfr-java-flight-recorder-и-как-его-использовать)
        + [3.4.5. Как мониторить JVM с помощью JMX?](#345-как-мониторить-jvm-с-помощью-jmx)
      </details>
  </details>

## 1. Протоколы

+ [1.1. REST vs SOAP](#11-rest-vs-soap)
    <details>
        <summary>Навигация</summary>

    + [1.1.1. Как расшифровывается REST](#111-как-расшифровывается-rest)
    + [1.1.2. Что такое REST](#112-что-такое-rest)
    + [1.1.3. Какие принципы есть у REST](#113-какие-принципы-есть-у-rest)
    + [1.1.4. Что такое SOAP](#114-что-такое-soap)
    + [1.1.5. Как SOAP и REST используют HTTP протокол](#115-как-soap-и-rest-используют-http-протокол)
    + [1.1.6. В каком формате должны возвращаться данные при REST и SOAP](#116-в-каком-формате-должны-возвращаться-данные-при-rest-и-soap)
    + [1.1.7. С чем работает SOAP и REST](#117-с-чем-работает-soap-и-rest)
    + [1.1.8. Когда лучше использовать SOAP](#118-когда-лучше-использовать-soap)
    + [1.1.9. Когда лучше использовать REST](#119-когда-лучше-использовать-rest)
    + [1.1.10. Как работает кеширование REST](#1110-как-работает-кеширование-rest)
    + [1.1.11. Что такое идентификатор ресурса](#1111-что-такое-идентификатор-ресурса)
    + [1.1.12. Что такое многоуровневая система](#1112-что-такое-многоуровневая-система)
    + [1.1.13. Что такое HATEOAS и как он применяется в REST](#1113-что-такое-hateoas-и-как-он-применяется-в-rest)
    + [1.1.14. Как сравнить безопасность REST и SOAP](#1114-как-сравнить-безопасность-rest-и-soap)
    + [1.1.15. Какие стратегии версионирования API существуют для REST](#1115-какие-стратегии-версионирования-api-существуют-для-rest)
    + [1.1.16. Как обрабатывать ошибки в REST и SOAP](#1116-как-обрабатывать-ошибки-в-rest-и-soap)
    + [1.1.17. Что такое идемпотентность и как она реализована в REST](#1117-что-такое-идемпотентность-и-как-она-реализована-в-rest)
    + [1.1.18. Как реализовать пагинацию в REST API](#1118-как-реализовать-пагинацию-в-rest-api)
    + [1.1.19. Сравнение REST с GraphQL и gRPC](#1119-сравнение-rest-с-graphql-и-grpc)
    + [1.1.20. Как REST применяется в микросервисной архитектуре](#1120-как-rest-применяется-в-микросервисной-архитектуре)
    </details>
+ [1.2. HTTP](#12-http)
    <details>
        <summary>Навигация</summary>

    + [1.2.1. Коды ответов](#121-коды-ответов)
    + [1.2.2. HTTP/2 vs HTTP/1.1](#122-http2-vs-http11)
    + [1.2.3. HTTP/2 vs HTTP/3](#123-http2-vs-http3)
    + [1.2.4. CSRF токен](#124-csrf-токен)
    + [1.2.5. Основные HTTP методы](#125-основные-http-методы)
    + [1.2.6. HTTP заголовки](#126-http-заголовки)
    + [1.2.7. Cookies и Sessions](#127-cookies-и-sessions)
    + [1.2.8. HTTPS и SSL/TLS](#128-https-и-ssltls)
    + [1.2.9. HTTP кеширование](#129-http-кеширование)
    + [1.2.10. CORS (Cross-Origin Resource Sharing)](#1210-cors-cross-origin-resource-sharing)
    + [1.2.11. WebSockets vs HTTP](#1211-websockets-vs-http)
    + [1.2.12. Подробно о статус-кодах](#1212-подробно-о-статус-кодах)
    </details>


### 1.1. REST vs SOAP

+ [1.1.1. Как расшифровывается REST](#111-как-расшифровывается-rest)
+ [1.1.2. Что такое REST](#112-что-такое-rest)
+ [1.1.3. Какие принципы есть у REST](#113-какие-принципы-есть-у-rest)
+ [1.1.4. Что такое SOAP](#114-что-такое-soap)
+ [1.1.5. Как SOAP и REST используют HTTP протокол](#115-как-soap-и-rest-используют-http-протокол)
+ [1.1.6. В каком формате должны возвращаться данные при REST и SOAP](#116-в-каком-формате-должны-возвращаться-данные-при-rest-и-soap)
+ [1.1.7. С чем работает SOAP и REST](#117-с-чем-работает-soap-и-rest)
+ [1.1.8. Когда лучше использовать SOAP](#118-когда-лучше-использовать-soap)
+ [1.1.9. Когда лучше использовать REST](#119-когда-лучше-использовать-rest)
+ [1.1.10. Как работает кеширование REST](#1110-как-работает-кеширование-rest)
+ [1.1.11. Что такое идентификатор ресурса](#1111-что-такое-идентификатор-ресурса)
+ [1.1.12. Что такое многоуровневая система](#1112-что-такое-многоуровневая-система)
+ [1.1.13. Что такое HATEOAS и как он применяется в REST](#1113-что-такое-hateoas-и-как-он-применяется-в-rest)
+ [1.1.14. Как сравнить безопасность REST и SOAP](#1114-как-сравнить-безопасность-rest-и-soap)
+ [1.1.15. Какие стратегии версионирования API существуют для REST](#1115-какие-стратегии-версионирования-api-существуют-для-rest)
+ [1.1.16. Как обрабатывать ошибки в REST и SOAP](#1116-как-обрабатывать-ошибки-в-rest-и-soap)
+ [1.1.17. Что такое идемпотентность и как она реализована в REST](#1117-что-такое-идемпотентность-и-как-она-реализована-в-rest)
+ [1.1.18. Как реализовать пагинацию в REST API](#1118-как-реализовать-пагинацию-в-rest-api)
+ [1.1.19. Сравнение REST с GraphQL и gRPC](#1119-сравнение-rest-с-graphql-и-grpc)
+ [1.1.20. Как REST применяется в микросервисной архитектуре](#1120-как-rest-применяется-в-микросервисной-архитектуре)

#### 1.1.1. Как расшифровывается REST
**REST** расшифровывается как **Representational State Transfer** (передача состояния представления).

- Запрос ресурса с сервера переводит клиентское приложение в определённое состояние (state).
- Запрос следующего ресурса изменяет состояние приложения (transfer).
- "Representational" означает, что ресурс возвращается не просто так, а в каком-то представлении (например, в формате JSON или XML), а не в исходном виде.

Пример: При запросе `/users/1`, сервер возвращает представление пользователя (данные о нём), а не сам объект в памяти сервера.

#### 1.1.2. Что такое REST
REST — это архитектурный стиль для проектирования сетевых приложений, предложенный Роем Филдингом в 2000 году. Он не является протоколом или стандартом, а набором принципов для создания масштабируемых и простых API.

#### 1.1.3. Какие принципы есть у REST
Основные принципы REST (из диссертации Роя Филдинга):

- **Give every 'thing' an ID**: Каждому ресурсу присваивается уникальный идентификатор (URI).
- **Link things together**: Ресурсы связываются гиперссылками. Например, в странице о Mercedes C218 лучше добавить ссылку на двигатель данной модели.
- **Use standard methods**: Использовать стандартные методы HTTP (GET, POST, PUT, DELETE).
- **Resources can have multiple representations**: Один и тот же ресурс можно вернуть в разных форматах (XML, JSON, HTML).
- **Communicate statelessly**: Каждый запрос независим; сервер не хранит состояние клиента между запросами. REST просто отвечает на запрос, вне зависимости от предыдущих.

#### 1.1.4. Что такое SOAP
SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями в веб-сервисах. Это семейство протоколов и стандартов, более тяжеловесный и сложный с точки зрения машинной обработки по сравнению с REST. SOAP стандартизирован (W3C) и часто используется в enterprise-средах.

#### 1.1.5. Как SOAP и REST используют HTTP протокол

- **SOAP** использует HTTP как транспортный протокол (хотя может работать и с другими, например, SMTP или TCP).
- **REST** базируется на HTTP и использует его методы, статус-коды и заголовки полностью.

В REST работают все наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование и прокси. В SOAP необходимо искать другие средства для реализации этих наработок, так как он не зависит от HTTP.

#### 1.1.6. В каком формате должны возвращаться данные при REST и SOAP
- **SOAP**: Привязан к XML (все сообщения в формате XML с обязательными элементами, такими как Envelope, Header, Body).
- **REST**: Не привязан к формату; может возвращать любой формат (JSON, XML, HTML, CSV и т.д.), в зависимости от заголовка Accept в запросе.

#### 1.1.7. С чем работает SOAP и REST
- **SOAP** работает с операциями (методами, вызовами процедур, как в RPC).
- **REST** работает с ресурсами (сущностями, доступными по URI).

Транзакции или сложная бизнес-логика должны реализовываться через SOAP, так как он поддерживает состояния и сложные взаимодействия.

#### 1.1.8. Когда лучше использовать SOAP
SOAP лучше использовать в сценариях, требующих:

- Многочисленных проверок данных, повышенной безопасности (WS-Security) и устойчивости к ошибкам.
- Сложных транзакций, где важен порядок операций и состояние (например, банковские системы, ERP).
- Стандартизации и поддержки enterprise-функций, таких как ACID-транзакции.

Пример: Интеграция с legacy-системами или в финансовых приложениях, где нужны гарантии доставки и обработки.

#### 1.1.9. Когда лучше использовать REST
REST лучше использовать для простых операций, которые независимы друг от друга (CRUD: Create, Read, Update, Delete).

- Преимущества: Легковесность, масштабируемость, простота интеграции с веб-клиентами.
- Пример: API для социальных сетей, где клиенты часто запрашивают данные о пользователях или постах.


#### 1.1.10. Как работает кеширование REST
Кеширование в REST опирается на HTTP-заголовки (например, Cache-Control, ETag, Last-Modified). Процесс:

1. Клиент отправляет запрос на сервер API (например, GET /users/1).
2. Сервер API обрабатывает запрос и генерирует ответ.
3. Сервер API добавляет заголовки к ответу, указывающие, как кэшировать ответ (например, Cache-Control: max-age=3600).
4. Клиент кэширует ответ в соответствии с инструкциями в заголовках (в браузере или прокси).
5. Когда клиент снова отправляет тот же запрос, он сначала проверяет свой кэш.
6. Если ответ найден в кэше и не устарел, клиент использует его вместо обращения к серверу API.
7. Если ответ не найден в кэше или устарел, клиент отправляет запрос на сервер.

Это повышает производительность и снижает нагрузку на сервер.

#### 1.1.11. Что такое идентификатор ресурса
**Идентификатор ресурса** (часто сокращённо URI — Uniform Resource Identifier) — это уникальная метка, которая определяет ресурс в REST API.

- Ресурс — абстрактное понятие, представляющее любой объект, доступный через API: данные (записи в базе данных, изображения, файлы) или функциональные возможности (операции, такие как создание, обновление или удаление).

**Требования к идентификатору ресурса:**

- Уникальный.
- Постоянный (не меняется со временем).
- Стабильный: должен оставаться неизменным при изменении состояния ресурса.
- Читаемый: должен быть понятным для человека и легко читаемым.

**Примеры:**

- `/users/123` — идентификатор ресурса пользователя с ID 123.
- `/images/cat.jpg` — идентификатор ресурса изображения кота.
- `/products/create` — идентификатор ресурса для создания нового продукта (хотя это больше операция).

**Использование:**

- **Доступ к ресурсам**: Используется в URL-адресах запросов для определения конкретного ресурса.
- **Фильтрация**: Может использоваться в запросах для фильтрации списка ресурсов (например, /users?age=25).
- **Ссылки**: Может использоваться в ответах для указания на связанные ресурсы (HATEOAS).

#### 1.1.12. Что такое многоуровневая система
Многоуровневая (или многослойная) система — это архитектурный принцип, который делит API на несколько уровней. Каждый уровень выполняет определённую функцию и взаимодействует только с соседними уровнями, обеспечивая разделение ответственности.

**Преимущества:**

- **Модульность:** API становится более модульным и простым в разработке и обслуживании.
- **Масштабируемость:** Каждый уровень можно масштабировать независимо, что позволяет оптимизировать API для разных типов нагрузки.
- **Повторное использование:** Компоненты API можно повторно использовать на разных уровнях.
- **Безопасность:** Разграничение уровней позволяет повысить безопасность API (например, через прокси или шлюзы).

**Основные уровни REST API:**

- **Уровень интерфейса:** Определяет, как клиент взаимодействует с API (например, API Gateway для маршрутизации).
- **Уровень приложения:** Определяет бизнес-логику API (сервер приложений, обрабатывающий запросы).
- **Уровень доступа к данным:** Определяет, как API взаимодействует с хранилищем данных (база данных или внешние сервисы).

**Пример архитектуры:**

1. **Клиент:** Веб-браузер или мобильное приложение.
2. **Уровень интерфейса:** API Gateway, который принимает запросы от клиентов и маршрутизирует их на соответствующие серверы.
3. **Уровень приложения:** Сервер приложений (например, на Node.js или Spring), который обрабатывает бизнес-логику.
4. **Уровень доступа к данным:** База данных (SQL или NoSQL), которая хранит и предоставляет данные.

#### 1.1.13. Что такое HATEOAS и как он применяется в REST
HATEOAS (Hypertext As The Engine Of Application State) — это принцип REST, который подразумевает, что клиент взаимодействует с API только через гиперссылки, предоставленные в ответах сервера. Это позволяет клиенту быть независимым от жёстко закодированных URL и делает API самоописывающимся.

**Применение:**
- В ответе API включаются ссылки на возможные действия (например, в JSON: `_links: { "self": "/users/1", "edit": "/users/1/edit" }`).
- Это полезно для senior разработчиков в микросервисах, где API эволюционируют, и клиенты должны адаптироваться динамически.

**Преимущества:** Уменьшает связанность, улучшает эволюцию API.

#### 1.1.14. Как сравнить безопасность REST и SOAP
- **REST:** Зависит от HTTP (HTTPS для шифрования), использует токены (OAuth, JWT) или базовую аутентификацию. Менее встроенных механизмов, но проще интегрировать с существующими веб-технологиями.
- **SOAP:** Имеет встроенные стандарты безопасности (WS-Security: шифрование, подписи, аутентификация). Более надёжен для enterprise, но сложнее реализовать.

**Сравнение:** SOAP лучше для строгих требований (банки), REST — для простых сценариев с HTTPS. Senior devs оценивают trade-offs: REST легче, но требует дополнительных слоёв для безопасности.

#### 1.1.15. Какие стратегии версионирования API существуют для REST
Версионирование позволяет эволюционировать API без нарушения совместимости.

- **URI versioning:** Включать версию в URL (e.g., `/v1/users`).
- **Header versioning:** Использовать заголовки (Accept: application/vnd.api.v1+json).
- **Parameter versioning:** Через query params (e.g., `/users?version=1`).
- **Media type versioning:** В Accept/Content-Type.

**Рекомендации для senior:** URI для ясности, header для чистоты URL. Рассматривать backward compatibility и deprecation policies.

#### 1.1.16. Как обрабатывать ошибки в REST и SOAP
- **REST:** Использует HTTP статус-коды (400 Bad Request, 404 Not Found, 500 Internal Server Error). Ошибки в теле ответа (JSON/XML) с деталями.
- **SOAP:** Стандартизированные fault элементы в XML (FaultCode, FaultString, Detail). Поддерживает сложные обработки ошибок.

**Best practices:** В REST — consistent error schemas; в SOAP — для enterprise, где нужны детальные faults. Senior devs фокусируются на пользовательском опыте и логировании.

#### 1.1.17. Что такое идемпотентность и как она реализована в REST
Идемпотентность — свойство, при котором повторный вызов операции даёт тот же результат, что и первый (без побочных эффектов).

**В REST:** Методы GET, PUT, DELETE идемпотентны; POST — нет. PUT для обновления ресурса гарантирует, что повторный запрос не создаст дубликаты.

**Применение:** Важно для resilient систем; senior devs используют для обработки retries в сетевых ошибках.

#### 1.1.18. Как реализовать пагинацию в REST API
Пагинация разбивает большие наборы данных на страницы для эффективности.

- **Offset-based:** `/users?offset=100&limit=50` (проблемы с производительностью при больших offset).
- **Cursor-based:** `/users?cursor=abc&limit=50` (использует курсоры из БД, лучше для больших данных).
- **Page-based:** `/users?page=2&size=50`.

**Senior considerations:** Cursor-based для NoSQL; добавлять metadata (total count, links to next/prev).

#### 1.1.19. Сравнение REST с GraphQL и gRPC
- **GraphQL:** Позволяет клиентам запрашивать точно нужные данные; schema-driven, лучше для сложных queries. Trade-off: Overhead на сервере vs. flexibility.
- **gRPC:** Бинарный протокол на HTTP/2; высокая производительность, strongly-typed с protobuf. Лучше для микросервисов, но требует генерации кода.
- **REST:** Универсален, прост, но может быть verbose для complex data fetching.

**Когда выбрать:** REST для простых CRUD; GraphQL для flexible APIs; gRPC для high-performance inter-service comms.

#### 1.1.20. Как REST применяется в микросервисной архитектуре
В микросервисах REST используется для коммуникации между сервисами: каждый сервис предоставляет REST API для ресурсов.

- **Принципы:** Stateless, scalable; API Gateway для маршрутизации.
- **Best practices:** Версионирование, HATEOAS для loose coupling; использовать async (e.g., webhooks) для event-driven.
- **Challenges:** Latency, error handling; senior devs фокусируются на circuit breakers, retries, и monitoring.

### END ---------------- 1.1. REST vs SOAP ----------------

### 1.2. HTTP
+ [1.2.1. Коды ответов](#121-коды-ответов)
+ [1.2.2. HTTP/2 vs HTTP/1.1](#122-http2-vs-http11)
+ [1.2.3. HTTP/2 vs HTTP/3](#123-http2-vs-http3)
+ [1.2.4. CSRF токен](#124-csrf-токен)
+ [1.2.5. Основные HTTP методы](#125-основные-http-методы)
+ [1.2.6. HTTP заголовки](#126-http-заголовки)
+ [1.2.7. Cookies и Sessions](#127-cookies-и-sessions)
+ [1.2.8. HTTPS и SSL/TLS](#128-https-и-ssltls)
+ [1.2.9. HTTP кеширование](#129-http-кеширование)
+ [1.2.10. CORS (Cross-Origin Resource Sharing)](#1210-cors-cross-origin-resource-sharing)
+ [1.2.11. WebSockets vs HTTP](#1211-websockets-vs-http)
+ [1.2.12. Подробно о статус-кодах](#1212-подробно-о-статус-кодах)

#### 1.2.1. Коды ответов
HTTP статус-коды — это трёхзначные числа, возвращаемые сервером в ответ на запрос клиента, указывающие на результат обработки запроса. Они разделены на классы:

- **1xx Информационные**: Указывают на промежуточный ответ. Клиент должен продолжить запрос или игнорировать ответ, если он не ожидает такого. Примеры: 100 Continue (клиент должен продолжить отправку тела запроса), 101 Switching Protocols (сервер соглашается сменить протокол).
- **2xx Успешные**: Указывают, что запрос был успешно принят и обработан. Примеры: 200 OK (запрос выполнен успешно), 201 Created (ресурс создан), 204 No Content (запрос выполнен, но тело ответа пустое).
- **3xx Перенаправления**: Указывают, что для завершения запроса требуется дополнительное действие, обычно перенаправление. Примеры: 301 Moved Permanently (ресурс перемещён навсегда), 302 Found (временное перенаправление), 304 Not Modified (ресурс не изменён, используется кеширование).
- **4xx Ошибки клиента**: Указывают на ошибку со стороны клиента. Примеры: 400 Bad Request (неверный синтаксис запроса), 401 Unauthorized (требуется аутентификация), 403 Forbidden (доступ запрещён), 404 Not Found (ресурс не найден), 429 Too Many Requests (слишком много запросов).
- **5xx Ошибки сервера**: Указывают на ошибку на стороне сервера. Примеры: 500 Internal Server Error (внутренняя ошибка сервера), 502 Bad Gateway (шлюз получил недействительный ответ), 503 Service Unavailable (сервис недоступен), 504 Gateway Timeout (таймаут шлюза).

Для junior: Запомните основные коды (200, 404, 500). Для senior: Обсудите, как обрабатывать конкретные коды в API (например, 429 для rate limiting) и их влияние на клиентскую логику.

#### 1.2.2. HTTP/2 vs HTTP/1.1
**HTTP/1.1** (стандартизирован в 1999 году) — это первая версия с поддержкой современных веб-приложений. Ключевые улучшения по сравнению с HTTP/1.0:

1. **Новые методы**:
    - PUT: Заменяет текущее представление ресурса данными из запроса.
    - DELETE: Удаляет указанный ресурс.
    - OPTIONS: Описывает параметры соединения с ресурсом (для preflight-запросов в CORS).
    - TRACE: Проверяет обратную связь по пути к целевому ресурсу (для диагностики).
    - CONNECT: Устанавливает "туннель" к серверу (используется для HTTPS через прокси).
    - PATCH: Частично обновляет ресурс (добавлен позже, в RFC 5789).

2. **Заголовки**:
    - Host: Позволяет указывать домен, с которого пришёл запрос (необходим для виртуального хостинга).
    - Keep-Alive: Поддерживает постоянные соединения по умолчанию (в HTTP/1.0 требовалось явно указывать `Connection: keep-alive`). Это снижает overhead на установку TCP-соединений для каждого запроса.

3. **Передача частями (Chunked Transfer Encoding)**: Позволяет передавать данные в потоках с помощью `Transfer-Encoding: chunked`, что полезно для динамического контента без предварительного знания размера.

**HTTP/2** (стандартизирован в 2015 году) — бинарный протокол, оптимизированный для производительности:

1. **Бинарные данные**: Передача в бинарном формате (фреймы), что уменьшает размер и повышает скорость парсинга.
2. **Мультиплексирование**: Запросы разбиваются на фреймы и потоки; один TCP-соединение обрабатывает несколько запросов параллельно, устраняя блокировку head-of-line в HTTP/1.1.
3. **Сжатие заголовков (HPACK)**: Эффективное сжатие заголовков с защитой от атак типа CRIME.
4. **Приоритизация потоков**: Клиент может присваивать веса (1-256) потокам для управления порядком обработки.
5. **Server Push**: Сервер может proactively отправлять ресурсы (например, CSS/JS) без запроса клиента.

Для junior: HTTP/2 быстрее из-за мультиплексирования. Для senior: Обсудите trade-offs (HTTP/2 требует шифрования, сложнее debug; HTTP/1.1 проще для legacy систем) и применение в CDN/API.

#### 1.2.3. HTTP/2 vs HTTP/3
HTTP/3 (на базе QUIC) — эволюция для дальнейшего улучшения производительности:

- **QUIC (Quick UDP Internet Connections)**: Использует UDP вместо TCP, что устраняет задержки из-за TCP-handshake и потери пакетов. Объединяет установку соединения и TLS-шифрование в один шаг (0-RTT handshake для повторных соединений).
- **Улучшения**: Лучшая обработка потерь пакетов, встроенное мультиплексирование без head-of-line blocking. Поддерживает миграцию соединений (например, с Wi-Fi на мобильную сеть без разрыва).

Сравнение: HTTP/2 лучше для большинства случаев; HTTP/3 — для high-latency сетей (мобильный интернет). Senior devs: Рассмотрите поддержку браузерами (HTTP/3 новее, но не везде реализован) и использование в real-time apps.

#### 1.2.4. CSRF токен
CSRF (Cross-Site Request Forgery) — атака, где злоумышленник заставляет пользователя выполнить нежелательное действие на сайте, где он аутентифицирован (например, через скрытую форму на другом сайте).

**Защита с помощью CSRF-токена**: Сервер генерирует уникальный, криптографически стойкий токен для каждой сессии/формы. Клиент включает его в запросы (в заголовке или теле). Сервер проверяет токен перед выполнением действия.

**Требования к токену**:
- Уникален для сессии/операции.
- Одноразовый или с коротким сроком жизни.
- Достаточно длинный (128+ бит) для устойчивости к brute-force.
- Генерируется CSPRNG (криптографически стойким генератором).

**Пример реализации**: В форме HTML `<input type="hidden" name="csrf_token" value="abc123">`. Для AJAX: В заголовке `X-CSRF-Token`.

Для junior: Токен предотвращает CSRF. Для senior: Обсудите альтернативы (SameSite cookies в HTTP/2), интеграцию с frameworks (e.g., Spring Security) и edge cases (SPA с JWT).

#### 1.2.5. Основные HTTP методы
HTTP методы (глаголы) определяют действие над ресурсом:

- **GET**: Получить ресурс (идемпотентный, кешируемый).
- **POST**: Создать ресурс или отправить данные (не идемпотентный).
- **PUT**: Обновить/заменить ресурс полностью (идемпотентный).
- **PATCH**: Частичное обновление (не всегда идемпотентный).
- **DELETE**: Удалить ресурс (идемпотентный).
- **HEAD**: Как GET, но без тела ответа (для проверки заголовков).
- **OPTIONS**: Узнать поддерживаемые методы/заголовки (для CORS preflight).

Для junior: CRUD — GET/POST/PUT/DELETE. Для senior: Идемпотентность (PUT vs POST), использование в REST API, и безопасность (POST для sensitive data).

#### 1.2.6. HTTP заголовки
Заголовки передают метаданные о запросе/ответе. Ключевые:

- **Request headers**: Accept (желаемый формат), Authorization (аутентификация), User-Agent (клиент).
- **Response headers**: Content-Type (тип контента), Cache-Control (кеширование), Set-Cookie (установка куки).
- **Entity headers**: Content-Length (размер тела), ETag (версия ресурса для кеширования).

Для senior: Как использовать для оптимизации (e.g., gzip с Accept-Encoding), безопасности (Strict-Transport-Security) и debugging.

#### 1.2.7. Cookies и Sessions
- **Cookies**: Маленькие текстовые файлы, хранящиеся на клиенте. Сервер устанавливает через Set-Cookie. Используются для сессий, предпочтений. Недостатки: Видимы клиенту, могут быть украдены.
- **Sessions**: Серверная сторона; ID сессии хранится в cookie, данные — на сервере. Более безопасно для sensitive data.

Для junior: Cookies для хранения состояния. Для senior: Trade-offs (stateless vs stateful), JWT vs sessions, и CSRF-защита.

#### 1.2.8. HTTPS и SSL/TLS
HTTPS — HTTP over SSL/TLS, шифрует трафик для защиты от MITM-атак.

- **SSL/TLS handshake**: Обмен ключами, сертификатами для установления шифрованного канала.
- **Преимущества**: Шифрование, аутентификация сервера, integrity.

Для senior: Certificate pinning, HSTS, и влияние на performance (overhead на handshake).

#### 1.2.9. HTTP кеширование
Кеширование снижает нагрузку: браузер/прокси хранит ответы.

- **Типы**: Browser cache, CDN, proxy.
- **Заголовки**: Cache-Control (max-age), ETag (conditional requests), Last-Modified.

Для senior: Cache invalidation strategies, Vary header для разных представлений.

#### 1.2.10. CORS (Cross-Origin Resource Sharing)
CORS позволяет браузерам делать cross-origin запросы. Сервер отвечает заголовками (Access-Control-Allow-Origin).

- **Preflight**: OPTIONS для complex requests.
- **Проблемы**: Без CORS — blocked by SOP.

Для senior: Настройка в API Gateway, handling credentials.

#### 1.2.11. WebSockets vs HTTP
- **HTTP**: Request-response, stateless.
- **WebSockets**: Full-duplex, persistent connection для real-time (chat, games).

Для senior: Когда использовать (WebSockets для low-latency), fallback to polling.

#### 1.2.12. Подробно о статус-кодах
Расширение 1.2.1: Примеры использования в backend.

- 201 для POST success.
- 409 Conflict для duplicate resources.
- Senior: Custom codes (e.g., 422 Unprocessable Entity для validation errors) и их роль в API design.

### END ---------------- 1.2. HTTP ----------------

## END ---------------- 1. Протоколы ----------------

## 2. Java

+ [2.1. Основы](#21-основы)
  <details>
    <summary>Навигация</summary>

  + [2.1.1. Какие преимущества у Java?](#211-какие-преимущества-у-java)
  + [2.1.2. Какие недостатки у Java?](#212-какие-недостатки-у-java)
  + [2.1.3. Что такое JVM, JDK, JRE? В чем отличия?](#213-что-такое-jvm-jdk-jre-в-чем-отличия)
  + [2.1.4. Что такое byte code?](#214-что-такое-byte-code)
  + [2.1.5. Что такое загрузчик классов (ClassLoader)?](#215-что-такое-загрузчик-классов-classloader)
  + [2.1.6. Что такое JIT-компилятор?](#216-что-такое-jit-компилятор)
  + [2.1.7. Что такое String[] args в методе main()?](#217-что-такое-string-args-в-методе-main)
  + [2.1.8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?](#218-что-такое-пакеты-зачем-они-нужны-какие-пакеты-по-умолчанию-подключены)
  + [2.1.9. Какой дефолтный модификатор доступа у класса?](#219-какой-дефолтный-модификатор-доступа-у-класса)
  + [2.1.10. Какие типы принимает System.out.println()?](#2110-какие-типы-принимает-systemoutprintln)
  + [2.1.11. Что такое модули в Java (JPMS)?](#2111-что-такое-модули-в-java-jpms)
  + [2.1.12. В чем разница между JAR, WAR и EAR?](#2112-в-чем-разница-между-jar-war-и-ear)
  + [2.1.13. Что такое Java Memory Model (JMM)?](#2113-что-такое-java-memory-model-jmm)
  + [2.1.14. Как работает сборщик мусора (GC) в Java? Какие алгоритмы используются?](#2114-как-работает-сборщик-мусора-gc-в-java-какие-алгоритмы-используются)
  </details>

+ [2.2. Примитивные типы, строки и базовые структуры](#22-примитивные-типы-строки-и-базовые-структуры)
  <details>
    <summary>Навигация</summary>

  + [2.2.1. Какие примитивные типы данных есть в Java?](#221-какие-примитивные-типы-данных-есть-в-java)
  + [2.2.2. Какими значениями по умолчанию инициализируются поля примитивных типов данных?](#222-какими-значениями-по-умолчанию-инициализируются-поля-примитивных-типов-данных)
  + [2.2.3. Что такое автоупаковка и автораспаковка?](#223-что-такое-автоупаковка-и-автораспаковка)
  + [2.2.4. Что такое классы-обертки (Wrapper classes)?](#224-что-такое-классы-обертки-wrapper-classes)
  + [2.2.5. Что такое приведение типов (cast)?](#225-что-такое-приведение-типов-cast)
  + [2.2.6. Что такое пул интов (Integer pool)?](#226-что-такое-пул-интов-integer-pool)
  + [2.2.7. Какие нюансы у строк в Java?](#227-какие-нюансы-у-строк-в-java)
  + [2.2.8. Что такое пул строк (String pool)?](#228-что-такое-пул-строк-string-pool)
  + [2.2.9. Почему строки не рекомендуется использовать для хранения паролей?](#229-почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
  + [2.2.10. Почему класс String неизменяемый (immutable) и final?](#2210-почему-класс-string-неизменяемый-immutable-и-final)
  + [2.2.11. Что делает метод intern() в классе String?](#2211-что-делает-метод-intern-в-классе-string)
  + [2.2.12. Можно ли использовать строки в конструкции switch?](#2212-можно-ли-использовать-строки-в-конструкции-switch)
  + [2.2.13. Что такое инвариантность, ковариантность и контравариантность в контексте дженериков?](#2213-что-такое-инвариантность-ковариантность-и-контравариантность-в-контексте-дженериков)
  + [2.2.14. В чем разница между String, StringBuffer и StringBuilder?](#2214-в-чем-разница-между-string-stringbuffer-и-stringbuilder)
  + [2.2.15. Каким образом переменные передаются в методы (pass-by-value vs pass-by-reference)?](#2215-каким-образом-переменные-передаются-в-методы-pass-by-value-vs-pass-by-reference)
  + [2.2.16. В чем разница между Hashtable и HashMap?](#2216-в-чем-разница-между-hashtable-и-hashmap)
  + [2.2.17. Как ограничить upper bounding типа-параметра в дженериках?](#2217-как-ограничить-upper-bounding-типа-параметра-в-дженериках)
  + [2.2.18. Сколько может быть стеков в JVM?](#2218-сколько-может-быть-стеков-в-jvm)
  + [2.2.19. Какие классы могут быть статическими (static nested classes)?](#2219-какие-классы-могут-быть-статическими-static-nested-classes)
  + [2.2.20. Что такое финальный класс (final class)?](#2220-что-такое-финальный-класс-final-class)
  + [2.2.21. Что такое поверхностное копирование (shallow copy)?](#2221-что-такое-поверхностное-копирование-shallow-copy)
  + [2.2.22. Что такое глубокое копирование (deep copy)?](#2222-что-такое-глубокое-копирование-deep-copy)
  + [2.2.23. Какие иммутабельные классы есть в Java?](#2223-какие-иммутабельные-классы-есть-в-java)
  + [2.2.24. Как проверить значение на null в Java 8+ (Optional, etc.)?](#2224-как-проверить-значение-на-null-в-java-8-optional-etc)
  + [2.2.25. Что такое var в Java 10+ и когда его использовать?](#2225-что-такое-var-в-java-10-и-когда-его-использовать)
  </details>

+ [2.3. Потоки ввода/вывода (I/O)](#23-потоки-вводавывода-io)
  <details>
      <summary>Навигация</summary>

    + [2.3.1. Что такое потоки ввода/вывода в Java?](#231-что-такое-потоки-вводавывода-в-java)
    + [2.3.2. Какие виды потоков существуют (byte vs character streams)?](#232-какие-виды-потоков-существуют-byte-vs-character-streams)
    + [2.3.3. Что такое класс InputStream?](#233-что-такое-класс-inputstream)
    + [2.3.4. Что такое класс OutputStream?](#234-что-такое-класс-outputstream)
    + [2.3.5. Какие классы наследуются от базовых классов InputStream и OutputStream?](#235-какие-классы-наследуются-от-базовых-классов-inputstream-и-outputstream)
    + [2.3.6. Что такое класс File для работы с файловой системой?](#236-что-такое-класс-file-для-работы-с-файловой-системой)
    + [2.3.7. В чем разница между FileInputStream и FileReader?](#237-в-чем-разница-между-fileinputstream-и-filereader)
    + [2.3.8. Как работает NIO (New I/O) в Java? Что такое Channels и Buffers?](#238-как-работает-nio-new-io-в-java-что-такое-channels-и-buffers)
    + [2.3.9. Что такое Path и Files в java.nio.file?](#239-что-такое-path-и-files-в-javaniofile)
    + [2.3.10. Как обрабатывать большие файлы без загрузки в память (streaming)?](#2310-как-обрабатывать-большие-файлы-без-загрузки-в-память-streaming)
  </details>

+ [2.4. Объектно-ориентированное программирование (ООП)](#24-объектно-ориентированное-программирование-ооп)
  <details>
      <summary>Навигация</summary>

    + [2.4.1. Какие принципы ООП поддерживает Java (инкапсуляция, наследование, полиморфизм, абстракция)?](#241-какие-принципы-ооп-поддерживает-java-инкапсуляция-наследование-полиморфизм-абстракция)
    + [2.4.2. Что такое вложенные классы? В каких случаях они применяются?](#242-что-такое-вложенные-классы-в-каких-случаях-они-применяются)
    + [2.4.3. Что такое локальный класс? Каковы его особенности?](#243-что-такое-локальный-класс-каковы-его-особенности)
    + [2.4.4. Что такое анонимные классы? Где они применяются?](#244-что-такое-анонимные-классы-где-они-применяются)
    + [2.4.5. Каким образом из вложенного класса получить доступ к полю внешнего класса?](#245-каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
    + [2.4.6. Что такое перечисления (enum)?](#246-что-такое-перечисления-enum)
    + [2.4.7. Как проблема ромбовидного наследования решена в Java (default methods)?](#247-как-проблема-ромбовидного-наследования-решена-в-java-default-methods)
    + [2.4.8. Что такое конструктор по умолчанию?](#248-что-такое-конструктор-по-умолчанию)
    + [2.4.9. Могут ли быть приватные конструкторы? Для чего они нужны?](#249-могут-ли-быть-приватные-конструкторы-для-чего-они-нужны)
    + [2.4.10. Чем отличаются конструктор по умолчанию, конструктор копирования и конструктор с параметрами?](#2410-чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
    + [2.4.11. Какие модификаторы доступа вы знаете? Расскажите про каждый из них.](#2411-какие-модификаторы-доступа-вы-знаете-расскажите-про-каждый-из-них)
    + [2.4.12. Что означает модификатор static?](#2412-что-означает-модификатор-static)
    + [2.4.13. Могут ли нестатические методы перегрузить статические?](#2413-могут-ли-нестатические-методы-перегрузить-статические)
    + [2.4.14. Могут ли быть переопределены статические методы?](#2414-могут-ли-быть-переопределены-статические-методы)
    + [2.4.15. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?](#2415-можно-ли-сузить-уровень-доступа-или-тип-возвращаемого-значения-при-переопределении-метода)
    + [2.4.16. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы?](#2416-что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы)
    + [2.4.17. Что такое сигнатура метода?](#2417-что-такое-сигнатура-метода)
    + [2.4.18. Что такое переопределение (overriding) и перегрузка (overloading) методов?](#2418-что-такое-переопределение-overriding-и-перегрузка-overloading-методов)
    + [2.4.19. Когда вызывается конструктор?](#2419-когда-вызывается-конструктор)
    + [2.4.20. Что означает ключевое слово final?](#2420-что-означает-ключевое-слово-final)
    + [2.4.21. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?](#2421-могут-ли-быть-конструкторы-у-абстрактных-классов-зачем-они-нужны)
    + [2.4.22. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#2422-что-такое-интерфейсы-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
    + [2.4.23. Может ли интерфейс наследоваться от другого интерфейса?](#2423-может-ли-интерфейс-наследоваться-от-другого-интерфейса)
    + [2.4.24. Что такое дефолтные методы (default methods) в интерфейсах?](#2424-что-такое-дефолтные-методы-default-methods-в-интерфейсах)
    + [2.4.25. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default-методами?](#2425-как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-с-default-методами)
    + [2.4.26. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?](#2426-каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учетом-иерархии-классов)
    + [2.4.27. Какие бывают блоки инициализации и зачем они нужны?](#2427-какие-бывают-блоки-инициализации-и-зачем-они-нужны)
    + [2.4.28. Каков порядок вызова конструкторов и блоков инициализации для класса-потомка и его предка?](#2428-каков-порядок-вызова-конструкторов-и-блоков-инициализации-для-класса-потомка-и-его-предка)
    + [2.4.29. Что произойдет, если в блоке инициализации возникнет ошибка?](#2429-что-произойдет-если-в-блоке-инициализации-возникнет-ошибка)
    + [2.4.30. Какие методы есть у класса Object?](#2430-какие-методы-есть-у-класса-object)
    + [2.4.31. Что такое метод equals()? Чем он отличается от операции ==?](#2431-что-такое-метод-equals-чем-он-отличается-от-операции-)
    + [2.4.32. Каким образом реализованы методы equals() и hashCode() в Object?](#2432-каким-образом-реализованы-методы-equals-и-hashcode-в-object)
    + [2.4.33. Какие правила переопределения equals()?](#2433-какие-правила-переопределения-equals)
    + [2.4.34. Какие правила переопределения hashCode()?](#2434-какие-правила-переопределения-hashcode)
    + [2.4.35. Могут ли у разных объектов быть одинаковые hashCode()?](#2435-могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
    + [2.4.36. Чем a.getClass().equals(A.class) отличается от instanceof A?](#2436-чем-agetclassequalsaclass-отличается-от-instanceof-a)
    + [2.4.37. Может ли метод быть одновременно abstract и final?](#2437-может-ли-метод-быть-одновременно-abstract-и-final)
    + [2.4.38. Что такое функциональные интерфейсы?](#2438-что-такое-функциональные-интерфейсы)
    + [2.4.39. Как связаны equals() и hashCode()? Можно ли их использовать по отдельности?](#2439-как-связаны-equals-и-hashcode-можно-ли-их-использовать-по-отдельности)
    + [2.4.40. Какая дефолтная реализация equals() в Object?](#2440-какая-дефолтная-реализация-equals-в-object)
    + [2.4.41. Какие есть способы глубокого копирования объекта?](#2441-какие-есть-способы-глубокого-копирования-объекта)
    + [2.4.42. Как избежать ромбовидного наследования в Java?](#2442-как-избежать-ромбовидного-наследования-в-java)
    + [2.4.43. Что такое sealed classes в Java 17?](#2443-что-такое-sealed-classes-в-java-17)
  </details>

+ [2.5. Исключения (Exceptions)](#25-исключения-exceptions)
  <details>
      <summary>Навигация</summary>

    + [2.5.1. Опишите иерархию исключений в Java.](#251-опишите-иерархию-исключений-в-java)
    + [2.5.2. Чем отличается Error от Exception?](#252-чем-отличается-error-от-exception)
    + [2.5.3. Расскажите про checked (обрабатываемые) и unchecked (необрабатываемые) исключения.](#253-расскажите-про-checked-обрабатываемые-и-unchecked-необрабатываемые-исключения)
    + [2.5.4. Какой оператор позволяет принудительно выбросить исключение (throw)?](#254-какой-оператор-позволяет-принудительно-выбросить-исключение-throw)
    + [2.5.5. Как создать собственное (пользовательское) исключение?](#255-как-создать-собственное-пользовательское-исключение)
    + [2.5.6. В каком случае не выполнится блок finally?](#256-в-каком-случае-не-выполнится-блок-finally)
    + [2.5.7. Может ли метод main() выбросить исключение наружу?](#257-может-ли-метод-main-выбросить-исключение-наружу)
    + [2.5.8. В каком порядке следует обрабатывать исключения в catch-блоках?](#258-в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
    + [2.5.9. Что такое try-with-resources?](#259-что-такое-try-with-resources)
    + [2.5.10. Что необходимо реализовать для работы try-with-resources (AutoCloseable)?](#2510-что-необходимо-реализовать-для-работы-try-with-resources-autocloseable)
    + [2.5.11. Что произойдет, если исключение будет выброшено из блока catch, а затем другое — из finally?](#2511-что-произойдет-если-исключение-будет-выброшено-из-блока-catch-а-затем-другое--из-finally)
    + [2.5.12. Можно ли использовать checked-исключения в лямбда-выражениях?](#2512-можно-ли-использовать-checked-исключения-в-лямбда-выражениях)
    + [2.5.13. Как определить причину OutOfMemoryError?](#2513-как-определить-причину-outofmemoryerror)
    + [2.5.14. Что такое suppressed exceptions в Java?](#2514-что-такое-suppressed-exceptions-в-java)
    + [2.5.15. Как правильно логировать исключения в production-коде?](#2515-как-правильно-логировать-исключения-в-production-коде)
  </details>

+ [2.6. Сериализация и копирование](#26-сериализация-и-копирование)
  <details>
      <summary>Навигация</summary>

    + [2.6.1. Что такое сериализация и как она реализована в Java?](#261-что-такое-сериализация-и-как-она-реализована-в-java)
    + [2.6.2. Для чего нужна сериализация?](#262-для-чего-нужна-сериализация)
    + [2.6.3. Опишите процесс сериализации/десериализации с использованием Serializable.](#263-опишите-процесс-сериализациидесериализации-с-использованием-serializable)
    + [2.6.4. Какие поля не будут сериализованы при сериализации (transient)?](#264-какие-поля-не-будут-сериализованы-при-сериализации-transient)
    + [2.6.5. Как изменить стандартное поведение сериализации/десериализации (readObject, writeObject)?](#265-как-изменить-стандартное-поведение-сериализациидесериализации-readobject-writeobject)
    + [2.6.6. Как создать собственный протокол сериализации (Externalizable)?](#266-как-создать-собственный-протокол-сериализации-externalizable)
    + [2.6.7. В чем проблема сериализации Singleton? Как ее решить?](#267-в-чем-проблема-сериализации-singleton-как-ее-решить)
    + [2.6.8. Как происходит десериализация? Что такое serialVersionUID?](#268-как-происходит-десериализация-что-такое-serialversionuid)
    + [2.6.9. В чем разница между Serializable и Externalizable?](#269-в-чем-разница-между-serializable-и-externalizable)
    + [2.6.10. Какие проблемы безопасности связаны с десериализацией?](#2610-какие-проблемы-безопасности-связаны-с-десериализацией)
  </details>

+ [2.7. Дженерики (Generics)](#27-дженерики-generics)
  <details>
      <summary>Навигация</summary>

    + [2.7.1. Что такое дженерики в Java?](#271-что-такое-дженерики-в-java)
    + [2.7.2. Зачем нужны дженерики? Какие проблемы они решают?](#272-зачем-нужны-дженерики-какие-проблемы-они-решают)
    + [2.7.3. Что такое типовая эрасура (type erasure)?](#273-что-такое-типовая-эрасура-type-erasure)
    + [2.7.4. В чем разница между bounded и unbounded wildcards?](#274-в-чем-разница-между-bounded-и-unbounded-wildcards)
    + [2.7.5. Что такое PECS (Producer Extends, Consumer Super)?](#275-что-такое-pecs-producer-extends-consumer-super)
    + [2.7.6. Можно ли использовать примитивные типы в дженериках?](#276-можно-ли-использовать-примитивные-типы-в-дженериках)
    + [2.7.7. Что такое рекурсивные дженерики?](#277-что-такое-рекурсивные-дженерики)
    + [2.7.8. Как работает super в дженериках?](#278-как-работает-super-в-дженериках)
  </details>

### 2.1. Основы

+ [2.1.1. Какие преимущества у Java?](#211-какие-преимущества-у-java)
+ [2.1.2. Какие недостатки у Java?](#212-какие-недостатки-у-java)
+ [2.1.3. Что такое JVM, JDK, JRE? В чем отличия?](#213-что-такое-jvm-jdk-jre-в-чем-отличия)
+ [2.1.4. Что такое byte code?](#214-что-такое-byte-code)
+ [2.1.5. Что такое загрузчик классов (ClassLoader)?](#215-что-такое-загрузчик-классов-classloader)
+ [2.1.6. Что такое JIT-компилятор?](#216-что-такое-jit-компилятор)
+ [2.1.7. Что такое String[] args в методе main()?](#217-что-такое-string-args-в-методе-main)
+ [2.1.8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?](#218-что-такое-пакеты-зачем-они-нужны-какие-пакеты-по-умолчанию-подключены)
+ [2.1.9. Какой дефолтный модификатор доступа у класса?](#219-какой-дефолтный-модификатор-доступа-у-класса)
+ [2.1.10. Какие типы принимает System.out.println()?](#2110-какие-типы-принимает-systemoutprintln)
+ [2.1.11. Что такое модули в Java (JPMS)?](#2111-что-такое-модули-в-java-jpms)
+ [2.1.12. В чем разница между JAR, WAR и EAR?](#2112-в-чем-разница-между-jar-war-и-ear)
+ [2.1.13. Что такое Java Memory Model (JMM)?](#2113-что-такое-java-memory-model-jmm)
+ [2.1.14. Как работает сборщик мусора (GC) в Java? Какие алгоритмы используются?](#2114-как-работает-сборщик-мусора-gc-в-java-какие-алгоритмы-используются)

#### 2.1.1. Какие преимущества у Java?
- **Кроссплатформенность**: Благодаря JVM программы на Java могут работать на любой платформе без изменений ("Write once, run anywhere").
- **Автоматическое управление памятью**: Сборщик мусора (Garbage Collector) освобождает разработчиков от ручного управления памятью, снижая риски утечек.
- **Многопоточность**: Встроенная поддержка многопоточности через классы Thread и Executor Framework упрощает разработку параллельных приложений.
- **Объектно-ориентированное программирование (ООП)**: Полная поддержка принципов ООП (инкапсуляция, наследование, полиморфизм, абстракция), что способствует модульности и переиспользованию кода.
- **Огромная экосистема**: Широкий выбор библиотек (например, Spring, Hibernate), фреймворков и инструментов для решения разнообразных задач, от веб-разработки до big data.
- **Безопасность**: Встроенные механизмы безопасности, такие как песочница (sandbox) для апплетов и контроль доступа.
- **Сообщество и поддержка**: Активное сообщество, регулярные обновления и долгосрочная поддержка от Oracle.

#### 2.1.2. Какие недостатки у Java?
- **Производительность**: Низкая скорость выполнения по сравнению с языками вроде C++ или C, из-за интерпретации байт-кода и накладных расходов JVM.
- **Потребление памяти**: Требует значительного объема памяти из-за JVM и автоматического управления памятью.
- **Отсутствие низкоуровневого программирования**: Нет прямого доступа к указателям и низкоуровневым операциям, что ограничивает возможности в системном программировании.
- **Многословность (verbosity)**: Код часто бывает более verbose по сравнению с динамическими языками, что увеличивает время разработки.
- **Время запуска приложений**: Дольше, чем у нативных приложений, из-за загрузки JVM и классов.
- **Сложность в некоторых сценариях**: Для простых скриптов или прототипов может быть избыточной.

#### 2.1.3. Что такое JVM, JDK, JRE? В чем отличия?
- **JVM (Java Virtual Machine)**: Это виртуальная машина, которая исполняет байт-код Java. Она обеспечивает кроссплатформенность, интерпретируя или компилируя байт-код в машинный код для конкретной платформы. JVM включает JIT-компилятор, сборщик мусора и другие компоненты.
- **JRE (Java Runtime Environment)**: Это среда выполнения, содержащая JVM и стандартные библиотеки Java (например, java.lang, java.util). JRE позволяет запускать скомпилированные Java-приложения, но не создавать их.
- **JDK (Java Development Kit)**: Это комплект для разработки, включающий JRE, компилятор (javac), отладчик, архиватор и другие инструменты. JDK = JRE + инструменты для разработки.

Отличия: JVM — это только исполнительная часть; JRE — среда для запуска приложений; JDK — полный набор для разработки и запуска.

#### 2.1.4. Что такое byte code?
Байт-код — это промежуточное представление программы на Java, скомпилированное из исходного кода (.java) в бинарный формат (.class). Он состоит из инструкций для JVM, что позволяет программе быть кроссплатформенной. Байт-код не является машинным кодом для конкретного процессора, а интерпретируется или компилируется JIT-компилятором в реальном времени.

#### 2.1.5. Что такое загрузчик классов (ClassLoader)?
ClassLoader — это абстрактный класс в Java, отвечающий за динамическую загрузку классов в JVM во время выполнения. Он находит и загружает .class файлы из различных источников (файловая система, сеть, JAR-архивы). Существуют встроенные загрузчики: Bootstrap ClassLoader (загружает core-классы из rt.jar), Extension ClassLoader и System ClassLoader. ClassLoader обеспечивает безопасность и изоляцию классов.

#### 2.1.6. Что такое JIT-компилятор?
JIT (Just-In-Time) компилятор — это компонент JVM, который компилирует байт-код в машинный код во время выполнения программы. Он анализирует часто выполняемые участки кода (hotspots) и оптимизирует их для повышения производительности. Преимущество: ускорение работы за счет кэширования скомпилированного кода, но с увеличением потребления памяти.

#### 2.1.7. Что такое String[] args в методе main()?
String[] args — это массив строковых аргументов, передаваемых в метод main() из командной строки при запуске программы. Например, команда `java MyClass arg1 arg2` передаст ["arg1", "arg2"] в args. Это позволяет программе принимать параметры запуска, такие как конфигурационные файлы или флаги.

#### 2.1.8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
Пакеты — это механизм группировки связанных классов, интерфейсов и подпакетов для организации кода и предотвращения конфликтов имен. Они обеспечивают пространство имен, инкапсуляцию и контроль доступа. Например, классы в пакете com.example не конфликтуют с классами в другом пакете.

По умолчанию подключен пакет java.lang (содержит фундаментальные классы вроде Object, String, System), а также java.util и другие, но не все — импорт требуется для большинства.

#### 2.1.9. Какой дефолтный модификатор доступа у класса?
Дефолтный модификатор доступа для класса — package-private (без ключевого слова). Это означает, что класс доступен только внутри своего пакета, но не за его пределами.

#### 2.1.10. Какие типы принимает System.out.println()?
System.out.println() принимает любой объект или примитивный тип. Для примитивов (int, double и т.д.) выводится их строковое представление. Для объектов вызывается метод toString() (если не переопределен, используется Object.toString()). Также принимает массивы и коллекции, но для них toString() может выводить нечитаемые данные (например, [I@hash для int[]).

#### 2.1.11. Что такое модули в Java (JPMS)?
JPMS (Java Platform Module System) — это система модулей, введенная в Java 9 для улучшения структуры приложений, инкапсуляции и управления зависимостями. Модули группируют пакеты и определяют, какие из них экспортируются (доступны извне) или требуют импорта. Пример: module com.example { exports com.example.api; requires java.sql; }. Это решает проблемы classpath hell и повышает безопасность.

#### 2.1.12. В чем разница между JAR, WAR и EAR?
- **JAR (Java Archive)**: Стандартный архив для упаковки Java-классов, ресурсов и метаданных. Используется для библиотек или standalone-приложений. Запускается через java -jar.
- **WAR (Web Archive)**: Специализированный JAR для веб-приложений, содержащий сервлеты, JSP, HTML и дескриптор web.xml. Развертывается на серверах вроде Tomcat.
- **EAR (Enterprise Archive)**: Архив для enterprise-приложений, содержащий один или несколько WAR/JAR и конфигурационные файлы. Используется в J2EE-серверах (например, JBoss) для сложных многомодульных приложений.

Основное отличие: JAR — общий, WAR — веб, EAR — enterprise-уровень.

#### 2.1.13. Что такое Java Memory Model (JMM)?
JMM (Java Memory Model) — это спецификация, определяющая, как JVM работает с памятью в многопоточных приложениях. Она описывает правила видимости и упорядоченности операций с переменными, синхронизации и volatile. JMM обеспечивает thread-safety, предотвращая race conditions, и основана на концепциях happens-before и memory barriers.

#### 2.1.14. Как работает сборщик мусора (GC) в Java? Какие алгоритмы используются?
GC автоматически освобождает память от неиспользуемых объектов. Он работает в фоне, отслеживая ссылки и удаляя объекты без ссылок. Основные алгоритмы:
- **Mark-and-Sweep**: Помечает живые объекты и очищает остальные.
- **Generational GC (G1, CMS)**: Делит heap на поколения (young, old, perm). Молодые объекты очищаются чаще.
- **G1 (Garbage-First)**: Разделяет heap на регионы, очищает наиболее "мусорные" первыми.
- **ZGC/Shenandoah**: Низколатентные GC для больших heap.

GC можно настраивать через флаги JVM (например, -XX:+UseG1GC).

## END ---------------- 2.1. Основы ----------------

### 2.2. Примитивные типы, строки и базовые структуры

+ [2.2.1. Какие примитивные типы данных есть в Java?](#221-какие-примитивные-типы-данных-есть-в-java)
+ [2.2.2. Какими значениями по умолчанию инициализируются поля примитивных типов данных?](#222-какими-значениями-по-умолчанию-инициализируются-поля-примитивных-типов-данных)
+ [2.2.3. Что такое автоупаковка и автораспаковка?](#223-что-такое-автоупаковка-и-автораспаковка)
+ [2.2.4. Что такое классы-обертки (Wrapper classes)?](#224-что-такое-классы-обертки-wrapper-classes)
+ [2.2.5. Что такое приведение типов (cast)?](#225-что-такое-приведение-типов-cast)
+ [2.2.6. Что такое пул интов (Integer pool)?](#226-что-такое-пул-интов-integer-pool)
+ [2.2.7. Какие нюансы у строк в Java?](#227-какие-нюансы-у-строк-в-java)
+ [2.2.8. Что такое пул строк (String pool)?](#228-что-такое-пул-строк-string-pool)
+ [2.2.9. Почему строки не рекомендуется использовать для хранения паролей?](#229-почему-строки-не-рекомендуется-использовать-для-хранения-паролей)
+ [2.2.10. Почему класс String неизменяемый (immutable) и final?](#2210-почему-класс-string-неизменяемый-immutable-и-final)
+ [2.2.11. Что делает метод intern() в классе String?](#2211-что-делает-метод-intern-в-классе-string)
+ [2.2.12. Можно ли использовать строки в конструкции switch?](#2212-можно-ли-использовать-строки-в-конструкции-switch)
+ [2.2.13. Что такое инвариантность, ковариантность и контравариантность в контексте дженериков?](#2213-что-такое-инвариантность-ковариантность-и-контравариантность-в-контексте-дженериков)
+ [2.2.14. В чем разница между String, StringBuffer и StringBuilder?](#2214-в-чем-разница-между-string-stringbuffer-и-stringbuilder)
+ [2.2.15. Каким образом переменные передаются в методы (pass-by-value vs pass-by-reference)?](#2215-каким-образом-переменные-передаются-в-методы-pass-by-value-vs-pass-by-reference)
+ [2.2.16. В чем разница между Hashtable и HashMap?](#2216-в-чем-разница-между-hashtable-и-hashmap)
+ [2.2.17. Как ограничить upper bounding типа-параметра в дженериках?](#2217-как-ограничить-upper-bounding-типа-параметра-в-дженериках)
+ [2.2.18. Сколько может быть стеков в JVM?](#2218-сколько-может-быть-стеков-в-jvm)
+ [2.2.19. Какие классы могут быть статическими (static nested classes)?](#2219-какие-классы-могут-быть-статическими-static-nested-classes)
+ [2.2.20. Что такое финальный класс (final class)?](#2220-что-такое-финальный-класс-final-class)
+ [2.2.21. Что такое поверхностное копирование (shallow copy)?](#2221-что-такое-поверхностное-копирование-shallow-copy)
+ [2.2.22. Что такое глубокое копирование (deep copy)?](#2222-что-такое-глубокое-копирование-deep-copy)
+ [2.2.23. Какие иммутабельные классы есть в Java?](#2223-какие-иммутабельные-классы-есть-в-java)
+ [2.2.24. Как проверить значение на null в Java 8+ (Optional, etc.)?](#2224-как-проверить-значение-на-null-в-java-8-optional-etc)
+ [2.2.25. Что такое var в Java 10+ и когда его использовать?](#2225-что-такое-var-в-java-10-и-когда-его-использовать)

#### 2.2.1. Какие примитивные типы данных есть в Java?
В Java есть 8 примитивных типов данных. Они не являются объектами и хранятся в стеке. Вот таблица с описанием:

| Тип     | Размер в байтах | Диапазон значений                  | Значение по умолчанию | Описание |
|---------|-----------------|------------------------------------|-----------------------|----------|
| byte    | 1               | -128 .. 127                        | 0                     | Целое число, один байт |
| short   | 2               | -32,768 .. 32,767                  | 0                     | Целое число, два байта |
| int     | 4               | -2,147,483,648 .. 2,147,483,647    | 0                     | Целое число, четыре байта (стандарт для целых) |
| long    | 8               | -9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807 | 0L | Длинное целое, восемь байт |
| float   | 4               | ±1.4e-45 .. ±3.4e38                | 0.0f                  | Число с плавающей точкой, четыре байта |
| double  | 8               | ±4.9e-324 .. ±1.8e308              | 0.0d                  | Число с плавающей точкой двойной точности, восемь байт |
| boolean | 1 (зависит от JVM)| true, false                         | false                 | Логический тип |
| char    | 2               | 0 .. 65,535 (Unicode)              | '\u0000'              | Символ Unicode, два байта |

Примечание: Для float и double есть специальные значения, такие как NaN (Not a Number), положительная и отрицательная бесконечность.

#### 2.2.2. Какими значениями по умолчанию инициализируются поля примитивных типов данных?
- Числовые типы (byte, short, int, long, float, double) и char: 0 (для float и double — 0.0, для char — '\u0000').
- boolean: false.

Это применяется к полям классов, если они не инициализированы явно. Локальные переменные должны быть инициализированы перед использованием.

#### 2.2.3. Что такое автоупаковка и автораспаковка?
- **Автоупаковка (autoboxing)**: Автоматическое преобразование примитивного типа в соответствующий класс-обёртку. Например, int в Integer.
- **Автораспаковка (auto-unboxing)**: Автоматическое извлечение примитивного значения из объекта-обёртки. Например, Integer в int.

Это упрощает работу с коллекциями и дженериками, введено в Java 5. Пример: `List<Integer> list = new ArrayList<>(); list.add(5);` (5 автоупаковывается в Integer).

#### 2.2.4. Что такое классы-обертки (Wrapper classes)?
Классы-обёртки — это immutable классы, представляющие примитивные типы как объекты. Они позволяют использовать примитивы в коллекциях и предоставляют методы для работы с ними.

Основные:
- byte → Byte
- short → Short
- int → Integer
- long → Long
- float → Float
- double → Double
- boolean → Boolean
- char → Character

Они имеют методы вроде parseInt(), valueOf(), и поддерживают null (в отличие от примитивов).

#### 2.2.5. Что такое приведение типов (cast)?
Приведение типов (type casting) — это явное преобразование одного типа в другой. Для примитивов: сужающее (например, double в int, может потерять данные) или расширяющее (int в long, безопасно). Для объектов: upcasting (подкласс в суперкласс) или downcasting (суперкласс в подкласс, требует проверки).

Пример: `int x = (int) 3.14;` (сужение).

#### 2.2.6. Что такое пул интов (Integer pool)?
Integer pool (или Integer cache) — это кэш объектов Integer для значений от -128 до 127. При автоупаковке этих значений возвращается один и тот же объект из пула, что экономит память. Для значений вне диапазона создаются новые объекты.

Пример: `Integer a = 100; Integer b = 100;` — a == b (true), но для 200 — false.

#### 2.2.7. Какие нюансы у строк в Java?
- String — immutable и final класс.
- Реализует Serializable, Comparable<String> и CharSequence.
- Хранится в heap или string pool.
- Операции вроде concat создают новый объект.
- Потокобезопасен благодаря неизменности.
- Метод toString() возвращает саму строку.

Нюансы: сравнивать через equals(), не == (для ссылок).

#### 2.2.8. Что такое пул строк (String pool)?
String pool — это область в heap для хранения уникальных строк. При создании строки через литералы ("hello") она помещается в пул; если такая уже есть, возвращается ссылка. Это экономит память благодаря неизменности.

Оператор new создаёт объект вне пула. Метод intern() добавляет строку в пул.

#### 2.2.9. Почему строки не рекомендуется использовать для хранения паролей?
Строки immutable и хранятся в string pool до GC. Пароль остаётся в памяти долго, что рискованно для безопасности. Лучше использовать char[] — его можно обнулить после использования (например, Arrays.fill(password, ' ')).

#### 2.2.10. Почему класс String неизменяемый (immutable) и final?
- **Immutable**: Гарантирует безопасность в многопоточности, предотвращает изменения (например, в ключах Map).
- **Final**: Предотвращает наследование и переопределение методов.
- Преимущества: string pool, кэшированный hashCode, безопасность (например, для параметров БД).

#### 2.2.11. Что делает метод intern() в классе String?
Метод intern() добавляет строку в string pool, если её там нет, и возвращает ссылку на объект из пула. Это обеспечивает, что строки с одинаковым значением ссылаются на один объект, экономя память.

Пример: `"hello".intern()` вернёт строку из пула.

#### 2.2.12. Можно ли использовать строки в конструкции switch?
Да, начиная с Java 7. Switch чувствителен к регистру, использует equals() для сравнения, требует проверки на null (иначе NPE). Компилятор оптимизирует в эффективный байт-код.

Пример: `switch (str) { case "A": break; }`

#### 2.2.13. Что такое инвариантность, ковариантность и контравариантность в контексте дженериков?
- **Инвариантность**: Типы несовместимы; List<String> не является подтипом List<Object>.
- **Ковариантность**: Подтип сохраняется; List<? extends Number> может содержать Integer (подтип Number).
- **Контравариантность**: Обратное; List<? super Integer> может содержать Number (супертип Integer).

В Java дженерики инвариантны по умолчанию; wildcard (? extends, ? super) добавляют ковариантность/контравариантность.

#### 2.2.14. В чем разница между String, StringBuffer и StringBuilder?
- **String**: Immutable, каждая операция создаёт новый объект. Потокобезопасен.
- **StringBuffer**: Mutable, синхронизирован (потокобезопасен), медленнее.
- **StringBuilder**: Mutable, не синхронизирован (быстрее), для однопоточных сценариев.

Выбирайте StringBuilder для производительности, StringBuffer для многопоточности.

#### 2.2.15. Каким образом переменные передаются в методы (pass-by-value vs pass-by-reference)?
В Java всегда pass-by-value: копируется значение. Для примитивов — само значение; для объектов — ссылка (копия ссылки). Изменения внутри метода не влияют на оригинал, кроме как через ссылку.

Пример: `void change(int x) { x = 10; }` — x снаружи не изменится.

#### 2.2.16. В чем разница между Hashtable и HashMap?
- **Hashtable**: Синхронизирован (потокобезопасен), не допускает null-ключи/значения, устаревший.
- **HashMap**: Не синхронизирован (быстрее), допускает null, предпочтителен.

Для многопоточности используйте ConcurrentHashMap.

#### 2.2.17. Как ограничить upper bounding типа-параметра в дженериках?
Upper bounding ограничивает тип-параметр сверху: `<T extends Number>` — T должен быть Number или его подклассом. Это позволяет вызывать методы суперкласса.

Пример: `public <T extends Comparable<T>> void sort(List<T> list)`.

Для downcasting в runtime используйте instanceof и cast, но это не компилируется.

#### 2.2.18. Сколько может быть стеков в JVM?
Каждый поток имеет свой стек (thread stack) для локальных переменных, вызовов методов и частичных результатов. Размер по умолчанию 1-2 MB, настраивается (-Xss). Количество стеков = количеству потоков.

#### 2.2.19. Какие классы могут быть статическими (static nested classes)?
Статическими могут быть вложенные классы (nested classes), объявленные как static. Они не привязаны к экземпляру внешнего класса, могут обращаться только к статическим членам внешнего. Пример: `public static class Inner {}`.

Доступ: Outer.Inner obj = new Outer.Inner();

#### 2.2.20. Что такое финальный класс (final class)?
Final класс нельзя наследовать. Пример: `public final class String {}`. Это предотвращает расширение и обеспечивает неизменность.

#### 2.2.21. Что такое поверхностное копирование (shallow copy)?
Shallow copy копирует объект, но не его вложенные объекты — копируются только ссылки. Изменения в вложенных объектах отражаются в обоих копиях.

Реализуется через clone() или конструктор копирования. Для глубокого копирования нужно вручную копировать вложенные объекты.

Пример: В вашем коде — изменение name в оригинале не влияет на копию, но если бы был вложенный объект, ссылка была бы общей.

#### 2.2.22. Что такое глубокое копирование (deep copy)?
Deep copy копирует объект и все его вложенные объекты рекурсивно, создавая независимые копии. Изменения в копии не влияют на оригинал.

Реализуется через clone() с переопределением (вызывая clone() для полей) или сериализацию. Требует, чтобы все классы поддерживали клонирование.

#### 2.2.23. Какие иммутабельные классы есть в Java?
Immutable классы: объекты нельзя изменить после создания.
- String, все wrapper-классы (Integer, etc.), BigInteger, BigDecimal.
- Коллекции: ImmutableList (Guava), List.of() (Java 9+).
- Другие: LocalDate, UUID.

Преимущества: потокобезопасность, простота.

#### 2.2.24. Как проверить значение на null в Java 8+ (Optional, etc.)?
Используйте Optional для избежания NPE. Пример: `Optional<String> opt = Optional.ofNullable(str); opt.ifPresent(s -> System.out.println(s));`

Методы: isPresent(), orElse(), map(). Для коллекций — Objects.requireNonNull() или проверки в стримах.

#### 2.2.25. Что такое var в Java 10+ и когда его использовать?
Var — локальная переменная с inferred типом (type inference). Компилятор определяет тип по инициализатору. Пример: `var list = new ArrayList<String>();` (тип — ArrayList<String>).

Использовать: для сокращения кода, когда тип очевиден. Не для полей, параметров или возвратов методов. Не скрывает тип — IDE покажет.


## END ---------------- 2.2. Примитивные типы, строки и базовые структуры ----------------

### 2.3. Потоки ввода/вывода (I/O)

+ [2.3.1. Что такое потоки ввода/вывода в Java?](#231-что-такое-потоки-вводавывода-в-java)
+ [2.3.2. Какие виды потоков существуют (byte vs character streams)?](#232-какие-виды-потоков-существуют-byte-vs-character-streams)
+ [2.3.3. Что такое класс InputStream?](#233-что-такое-класс-inputstream)
+ [2.3.4. Что такое класс OutputStream?](#234-что-такое-класс-outputstream)
+ [2.3.5. Какие классы наследуются от базовых классов InputStream и OutputStream?](#235-какие-классы-наследуются-от-базовых-классов-inputstream-и-outputstream)
+ [2.3.6. Что такое класс File для работы с файловой системой?](#236-что-такое-класс-file-для-работы-с-файловой-системой)
+ [2.3.7. В чем разница между FileInputStream и FileReader?](#237-в-чем-разница-между-fileinputstream-и-filereader)
+ [2.3.8. Как работает NIO (New I/O) в Java? Что такое Channels и Buffers?](#238-как-работает-nio-new-io-в-java-что-такое-channels-и-buffers)
+ [2.3.9. Что такое Path и Files в java.nio.file?](#239-что-такое-path-и-files-в-javaniofile)
+ [2.3.10. Как обрабатывать большие файлы без загрузки в память (streaming)?](#2310-как-обрабатывать-большие-файлы-без-загрузки-в-память-streaming)

#### 2.3.1. Что такое потоки ввода/вывода в Java?
Потоки ввода/вывода (I/O streams) — это абстракция для последовательного чтения или записи данных из/в источник/приёмник. Они позволяют работать с файлами, сетью, памятью и т.д. без знания деталей устройства.

- **Ввод (Input)**: Чтение данных из источника (файл, сеть).
- **Вывод (Output)**: Запись данных в приёмник.

Потоки байтовые или символьные, могут быть буферизованными для эффективности. Пример: `FileInputStream` для чтения файла.

#### 2.3.2. Какие виды потоков существуют (byte vs character streams)?
- **Байтовые потоки (byte streams)**: Работа с данными как с байтами. Классы: `InputStream`, `OutputStream` и их подклассы (например, `FileInputStream`). Подходят для бинарных данных.
- **Символьные потоки (character streams)**: Работа с данными как с символами (символы Unicode). Классы: `Reader`, `Writer` и их подклассы (например, `FileReader`). Автоматически обрабатывают кодировку, подходят для текста.

Символьные потоки часто обёртывают байтовые (например, `InputStreamReader` над `InputStream`).

#### 2.3.3. Что такое класс InputStream?
`InputStream` — абстрактный класс для байтового ввода. Представляет источник данных, из которого можно читать байты.

Основные методы:
- `int read()`: Читает следующий байт (или -1, если конец).
- `int read(byte[] b)`: Читает байты в массив, возвращает количество прочитанных.
- `int read(byte[] b, int off, int len)`: Читает len байтов в массив начиная с off.
- `int available()`: Возвращает количество доступных байтов без блокировки.
- `void close()`: Закрывает поток.

Пример: `InputStream is = new FileInputStream("file.txt"); int data = is.read(); is.close();`

#### 2.3.4. Что такое класс OutputStream?
`OutputStream` — абстрактный класс для байтового вывода. Представляет приёмник, куда можно записывать байты.

Основные методы:
- `void write(int b)`: Записывает байт.
- `void write(byte[] b)`: Записывает массив байтов.
- `void write(byte[] b, int off, int len)`: Записывает len байтов из массива начиная с off.
- `void flush()`: Очищает буферы.
- `void close()`: Закрывает поток.

Пример: `OutputStream os = new FileOutputStream("file.txt"); os.write(65); os.close();` (запишет 'A').

Нельзя напрямую выводить в String; используйте `ByteArrayOutputStream` для создания строки из байтов.

#### 2.3.5. Какие классы наследуются от базовых классов InputStream и OutputStream?
От `InputStream`:
- `ByteArrayInputStream`: Читает из массива байтов.
- `FileInputStream`: Читает из файла.
- `FilterInputStream`: Базовый для фильтров (например, `BufferedInputStream`, `DataInputStream`).
- `ObjectInputStream`: Для десериализации объектов.
- `PipedInputStream`: Для межпотоковой связи.

От `OutputStream`:
- `ByteArrayOutputStream`: Записывает в массив байтов.
- `FileOutputStream`: Записывает в файл.
- `FilterOutputStream`: Базовый для фильтров (например, `BufferedOutputStream`, `DataOutputStream`, `PrintStream`).
- `ObjectOutputStream`: Для сериализации объектов.
- `PipedOutputStream`: Для межпотоковой связи.

От `Reader` (символьный ввод):
- `BufferedReader`: Буферизированный ввод.
- `CharArrayReader`: Из массива символов.
- `StringReader`: Из строки.
- `FileReader`: Из файла.
- `InputStreamReader`: Преобразует байты в символы (с кодировкой).

От `Writer` (символьный вывод):
- `BufferedWriter`: Буферизированный вывод.
- `CharArrayWriter`: В массив символов.
- `StringWriter`: В строку.
- `FileWriter`: В файл.
- `OutputStreamWriter`: Преобразует символы в байты.

#### 2.3.6. Что такое класс File для работы с файловой системой?
`File` — класс для работы с файлами и директориями (представляет путь). Позволяет проверять существование, права, размер, время создания.

Конструкторы:
- `File(String pathname)`: Полный путь.
- `File(String parent, String child)`: Путь к родителю и имя.
- `File(File parent, String child)`: Объект родителя и имя.
- `File(URI uri)`: Из URI.

Методы: `exists()`, `isFile()`, `isDirectory()`, `length()`, `listFiles()`, `mkdir()`, `delete()`.

Пример: `File file = new File("c:/dir/Hello.txt"); if (file.exists()) { /* действия */ }`

#### 2.3.7. В чем разница между FileInputStream и FileReader?
- `FileInputStream`: Байтовый поток, читает данные как байты. Подходит для бинарных файлов (изображения, аудио).
- `FileReader`: Символьный поток, читает как символы (автоматически обрабатывает кодировку). Подходит для текстовых файлов.

`FileReader` — это `InputStreamReader` с `FileInputStream` и дефолтной кодировкой. Для контроля кодировки используйте `InputStreamReader` с `FileInputStream`.

Пример: `FileInputStream fis = new FileInputStream("file.bin");` vs `FileReader fr = new FileReader("file.txt");`

#### 2.3.8. Как работает NIO (New I/O) в Java? Что такое Channels и Buffers?
NIO (New I/O, java.nio) — неблокирующий I/O для эффективной работы с данными. Введён в Java 1.4, улучшен в NIO.2 (Java 7).

- **Channels**: Каналы для чтения/записи данных (например, `FileChannel`, `SocketChannel`). Поддерживают асинхронные операции.
- **Buffers**: Контейнеры для данных (например, `ByteBuffer`). Хранят данные для обработки; методы `flip()`, `clear()`, `rewind()` для управления позицией.

Работа: Читаете из канала в буфер, обрабатываете, пишете обратно. Неблокирующий: `Selector` для мониторинга нескольких каналов.

Пример: `FileChannel channel = FileChannel.open(path); ByteBuffer buffer = ByteBuffer.allocate(1024); channel.read(buffer);`

#### 2.3.9. Что такое Path и Files в java.nio.file?
- **Path**: Интерфейс (реализация `Paths.get()`) для представления путей к файлам/директориям. Заменяет `File`, поддерживает относительные/абсолютные пути, символические ссылки.
- **Files**: Утилитарный класс с статическими методами для операций: чтение/запись файлов, копирование, перемещение, проверка атрибутов.

Пример: `Path path = Paths.get("file.txt"); if (Files.exists(path)) { String content = Files.readString(path); }`

#### 2.3.10. Как обрабатывать большие файлы без загрузки в память (streaming)?
Используйте стриминговые потоки: читайте/пишите по частям, не загружая весь файл. Для байтов: `FileInputStream` с буфером; для символов: `BufferedReader`.

Пример чтения большого файла построчно:
```java


try (BufferedReader br = new BufferedReader(new FileReader("large.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
      // Обработка line
    }
}
```

Для NIO: `Files.lines(path)` возвращает Stream<String> для ленивой обработки. Избегайте `Files.readAllBytes()` для больших файлов.

### END ---------------- 2.3. Потоки ввода/вывода (I/O) ----------------

### 2.4. Объектно-ориентированное программирование (ООП)

+ [2.4.1. Какие принципы ООП поддерживает Java (инкапсуляция, наследование, полиморфизм, абстракция)?](#241-какие-принципы-ооп-поддерживает-java-инкапсуляция-наследование-полиморфизм-абстракция)
+ [2.4.2. Что такое вложенные классы? В каких случаях они применяются?](#242-что-такое-вложенные-классы-в-каких-случаях-они-применяются)
+ [2.4.3. Что такое локальный класс? Каковы его особенности?](#243-что-такое-локальный-класс-каковы-его-особенности)
+ [2.4.4. Что такое анонимные классы? Где они применяются?](#244-что-такое-анонимные-классы-где-они-применяются)
+ [2.4.5. Каким образом из вложенного класса получить доступ к полю внешнего класса?](#245-каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса)
+ [2.4.6. Что такое перечисления (enum)?](#246-что-такое-перечисления-enum)
+ [2.4.7. Как проблема ромбовидного наследования решена в Java (default methods)?](#247-как-проблема-ромбовидного-наследования-решена-в-java-default-methods)
+ [2.4.8. Что такое конструктор по умолчанию?](#248-что-такое-конструктор-по-умолчанию)
+ [2.4.9. Могут ли быть приватные конструкторы? Для чего они нужны?](#249-могут-ли-быть-приватные-конструкторы-для-чего-они-нужны)
+ [2.4.10. Чем отличаются конструктор по умолчанию, конструктор копирования и конструктор с параметрами?](#2410-чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами)
+ [2.4.11. Какие модификаторы доступа вы знаете? Расскажите про каждый из них.](#2411-какие-модификаторы-доступа-вы-знаете-расскажите-про-каждый-из-них)
+ [2.4.12. Что означает модификатор static?](#2412-что-означает-модификатор-static)
+ [2.4.13. Могут ли нестатические методы перегрузить статические?](#2413-могут-ли-нестатические-методы-перегрузить-статические)
+ [2.4.14. Могут ли быть переопределены статические методы?](#2414-могут-ли-быть-переопределены-статические-методы)
+ [2.4.15. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?](#2415-можно-ли-сузить-уровень-доступа-или-тип-возвращаемого-значения-при-переопределении-метода)
+ [2.4.16. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы?](#2416-что-можно-изменить-в-сигнатуре-метода-при-переопределении-можно-ли-менять-модификаторы)
+ [2.4.17. Что такое сигнатура метода?](#2417-что-такое-сигнатура-метода)
+ [2.4.18. Что такое переопределение (overriding) и перегрузка (overloading) методов?](#2418-что-такое-переопределение-overriding-и-перегрузка-overloading-методов)
+ [2.4.19. Когда вызывается конструктор?](#2419-когда-вызывается-конструктор)
+ [2.4.20. Что означает ключевое слово final?](#2420-что-означает-ключевое-слово-final)
+ [2.4.21. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?](#2421-могут-ли-быть-конструкторы-у-абстрактных-классов-зачем-они-нужны)
+ [2.4.22. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?](#2422-что-такое-интерфейсы-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов)
+ [2.4.23. Может ли интерфейс наследоваться от другого интерфейса?](#2423-может-ли-интерфейс-наследоваться-от-другого-интерфейса)
+ [2.4.24. Что такое дефолтные методы (default methods) в интерфейсах?](#2424-что-такое-дефолтные-методы-default-methods-в-интерфейсах)
+ [2.4.25. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default-методами?](#2425-как-решается-проблема-ромбовидного-наследования-при-наследовании-интерфейсов-с-default-методами)
+ [2.4.26. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?](#2426-каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учетом-иерархии-классов)
+ [2.4.27. Какие бывают блоки инициализации и зачем они нужны?](#2427-какие-бывают-блоки-инициализации-и-зачем-они-нужны)
+ [2.4.28. Каков порядок вызова конструкторов и блоков инициализации для класса-потомка и его предка?](#2428-каков-порядок-вызова-конструкторов-и-блоков-инициализации-для-класса-потомка-и-его-предка)
+ [2.4.29. Что произойдет, если в блоке инициализации возникнет ошибка?](#2429-что-произойдет-если-в-блоке-инициализации-возникнет-ошибка)
+ [2.4.30. Какие методы есть у класса Object?](#2430-какие-методы-есть-у-класса-object)
+ [2.4.31. Что такое метод equals()? Чем он отличается от операции ==?](#2431-что-такое-метод-equals-чем-он-отличается-от-операции-)
+ [2.4.32. Каким образом реализованы методы equals() и hashCode() в Object?](#2432-каким-образом-реализованы-методы-equals-и-hashcode-в-object)
+ [2.4.33. Какие правила переопределения equals()?](#2433-какие-правила-переопределения-equals)
+ [2.4.34. Какие правила переопределения hashCode()?](#2434-какие-правила-переопределения-hashcode)
+ [2.4.35. Могут ли у разных объектов быть одинаковые hashCode()?](#2435-могут-ли-у-разных-объектов-быть-одинаковые-hashcode)
+ [2.4.36. Чем a.getClass().equals(A.class) отличается от instanceof A?](#2436-чем-agetclassequalsaclass-отличается-от-instanceof-a)
+ [2.4.37. Может ли метод быть одновременно abstract и final?](#2437-может-ли-метод-быть-одновременно-abstract-и-final)
+ [2.4.38. Что такое функциональные интерфейсы?](#2438-что-такое-функциональные-интерфейсы)
+ [2.4.39. Как связаны equals() и hashCode()? Можно ли их использовать по отдельности?](#2439-как-связаны-equals-и-hashcode-можно-ли-их-использовать-по-отдельности)
+ [2.4.40. Какая дефолтная реализация equals() в Object?](#2440-какая-дефолтная-реализация-equals-в-object)
+ [2.4.41. Какие есть способы глубокого копирования объекта?](#2441-какие-есть-способы-глубокого-копирования-объекта)
+ [2.4.42. Как избежать ромбовидного наследования в Java?](#2442-как-избежать-ромбовидного-наследования-в-java)
+ [2.4.43. Что такое sealed classes в Java 17?](#2443-что-такое-sealed-classes-в-java-17)

#### 2.4.1. Какие принципы ООП поддерживает Java (инкапсуляция, наследование, полиморфизм, абстракция)?
Java поддерживает четыре основных принципа ООП:
- **Инкапсуляция**: Скрытие внутренней реализации класса, доступ через публичные методы. Реализуется модификаторами доступа (private, protected).
- **Наследование**: Классы наследуют свойства и методы от родительских. Используется extends. Множественное наследование запрещено, но поддерживается через интерфейсы.
- **Полиморфизм**: Один интерфейс для разных типов. Реализуется переопределением (overriding) и перегрузкой (overloading) методов.
- **Абстракция**: Фокус на существенных характеристиках, игнорируя детали. Реализуется абстрактными классами и интерфейсами.

Пример: Инкапсуляция - private поля с геттерами/сеттерами.

#### 2.4.2. Что такое вложенные классы? В каких случаях они применяются?
Вложенные классы — это классы, объявленные внутри других классов. Они делятся на:
- Нестатические (внутренние): Имеют доступ к полям внешнего класса, не могут существовать без него.
- Статические: Независимы от экземпляра внешнего класса, могут иметь статические члены.

Применяются для логической группировки, когда класс тесно связан с внешним (например, компоненты автомобиля). Внутренние классы полезны для обработки событий или скрытия реализации.

Пример: `class Outer { class Inner {} }`

#### 2.4.3. Что такое локальный класс? Каковы его особенности?
Локальный класс — класс, объявленный внутри метода или блока кода.

Особенности:
- Доступ только к final (или effectively final) переменным метода.
- Не могут быть static или иметь модификаторы доступа.
- Видимы только в области объявления.
- Полезны для одноразовой логики, например, в анонимных обработчиках.

Пример:
```java
void method() {
    final int x = 10;
    class Local {
      void print() { System.out.println(x); }
    }
    
    new Local().print();
}
```

#### 2.4.4. Что такое анонимные классы? Где они применяются?
Анонимные классы — неименованные подклассы или реализации интерфейсов, создаваемые на лету.

Применяются для кратких реализаций, когда нужен один экземпляр и имя не важно (например, обработчики событий, Runnable).

Пример:
```java
Runnable r = new Runnable() {
  public void run() { System.out.println("Hello"); }
};
```

#### 2.4.5. Каким образом из вложенного класса получить доступ к полю внешнего класса?
Из нестатического вложенного класса: `Outer.this.field`. Из статического: `Outer.field` (если поле статическое).

Пример:
```java
class Outer {
    private int x = 1;
    class Inner {
      void access() { System.out.println(Outer.this.x); }
    }
}
```

#### 2.4.6. Что такое перечисления (enum)?
Enum — специальный класс для констант. Наследуется от `java.lang.Enum`. Элементы — статические экземпляры.

Применяются для ограниченного набора значений (дни недели, статусы).

Пример:
```java
enum Day { MONDAY, TUESDAY; }
Day day = Day.MONDAY;
```

#### 2.4.7. Как проблема ромбовидного наследования решена в Java (default methods)?
В Java нет множественного наследования классов, но интерфейсы позволяют default-методы. При конфликте (ромб) компилятор требует явного разрешения (super или переопределение).

Пример: Два интерфейса с default-методом — класс должен переопределить его.

#### 2.4.8. Что такое конструктор по умолчанию?
Конструктор по умолчанию — автоматически генерируемый пустой конструктор без параметров, вызывающий super(). Существует, если нет других конструкторов.

Пример: Для класса без конструкторов компилятор добавляет `public ClassName() {}`.

#### 2.4.9. Могут ли быть приватные конструкторы? Для чего они нужны?
Да, приватные конструкторы возможны. Нужны для предотвращения создания экземпляров (шаблон Singleton) или утилитарных классов.

Пример Singleton:
```java
class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
  
    public static Singleton getInstance() { 
      return instance != null ? instance : (instance = new Singleton()); 
    }
}
```

#### 2.4.10. Чем отличаются конструктор по умолчанию, конструктор копирования и конструктор с параметрами?
- **По умолчанию**: Без параметров, генерируется автоматически.
- **Копирования**: Принимает объект того же класса для копирования. В Java нет встроенного, реализуется вручную.
- **С параметрами**: Принимает аргументы для инициализации.

Пример копирования: `public Circle(Circle c) { this.radius = c.radius; }`

#### 2.4.11. Какие модификаторы доступа вы знаете? Расскажите про каждый из них.
- **private**: Доступ только в классе.
- **default (package-private)**: Доступ в пакете.
- **protected**: Доступ в пакете и подклассах.
- **public**: Доступ везде.

Пример: private поле скрыто от внешнего доступа.

#### 2.4.12. Что означает модификатор static?
Static — принадлежит классу, не экземпляру. Доступ без создания объекта. Статические блоки выполняются при загрузке класса.

Пример: `static int count;`

#### 2.4.13. Могут ли нестатические методы перегрузить статические?
Да, перегрузка возможна по сигнатуре. Статический метод доступен по классу, нестатический — по объекту.

Пример:
```java
class A {
    static void m() {}
  
    void m(int x) {}
}
```

#### 2.4.14. Могут ли быть переопределены статические методы?
Нет, статические методы скрываются (hiding), не переопределяются. В подклассе можно объявить статический метод с той же сигнатурой.

Пример: `class B extends A { static void m() {} }` — это hiding, не overriding.

#### 2.4.15. Можно ли сузить уровень доступа или тип возвращаемого значения при переопределении метода?
Нет, уровень доступа можно расширить, тип возврата — covariant (подтип). Сужение запрещено.

Пример: protected -> public ок, Object -> String ок.

#### 2.4.16. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы?
Ничего в сигнатуре (имя, параметры, порядок). Модификаторы: доступ расширить, добавить final, но не static или abstract.

Пример: Нельзя изменить тип параметра.

#### 2.4.17. Что такое сигнатура метода?
Сигнатура — имя метода + список параметров (типы и порядок). Возвратный тип и модификаторы не входят.

Пример: `void method(int x, String s)` — сигнатура method(int, String).

#### 2.4.18. Что такое переопределение (overriding) и перегрузка (overloading) методов?
- **Overriding**: Изменение поведения унаследованного метода в подклассе (та же сигнатура).
- **Overloading**: Несколько методов с одинаковым именем, но разными параметрами.

Пример overriding: `class B extends A { void m() { super.m(); } }`

#### 2.4.19. Когда вызывается конструктор?
При создании объекта с new. Автоматически вызывается цепочка: подкласс -> суперкласс.

Пример: `new MyClass();` вызывает конструктор.

#### 2.4.20. Что означает ключевое слово final?
- Класс: Нельзя наследовать.
- Метод: Нельзя переопределить.
- Переменная: Нельзя изменить значение.

Пример: `final int x = 5;`

#### 2.4.21. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?
Да, абстрактные классы могут иметь конструкторы. Они инициализируют поля, вызываются подклассами.

Пример: Абстрактный класс с конструктором для общих полей.

#### 2.4.22. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Интерфейс — контракт для классов. Поля: public static final. Методы: public abstract (с Java 8 — default, static).

Пример: `interface I { int X = 1; void m(); default void d() {} }`

#### 2.4.23. Может ли интерфейс наследоваться от другого интерфейса?
Да, интерфейсы могут наследоваться от других интерфейсов (extends), поддерживая множественное.

Пример: `interface B extends A, C {}`

#### 2.4.24. Что такое дефолтные методы (default methods) в интерфейсах?
Default-методы — реализованные методы в интерфейсе, добавленные в Java 8 для обратной совместимости.

Пример: `default void m() { System.out.println("Default"); }`

#### 2.4.25. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default-методами?
Компилятор требует явного разрешения: класс переопределяет метод или использует super (I.super.m()).

Пример: `interface A { default void m() {} } interface B extends A {} class C implements A, B { void m() { A.super.m(); } }`

#### 2.4.26. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
Статические блоки суперкласса -> статические подкласса -> нестатические суперкласса + конструктор -> нестатические подкласса + конструктор.

Пример: При new Sub() — сначала static блоков от Object до Sub, затем нестатических.

#### 2.4.27. Какие бывают блоки инициализации и зачем они нужны?
- Статические: `static {}` — выполняются при загрузке класса, инициализируют статические поля.
- Нестатические: `{}` — выполняются при создании объекта, до конструктора.

Нужны для сложной инициализации, читаемости кода.

Пример: `static { System.out.println("Class loaded"); }`

#### 2.4.28. Каков порядок вызова конструкторов и блоков инициализации для класса-потомка и его предка?
Статические блоки предка -> статические потомка -> нестатические предка + конструктор предка -> нестатические потомка + конструктор потомка.

#### 2.4.29. Что произойдет, если в блоке инициализации возникнет ошибка?
Для статических: ExceptionInInitializerError, класс не загружается. Для нестатических: Исключение в конструкторе, объект не создается. ThreadDeath игнорируется.

#### 2.4.30. Какие методы есть у класса Object?
- clone(), equals(Object), finalize(), getClass(), hashCode(), notify(), notifyAll(), toString(), wait() (три варианта).

#### 2.4.31. Что такое метод equals()? Чем он отличается от операции ==?
equals() сравнивает содержимое объектов (переопределяется для логики). == сравнивает ссылки.

Пример: `obj1.equals(obj2)` vs `obj1 == obj2`.

#### 2.4.32. Каким образом реализованы методы equals() и hashCode() в Object?
equals(): `return this == obj;`. hashCode(): Нативная реализация, возвращает уникальный int.

#### 2.4.33. Какие правила переопределения equals()?
- Рефлексивность, симметричность, транзитивность, консистентность.
- При переопределении также переопределить hashCode().
- Проверять на null и тип.

#### 2.4.34. Какие правила переопределения hashCode()?
- Консистентность: одинаковый hash для равных объектов.
- Равные equals() — равные hashCode().
- Желательно равномерное распределение.

#### 2.4.35. Могут ли у разных объектов быть одинаковые hashCode()?
Да, коллизии возможны, но нежелательны.

#### 2.4.36. Чем a.getClass().equals(A.class) отличается от instanceof A?
getClass() проверяет точный класс. instanceof — класс или подкласс.

Пример: `obj instanceof A` true для подклассов, `obj.getClass() == A.class` — только A.

#### 2.4.37. Может ли метод быть одновременно abstract и final?
Нет, abstract требует реализации, final запрещает.

#### 2.4.38. Что такое функциональные интерфейсы?
Интерфейсы с одним абстрактным методом. Аннотируются @FunctionalInterface. Используются в лямбдах.

Пример: Runnable, Predicate.

#### 2.4.39. Как связаны equals() и hashCode()? Можно ли их использовать по отдельности?
Связаны контрактом: равные equals() — равные hashCode(). Можно использовать отдельно, но вместе обеспечивают корректность в коллекциях.

#### 2.4.40. Какая дефолтная реализация equals() в Object?
`public boolean equals(Object obj) { return this == obj; }`

#### 2.4.41. Какие есть способы глубокого копирования объекта?
- Реализовать Cloneable и clone() (поверхностное, доработать для глубокого).
- Сериализация/десериализация.
- Конструкторы копирования или библиотеки (Apache Commons, Gson).

#### 2.4.42. Как избежать ромбовидного наследования в Java?
Использовать интерфейсы вместо множественного наследования. Для default-методов — явное разрешение.

#### 2.4.43. Что такое sealed classes в Java 17?
Sealed classes ограничивают наследование: класс объявляет permitted subclasses. Улучшает безопасность, позволяет exhaustive switch.

Пример: `sealed class Shape permits Circle, Square {}`


### END ---------------- 2.4. Объектно-ориентированное программирование (ООП) ----------------

### 2.5. Исключения (Exceptions)

+ [2.5.1. Опишите иерархию исключений в Java.](#251-опишите-иерархию-исключений-в-java)
+ [2.5.2. Чем отличается Error от Exception?](#252-чем-отличается-error-от-exception)
+ [2.5.3. Расскажите про checked (обрабатываемые) и unchecked (необрабатываемые) исключения.](#253-расскажите-про-checked-обрабатываемые-и-unchecked-необрабатываемые-исключения)
+ [2.5.4. Какой оператор позволяет принудительно выбросить исключение (throw)?](#254-какой-оператор-позволяет-принудительно-выбросить-исключение-throw)
+ [2.5.5. Как создать собственное (пользовательское) исключение?](#255-как-создать-собственное-пользовательское-исключение)
+ [2.5.6. В каком случае не выполнится блок finally?](#256-в-каком-случае-не-выполнится-блок-finally)
+ [2.5.7. Может ли метод main() выбросить исключение наружу?](#257-может-ли-метод-main-выбросить-исключение-наружу)
+ [2.5.8. В каком порядке следует обрабатывать исключения в catch-блоках?](#258-в-каком-порядке-следует-обрабатывать-исключения-в-catch-блоках)
+ [2.5.9. Что такое try-with-resources?](#259-что-такое-try-with-resources)
+ [2.5.10. Что необходимо реализовать для работы try-with-resources (AutoCloseable)?](#2510-что-необходимо-реализовать-для-работы-try-with-resources-autocloseable)
+ [2.5.11. Что произойдет, если исключение будет выброшено из блока catch, а затем другое — из finally?](#2511-что-произойдет-если-исключение-будет-выброшено-из-блока-catch-а-затем-другое--из-finally)
+ [2.5.12. Можно ли использовать checked-исключения в лямбда-выражениях?](#2512-можно-ли-использовать-checked-исключения-в-лямбда-выражениях)
+ [2.5.13. Как определить причину OutOfMemoryError?](#2513-как-определить-причину-outofmemoryerror)
+ [2.5.14. Что такое suppressed exceptions в Java?](#2514-что-такое-suppressed-exceptions-в-java)
+ [2.5.15. Как правильно логировать исключения в production-коде?](#2515-как-правильно-логировать-исключения-в-production-коде)

#### 2.5.1. Опишите иерархию исключений в Java.
Иерархия исключений в Java основана на классе `Throwable`. Он делится на:
- **Error**: Серьезные ошибки JVM, не предназначенные для обработки (например, OutOfMemoryError, StackOverflowError).
- **Exception**: Исключения, которые можно обрабатывать. Делятся на:
    - Checked (проверяемые): Наследники Exception, кроме RuntimeException (например, IOException, FileNotFoundException).
    - Unchecked (непроверяемые): RuntimeException и его подклассы (например, IllegalArgumentException, NullPointerException).

Пример: Throwable -> Exception -> IOException -> FileNotFoundException.

#### 2.5.2. Чем отличается Error от Exception?
- **Error**: Представляет серьезные проблемы JVM (например, OutOfMemoryError), которые обычно не обрабатываются, так как указывают на системные сбои.
- **Exception**: Обычные исключительные ситуации в программе (например, IOException), которые можно и нужно обрабатывать.

Error наследуется от Throwable, как и Exception, но предназначен для необрабатываемых ошибок.

#### 2.5.3. Расскажите про checked (обрабатываемые) и unchecked (необрабатываемые) исключения.
- **Checked исключения**: Проверяются компилятором, требуют обработки (try-catch или throws). Примеры: IOException, SQLException.
- **Unchecked исключения**: Не проверяются компилятором, включают RuntimeException (например, NullPointerException) и Error. Не требуют обязательной обработки, но могут быть пойманы.

Пример: Метод, выбрасывающий IOException, должен объявить throws или обработать.

#### 2.5.4. Какой оператор позволяет принудительно выбросить исключение (throw)?
Оператор `throw` используется для явного выбрасывания исключения. Пример: `throw new IllegalArgumentException("Invalid argument");`

#### 2.5.5. Как создать собственное (пользовательское) исключение?
Создайте класс, наследующий от Exception (checked) или RuntimeException (unchecked). Добавьте конструкторы для сообщения и причины.

Пример:
```java
public class MyException extends Exception {
  public MyException(String message) { super(message); }
}
```

#### 2.5.6. В каком случае не выполнится блок finally?
Блок finally не выполнится, если:
- В try или catch вызван System.exit().
- Возникла критическая ошибка (например, OutOfMemoryError).
- В try или catch произошел бесконечный цикл или ThreadDeath.

В остальных случаях finally всегда выполняется.

#### 2.5.7. Может ли метод main() выбросить исключение наружу?
Да, main() может выбрасывать исключения. Если не обработано, JVM выведет stack trace в stderr. Если нет не-демон потоков, программа завершится; иначе — дождется их завершения.

Пример: `public static void main(String[] args) throws IOException { ... }`

#### 2.5.8. В каком порядке следует обрабатывать исключения в catch-блоках?
От наиболее специфичных (подклассов) к общим (родителям). Иначе общий catch поймает все раньше.

Пример:
```java
try { ... }
  
catch (FileNotFoundException e) { ... }
  
catch (IOException e) { ... }
```

#### 2.5.9. Что такое try-with-resources?
Try-with-resources автоматически закрывает ресурсы (реализующие AutoCloseable), даже при исключении. Ресурсы объявляются в скобках после try.

Пример:
```java
try (FileReader fr = new FileReader(path); BufferedReader br = new BufferedReader(fr)) {
  return br.readLine();
}
```

#### 2.5.10. Что необходимо реализовать для работы try-with-resources (AutoCloseable)?
Класс ресурса должен реализовать интерфейс AutoCloseable (или Closeable), который имеет метод close().

Пример: FileReader реализует Closeable, наследующий AutoCloseable.

#### 2.5.11. Что произойдет, если исключение будет выброшено из блока catch, а затем другое — из finally?
Исключение из finally подавит исключение из catch. В Java 7+ второе может быть suppressed. В finally можно использовать вложенный try-catch для обработки.

Пример: Если catch выбрасывает A, finally — B, то B будет видно, A — suppressed.

#### 2.5.12. Можно ли использовать checked-исключения в лямбда-выражениях?
Нет, лямбда-выражения не могут выбрасывать checked-исключения напрямую, так как функциональные интерфейсы не объявляют их. Можно обернуть в unchecked или обработать внутри.

Пример: Вместо throws IOException, используйте RuntimeException.

#### 2.5.13. Как определить причину OutOfMemoryError?
- Анализируйте heap dump с помощью jvisualvm или MAT (Eclipse Memory Analyzer).
- Используйте Java Flight Recorder для записи работы JVM.
- Проверьте логи, стек вызовов, параметры JVM (-Xmx для heap size).
- Оптимизируйте код: избегайте утечек, используйте кеширование, профилировщики (например, YourKit).

Пример: Увеличьте heap size или найдите утечку памяти.

#### 2.5.14. Что такое suppressed exceptions в Java?
Suppressed exceptions — дополнительные исключения, добавленные к основному в try-with-resources или addSuppressed(). Они не теряются, если в finally выбрасывается новое.

Пример: В try-with-resources исключение в close() добавляется к основному via addSuppressed().

#### 2.5.15. Как правильно логировать исключения в production-коде?
- Логируйте с уровнем ERROR или WARN, включая stack trace (e.printStackTrace() или logger.error(message, e)).
- Не логируйте чувствительные данные.
- Используйте фреймворки вроде Log4j или SLF4J.
- Добавляйте контекст (ID запроса, пользователь).
- Избегайте чрезмерного логирования, чтобы не засорять логи.

Пример: `logger.error("Database error for user {}", userId, e);`

### END ---------------- 2.5. Исключения (Exceptions) ----------------

### 2.6. Сериализация и копирование

+ [2.6.1. Что такое сериализация и как она реализована в Java?](#261-что-такое-сериализация-и-как-она-реализована-в-java)
+ [2.6.2. Для чего нужна сериализация?](#262-для-чего-нужна-сериализация)
+ [2.6.3. Опишите процесс сериализации/десериализации с использованием Serializable.](#263-опишите-процесс-сериализациидесериализации-с-использованием-serializable)
+ [2.6.4. Какие поля не будут сериализованы при сериализации (transient)?](#264-какие-поля-не-будут-сериализованы-при-сериализации-transient)
+ [2.6.5. Как изменить стандартное поведение сериализации/десериализации (readObject, writeObject)?](#265-как-изменить-стандартное-поведение-сериализациидесериализации-readobject-writeobject)
+ [2.6.6. Как создать собственный протокол сериализации (Externalizable)?](#266-как-создать-собственный-протокол-сериализации-externalizable)
+ [2.6.7. В чем проблема сериализации Singleton? Как ее решить?](#267-в-чем-проблема-сериализации-singleton-как-ее-решить)
+ [2.6.8. Как происходит десериализация? Что такое serialVersionUID?](#268-как-происходит-десериализация-что-такое-serialversionuid)
+ [2.6.9. В чем разница между Serializable и Externalizable?](#269-в-чем-разница-между-serializable-и-externalizable)
+ [2.6.10. Какие проблемы безопасности связаны с десериализацией?](#2610-какие-проблемы-безопасности-связаны-с-десериализацией)

#### 2.6.1. Что такое сериализация и как она реализована в Java?
Сериализация — это процесс преобразования объекта в последовательность байтов для сохранения или передачи. Десериализация — обратный процесс восстановления объекта из байтов.

В Java сериализация реализована через пакеты java.io (ObjectOutputStream для сериализации, ObjectInputStream для десериализации). Класс должен реализовывать интерфейс Serializable.

Пример:
```java
import java.io.*;

class MyClass implements Serializable {
  private String data;
}

public class Example {
  public static void main(String[] args) {
    MyClass obj = new MyClass();
    try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("file.ser"))) {
      out.writeObject(obj);
    } catch (IOException e) { e.printStackTrace(); }
  }
}
```

#### 2.6.2. Для чего нужна сериализация?
Сериализация нужна для:
- Сохранения состояния объекта (например, в файл или базу данных).
- Передачи объектов по сети (RMI, HTTP).
- Клонирования объектов (через сериализацию-десериализацию).

Пример: Сохранение состояния игры в файл.

#### 2.6.3. Опишите процесс сериализации/десериализации с использованием Serializable.
При использовании Serializable применяется алгоритм сериализации с помощью рефлексии:
- Запись метаданных класса (имя, serialVersionUID, поля).
- Рекурсивная запись суперклассов до Object.
- Запись примитивных полей и рекурсивная сериализация объектов-полей (с обработкой циклов).

Десериализация: Чтение метаданных, создание объекта через рефлексию, заполнение полей.

При реализации Serializable добавляется serialVersionUID (вычисляется по классу или задается вручную). При несоответствии — InvalidClassException.

Пример: См. код в 2.6.1.

#### 2.6.4. Какие поля не будут сериализованы при сериализации (transient)?
Поля, помеченные как transient, не сериализуются. Static поля также не сериализуются (принадлежат классу, не экземпляру).

Final поля сериализуются, но с Externalizable их нельзя изменить после десериализации (из-за конструктора).

Пример: private transient String password; // Не будет сохранено.

#### 2.6.5. Как изменить стандартное поведение сериализации/десериализации (readObject, writeObject)?
- Реализуйте Externalizable с writeExternal() и readExternal() для полной кастомизации.
- Или добавьте private методы readObject() и writeObject() в классе, реализующем Serializable, для изменения поведения.

Также readResolve() и writeReplace() для замены объекта.

Пример:
```java
private void writeObject(ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  // Дополнительная логика
}
```

#### 2.6.6. Как создать собственный протокол сериализации (Externalizable)?
Реализуйте интерфейс Externalizable с методами writeExternal() и readExternal(). Это дает полный контроль над процессом.

Пример:
```java
public class MyClass implements Externalizable {
    private String data;
    
    public void writeExternal(ObjectOutput out) throws IOException {
      out.writeUTF(data);
    }
    
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
      data = in.readUTF();
    }
}
```

#### 2.6.7. В чем проблема сериализации Singleton? Как ее решить?
Проблема: Десериализация создает новый экземпляр, нарушая паттерн Singleton.

Решение:
- Запретить сериализацию (implements Serializable, но добавить readResolve()).
- Реализовать readResolve() для возврата единственного экземпляра.

Пример:
```java
public class Singleton implements Serializable {
    private static final Singleton instance = new Singleton();
    
    private Singleton() {}
  
    public static Singleton getInstance() { return instance; }
  
    private Object readResolve() { return instance; }
}
```

#### 2.6.8. Как происходит десериализация? Что такое serialVersionUID?
Десериализация: ObjectInputStream читает поток, проверяет serialVersionUID (должен совпадать с классом), создает объект рефлексивно, заполняет поля.

serialVersionUID — уникальный идентификатор версии класса (long). Если не задан, вычисляется JVM по полям/методам. Несовпадение вызывает InvalidClassException.

Пример: private static final long serialVersionUID = 1L;

#### 2.6.9. В чем разница между Serializable и Externalizable?
- Serializable: Автоматическая сериализация по умолчанию, использует рефлексию, медленнее, но проще.
- Externalizable: Ручная реализация writeExternal/readExternal, быстрее, полная кастомизация, требует конструктора без параметров.

Serializable — маркерный интерфейс; Externalizable — с методами.

#### 2.6.10. Какие проблемы безопасности связаны с десериализацией?
Десериализация может привести к уязвимостям (например, десериализация вредоносных объектов, вызывающих код). Известны атаки на библиотеки вроде Apache Commons Collections.

Решение: Валидация входных данных, использование безопасных библиотек (Jackson вместо ObjectInputStream), или избегание десериализации ненадежных данных.

Пример: Атаки через Gadgets, где десериализация вызывает системные команды.


### END ---------------- 2.6. Сериализация и копирование ----------------

### 2.7. Дженерики (Generics)

+ [2.7.1. Что такое дженерики в Java?](#271-что-такое-дженерики-в-java)
+ [2.7.2. Зачем нужны дженерики? Какие проблемы они решают?](#272-зачем-нужны-дженерики-какие-проблемы-они-решают)
+ [2.7.3. Что такое типовая эрасура (type erasure)?](#273-что-такое-типовая-эрасура-type-erasure)
+ [2.7.4. В чем разница между bounded и unbounded wildcards?](#274-в-чем-разница-между-bounded-и-unbounded-wildcards)
+ [2.7.5. Что такое PECS (Producer Extends, Consumer Super)?](#275-что-такое-pecs-producer-extends-consumer-super)
+ [2.7.6. Можно ли использовать примитивные типы в дженериках?](#276-можно-ли-использовать-примитивные-типы-в-дженериках)
+ [2.7.7. Что такое рекурсивные дженерики?](#277-что-такое-рекурсивные-дженерики)
+ [2.7.8. Как работает super в дженериках?](#278-как-работает-super-в-дженериках)

#### 2.7.1. Что такое дженерики в Java?
Дженерики — это механизм параметризации типов, позволяющий создавать классы, интерфейсы и методы, работающие с различными типами данных без потери типобезопасности. Введены в Java 5 для избежания приведения типов и ошибок во время выполнения.

Пример: List<String> list = new ArrayList<>(); — список строк, компилятор проверяет типы.

#### 2.7.2. Зачем нужны дженерики? Какие проблемы они решают?
Дженерики решают проблемы:
- Типобезопасности: Предотвращают ClassCastException во время выполнения.
- Переиспользования кода: Позволяют писать обобщенные алгоритмы (например, Collections.sort).
- Полиморфизма: Реализуют параметризованный полиморфизм.

Без дженериков использовались raw types (List list), что приводило к необходимости приведения типов и рискам ошибок.

Пример: Collections.sort(List<T> list) работает с любым Comparable<T>.

#### 2.7.3. Что такое типовая эрасура (type erasure)?
Type erasure — процесс, при котором JVM стирает информацию о параметрах типов во время компиляции. Generic-код компилируется в байткод с raw types (например, List<String> становится List), добавляя проверки типов и приведения.

Это обеспечивает совместимость с legacy-кодом, но ограничивает runtime-интроспекцию (нельзя узнать тип параметра).

Пример: Во время выполнения List<String> и List<Integer> — это просто List.

#### 2.7.4. В чем разница между bounded и unbounded wildcards?
- Unbounded wildcard (?): Представляет неизвестный тип, эквивалент <? extends Object>. Используется для чтения (producer).
- Bounded wildcards:
    - Upper-bounded (? extends T): Для чтения, тип — T или его подтипы.
    - Lower-bounded (? super T): Для записи, тип — T или его супертипы.

Unbounded подходит для операций, не зависящих от типа (например, size()).

Пример: List<?> list; // Любые объекты, но нельзя добавить ничего кроме null.

#### 2.7.5. Что такое PECS (Producer Extends, Consumer Super)?
PECS — принцип для выбора wildcards:
- Producer Extends: Если метод производит (возвращает) значения типа T, используйте ? extends T (ковариантность).
- Consumer Super: Если метод потребляет (принимает) значения типа T, используйте ? super T (контравариантность).

Это обеспечивает типобезопасность и гибкость.

Пример Producer:
```java
public void printList(List<? extends Number> list) {
    for (Number n : list) {
      System.out.println(n);
    }
}
```

Пример Consumer:
```java
public void addNumbers(List<? super Integer> list) {
  list.add(1);
}
```

#### 2.7.6. Можно ли использовать примитивные типы в дженериках?
Нет, дженерики работают только с reference types (классами и интерфейсами). Для примитивов используются wrapper-классы (Integer для int и т.д.).

Это ограничение из-за type erasure — примитивы не могут быть параметрами типов.

Пример: List<int> — ошибка; List<Integer> — правильно.

#### 2.7.7. Что такое рекурсивные дженерики?
Рекурсивные дженерики — это использование типа самого себя в качестве параметра (например, в Enum или builder-паттерне).

Пример: Класс, реализующий Comparable<T> с T = сам класс.
```java
public class MyClass<T extends MyClass<T>> implements Comparable<T> {
  public int compareTo(T other) { return 0; }
}
```

Используется для типов, зависящих от себя (например, в fluent API).

#### 2.7.8. Как работает super в дженериках?
super в wildcards (? super T) означает, что тип — T или его супертип. Используется для контравариантности: можно записывать T или подтипы T в коллекцию.

В методах: Позволяет передавать коллекции супертипов.

Пример: List<? super Integer> list; — можно добавить Integer, но при чтении тип Object.

В отличие от extends, который для чтения.

### END ---------------- 2.7. Дженерики (Generics) ----------------

### 2.8. Коллекции

+ [2.8.1. Что такое коллекция?](#281-что-такое-коллекция)
+ [2.8.2. Расскажите про иерархию коллекций?](#282-расскажите-про-иерархию-коллекций)
+ [2.8.3. Почему Map - это не Collection, в то время как List и Set являются Collection?](#283-почему-map---это-не-collection-в-то-время-как-list-и-set-являются-collection)
+ [2.8.4. В чем разница между классами java.util.Collection и java.util.Collections?](#284-в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
+ [2.8.5. Что такое «fail-fast поведение»?](#285-что-такое-fail-fast-поведение)
+ [2.8.6. Какая разница между fail-fast и fail-safe?](#286-какая-разница-между-fail-fast-и-fail-safe)
+ [2.8.7. Чем различается Enumeration и Iterator?](#287-чем-различается-enumeration-и-iterator)
+ [2.8.8. Как между собой связаны Iterable, Iterator и «for-each»?](#288-как-между-собой-связаны-iterable-iterator-и-for-each)
+ [2.8.9. Сравните Iterator и ListIterator.](#289-сравните-iterator-и-listiterator)
+ [2.8.10. Как поведёт себя коллекция, если вызвать iterator.remove()?](#2810-как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
+ [2.8.11. Чем Set отличается от List?](#2811-чем-set-отличается-от-list)
+ [2.8.12. Расскажите про интерфейс Set](#2812-расскажите-про-интерфейс-set)
+ [2.8.13. Что будет если добавлять элементы в TreeSet по возрастанию?](#2813-что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
+ [2.8.14. Как устроен HashSet, сложность основных операций](#2814-как-устроен-hashset-сложность-основных-операций)
+ [2.8.15. Как устроен LinkedHashSet сложность основных операций](#2815-как-устроен-linkedhashset-сложность-основных-операций)
+ [2.8.16. Как устроен TreeSet сложность основных операций](#2816-как-устроен-treeset-сложность-основных-операций)
+ [2.8.17. Расскажите про интерфейс List](#2817-расскажите-про-интерфейс-list)
+ [2.8.18. Как устроен ArrayList сложность основных операций](#2818-как-устроен-arraylist-сложность-основных-операций)
+ [2.8.19. Как устроен LinkedList сложность основных операций](#2819-как-устроен-linkedlist-сложность-основных-операций)
+ [2.8.20. Почему LinkedList реализует и List и Deque](#2820-почему-linkedlist-реализует-и-list-и-deque)
+ [2.8.21. Как перестроить Связанный список в HashTable](#2821-как-перестроить-связанный-список-в-hashtable)
+ [2.8.22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?](#2822-существуют-ли-какие-нибудь-требованию-к-объектам-используемым-в-качестве-ключа-в-hashmap)
+ [2.8.23. Как работает HashMap?](#2823-как-работает-hashmap)
+ [2.8.24. Как строиться красное-черное дерево?](#2824-как-строиться-красное-черное-дерево)
+ [2.8.25. На чем основана HashSet?](#2825-на-чем-основана-hashset)
+ [2.8.26. Какая структура подходит для хранения большого количества данных](#2826-какая-структура-подходит-для-хранения-большого-количества-данных)
+ [2.8.27. Что может быть ключем в HashMap?](#2827-что-может-быть-ключем-в-hashmap)
+ [2.8.28. Параметры ArrayList](#2828-параметры-arraylist)
+ [2.8.29. Stack](#2829-stack)
+ [2.8.30. Comparator vs Comparable](#2830-comparator-vs-comparable)
+ [2.8.31. Какие есть конкурентные коллекции в Java?](#2831-какие-есть-конкурентные-коллекции-в-java)
+ [2.8.32. Как работает Stream API с коллекциями?](#2832-как-работает-stream-api-с-коллекциями)

#### 2.8.1. Что такое коллекция?
Коллекция — это объект, представляющий группу объектов (элементов) как единое целое. В Java Collections Framework (JCF) коллекции позволяют хранить, манипулировать и обрабатывать группы объектов динамически. <br>
Основные интерфейсы: Collection (корневой), List, Set, Queue, Map. <br>
Для junior: Коллекции — это как массивы, но без фиксированного размера. Вы можете добавлять и удалять элементы, не заботясь о длине. Например, ArrayList растет автоматически. Начните с простых примеров: создать List<String> и добавить строки. Это поможет понять базовую работу без углубления в производительность. <br>
Senior: JCF — фундаментальная часть Java для структур данных. Используйте generics для type-safety и избегайте raw types. В Java 9+ применяйте factory methods вроде List.of() для создания immutable коллекций, что полезно для защиты от изменений. Помните о выборе коллекции по сценарию: для частых вставок — LinkedList, для поиска — HashMap. Также учитывайте memory footprint и сериализацию.

#### 2.8.2. Расскажите про иерархию коллекций?
Иерархия делится на две ветви: Collection и Map. <br>
Collection (расширяет Iterable): <br>
- Set: Уникальные элементы (HashSet, LinkedHashSet, TreeSet). <br>
- List: Упорядоченные, допускают дубликаты (ArrayList, LinkedList, Vector). <br>
- Queue: Очереди (PriorityQueue, LinkedList как Deque). <br>
  Map: Пары ключ-значение (HashMap, LinkedHashMap, TreeMap, Hashtable). <br>
  Для junior: Collection — для групп, Map — для словарей. Senior: Выбирайте по сложности (HashMap O(1), TreeMap O(log n)); в Java 21+ Sequenced Collections для ordered access; избегайте legacy (Vector/Hashtable).

Для junior: Представьте Collection как группу вещей, где List — список покупок (с повторами и порядком), Set — набор уникальных инструментов (без дубликатов), Queue — очередь в магазин (первый вошел — первый вышел). Map — словарь, где ключ — слово, значение — перевод. Начните с ArrayList для простоты, потом перейдите к HashSet для уникальности. <br>
Senior: Иерархия оптимизирована для разных случаев: HashMap для O(1) lookups, TreeMap для sorted keys. В Java 21+ Sequenced Collections добавляют методы для ordered access (first/last). Избегайте legacy классов вроде Vector/Hashtable из-за синхронизации и низкой производительности. Для concurrent сценариев выбирайте concurrent реализации. Анализируйте trade-offs: HashSet быстр, но unordered; TreeSet sorted, но медленнее.

#### 2.8.3. Почему Map - это не Collection, в то время как List и Set являются Collection?
Map не является Collection, потому что представляет пары ключ-значение, а не одиночные элементы. Collection фокусируется на элементах, Map — на ассоциациях. <br>
Однако Map.values() возвращает Collection значений. <br>
Для junior: Map — "словарь", Collection — "список". Senior: Map.entrySet() дает Set<Map.Entry>; в streams Map ведет себя как Collection через entries.

Для junior: Collection — это контейнер для одиночных вещей, как коробка с яблоками. Map — это как книжка с адресами: ключ (имя) связан со значением (адрес). List и Set — виды коробок, но Map — отдельный шкаф. Не пытайтесь добавить Map в цикл for-each напрямую, используйте entrySet(). <br>
Senior: Хотя Map не наследует Collection, он интегрируется через методы вроде keySet(), values(), entrySet(), которые возвращают Collection-подобные views. В streams Map обрабатывается как источник entries. Это дизайн-решение для разделения concerns: Collection для групп элементов, Map для ассоциаций. В custom реализациях следуйте этому паттерну.

#### 2.8.4. В чем разница между классами java.util.Collection и java.util.Collections?
java.util.Collection — интерфейс, корень иерархии (методы add, remove, size). <br>
java.util.Collections — утилитный класс со статическими методами (sort, unmodifiableList, singleton). <br>
Для junior: Collection — интерфейс для коллекций, Collections — хелпер. Senior: Collections.synchronizedList() для thread-safety; в Java 9+ List.of() вместо Collections.emptyList().

Для junior: Collection — это "что" (интерфейс для списков, множеств), Collections — "как" (класс с полезными функциями, как сортировка). Например, Collections.sort(list) отсортирует ваш ArrayList. Не путайте: один — интерфейс, другой — utility. <br>
Senior: Collections предоставляет алгоритмы для манипуляций: binarySearch, reverse, shuffle. Методы вроде synchronizedList() оборачивают для thread-safety, но лучше использовать concurrent коллекции. В Java 9+ List.of() — immutable factory, предпочтительнее Collections.emptyList(). Помните, что Collections — final класс без экземпляров.

#### 2.8.5. Что такое «fail-fast поведение»?
Fail-fast: Итераторы выбрасывают ConcurrentModificationException при модификации коллекции во время итерации (чтобы предотвратить inconsistency). <br>
Реализовано через modCount: Итератор проверяет изменения. <br>
Примеры: ArrayList, HashMap. <br>
Для junior: "Быстро падает" при изменениях. Senior: Не fail-safe; для concurrent используйте CopyOnWriteArrayList; в streams избегайте модификаций.

Для junior: Fail-fast значит "быстро сломаться", если вы меняете коллекцию во время чтения. Например, в цикле for-each добавление элемента вызовет ошибку. Это защита от багов, но требует осторожности. Начните с простых итераций без изменений. <br>
Senior: ModCount — счетчик модификаций; итератор snapshot-ит его и сравнивает. Не fail-safe, как ConcurrentHashMap. В многопоточных средах используйте CopyOnWriteArrayList для read-heavy. В streams избегайте модификаций; для bulk operations — removeIf().

#### 2.8.6. Какая разница между fail-fast и fail-safe?
Fail-fast: Выбрасывает исключение при concurrent модификации (ArrayList). <br>
Fail-safe: Работает с копией, не выбрасывает (ConcurrentHashMap, CopyOnWriteArrayList). <br>
Пример fail-fast: 
```java
List<String> list = new ArrayList<>();
list.add("a");
for (String s : list) {
  list.add("b"); // ConcurrentModificationException
}
```
Fail-safe:
```java
ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
map.put("k", "v");
for (String key : map.keySet()) {
  map.put(key + "2", "v2"); // OK, работает с snapshot
}
```
Для junior: Fail-fast — "строгий", fail-safe — "терпимый". Senior: Fail-safe медленнее (копирование); ConcurrentHashMap сегментирован для partial locking.

Для junior: Fail-fast — строгий, бросает ошибку при изменениях во время чтения. Fail-safe — терпимый, работает даже если что-то меняется. Используйте fail-safe для многопоточных программ, но помните о производительности. <br>
Senior: Fail-safe использует snapshots или segmented locking, медленнее из-за overhead. ConcurrentHashMap сегментирован, позволяя partial updates. CopyOnWrite копирует весь массив на write. Выбирайте по сценарию: для frequent writes — fail-fast с synchronized; для reads — fail-safe.

#### 2.8.7. Чем различается Enumeration и Iterator?
Enumeration: Устаревший (Vector, Hashtable), методы hasMoreElements/nextElement, read-only. <br>
Iterator: Современный, hasNext/next/remove, позволяет модификацию. <br>
Для junior: Iterator — новый, с remove. Senior: Enumeration deprecated; используйте Iterator в loops; ListIterator для Lists.

Для junior: Enumeration — старый способ перебирать, как древний телевизор. Iterator — новый, с возможностью удаления. В коде используйте Iterator для современных коллекций; Enumeration только для legacy Vector. <br>
Senior: Enumeration не поддерживает remove, что ограничивает. Iterator универсален для всех Collection. В Java переходите на Iterator; для Lists — ListIterator. Помните о fail-fast в обоих.

#### 2.8.8. Как между собой связаны Iterable, Iterator и «for-each»?
Iterable: Интерфейс с iterator() — возвращает Iterator. <br>
Iterator: Для перебора (hasNext/next/remove). <br>
For-each: Синтаксис for (T item : collection) использует Iterable.iterator(). <br>
Для junior: Iterable — "перебираемый", for-each — упрощает. Senior: Custom Iterable для своих структур; в Java 14+ records могут реализовывать Iterable.

Для junior: Iterable — "то, что можно перебрать", Iterator — инструмент для перебора, for-each — удобный синтаксис. Любая коллекция — Iterable, так что for-each работает автоматически. <br>
Senior: Custom классы реализуют Iterable для поддержки for-each. Iterator — core, for-each — syntactic sugar. В Java 14+ records могут реализовывать Iterable. Используйте для lazy evaluation в streams.

#### 2.8.9. Сравните Iterator и ListIterator.
Iterator: Универсален, только вперед, remove. <br>
ListIterator: Только для List, вперед/назад (previous), add/set/remove, индексы. <br>
Для junior: ListIterator — "расширенный" для Lists. Senior: Используйте ListIterator для bidirectional traversal; не для Sets.

Для junior: Iterator — базовый, как прогулка вперед. ListIterator — продвинутый, может идти назад и вставлять. Используйте ListIterator для ArrayList, если нужно редактировать на ходу. <br>
Senior: ListIterator extends Iterator, добавляет bidirectional. Полезен для текстовых редакторов или undo. Не для Sets; для общего — Iterator. Индексы позволяют random access.

#### 2.8.10. Как поведёт себя коллекция, если вызвать iterator.remove()?
Если после next() — удалит текущий элемент. Иначе — IllegalStateException. <br>
Не работает с immutable коллекциями (List.of()). <br>
Для junior: Удаляет последний next(). Senior: Безопасно в fail-fast; для concurrent — используйте removeIf().

Для junior: Вызовите next(), потом remove() — удалит элемент. Без next() — ошибка. Это безопасный способ удаления во время итерации. <br>
Senior: Remove() сбрасывает состояние итератора. Для fail-fast коллекций — OK. Для immutable — UnsupportedOperationException. Альтернатива: removeIf(predicate) для bulk.

#### 2.8.11. Чем Set отличается от List?
Set: Уникальные элементы, без порядка (кроме SortedSet). <br>
List: Допускает дубликаты, упорядочен по индексу. <br>
Для junior: Set — "множество", List — "список с повторами". Senior: Set для lookups O(1), List для последовательного доступа.

Для junior: Set — как мешок уникальных вещей, List — список с возможными повторами. Если добавите дубликат в Set, он игнорируется. <br>
Senior: Set для membership checks, List для positional access. Выбирайте: HashSet для скорости, TreeSet для sorting. В streams Set полезен для distinct().

#### 2.8.12. Расскажите про интерфейс Set
Set: Расширяет Collection, уникальные элементы. <br>
Реализации: HashSet (hash), LinkedHashSet (insertion order), TreeSet (sorted). <br>
Для junior: Set — без дубликатов. Senior: NavigableSet для ranges; в Java 21+ LinkedHashSet insertion-ordered.

Для junior: Set — контейнер без дубликатов. HashSet — быстрый, но без порядка; TreeSet — отсортированный. Начните с HashSet для простоты. <br>
Senior: NavigableSet (TreeSet) для ranges (subSet). В Java 21+ LinkedHashSet гарантирует insertion order. Используйте для уникальности; для ordered — List.

#### 2.8.13. Что будет если добавлять элементы в TreeSet по возрастанию?
TreeSet использует красное-черное дерево; добавление по порядку создаст несбалансированное дерево (вырожденное в список), но Java балансирует автоматически. <br>
Производительность: O(log n), но хуже для sorted input. <br>
Для junior: Дерево балансируется. Senior: В худшем случае O(n); используйте HashSet для unordered.

Для junior: Дерево само балансируется, так что порядок добавления не сломает его. Но лучше добавлять случайно для лучшей производительности. <br>
Senior: В худшем случае O(n) для вставки, но rebalancing исправляет. Для sorted data используйте TreeSet с caution; HashSet лучше для unordered. Анализируйте с JMH.

#### 2.8.14. Как устроен HashSet, сложность основных операций
HashSet: Основа — HashMap (элементы как ключи, dummy value). <br>
Сложность: add/get/remove O(1) в среднем, O(n) в худшем (коллизии). <br>
Для junior: Хэш-таблица под капотом. Senior: Load factor 0.75; resize 2x; с Java 8+ treeify при коллизиях.

Для junior: HashSet — как HashMap без значений. Быстрые операции благодаря хэшу. Коллизии редки, но возможны. <br>
Senior: Load factor 0.75; resize удваивает. С Java 8+ treeify при длинных chains. Mutable keys — риск. Для custom equals/hashCode — тщательно.

#### 2.8.15. Как устроен LinkedHashSet сложность основных операций
LinkedHashSet: HashSet + LinkedList для порядка вставки. <br>
Сложность: add/get/remove O(1) amortized. <br>
Для junior: Сохраняет порядок добавления. Senior: Двойная структура (hash + links); больше памяти; для LRU — LinkedHashMap.

Для junior: Сохраняет порядок добавления, как список, но уникальный. Немного медленнее HashSet из-за ссылок. <br>
Senior: Двойная структура: hash для скорости, links для order. Больше памяти. Для LRU — LinkedHashMap с accessOrder. Не для sorting.

#### 2.8.16. Как устроен TreeSet сложность основных операций
TreeSet: Основа — TreeMap (красное-черное дерево). <br>
Сложность: add/get/remove O(log n). <br>
Для junior: Сортированное дерево. Senior: Natural order или Comparator; NavigableSet для subSet; медленнее HashSet.

Для junior: Отсортированное множество, как дерево. Медленнее HashSet, но всегда упорядочено. <br>
Senior: Natural order или Comparator. NavigableSet для ceiling/floor. Медленнее для больших данных; альтернатива — sorted List с binarySearch.

#### 2.8.17. Расскажите про интерфейс List
List: Упорядоченная Collection с индексами (get(i), add(i)). <br>
Реализации: ArrayList, LinkedList. <br>
Для junior: Список с позициями. Senior: RandomAccess для быстрых индексов; в Java 21+ SequencedCollection.

Для junior: List — список с позициями, как массив, но гибкий. Можно вставлять в середину. <br>
Senior: RandomAccess для быстрых индексов. В Java 21+ SequencedCollection. Для immutable — List.of(). Выбирайте по access pattern.

#### 2.8.18. Как устроен ArrayList сложность основных операций
ArrayList: Массив Object[], resize 1.5x. <br>
Сложность: get O(1), add(end) O(1) amortized, add(i) O(n), remove O(n). <br>
Для junior: Массив, растет динамически. Senior: Initial capacity 10; trimToSize(); для big data — LinkedList; memory overhead низкий.

Для junior: Массив внутри, растет при заполнении. Быстрый доступ по индексу, но вставка в середину дорогая. <br>
Senior: Initial capacity 10; trimToSize(). SubList shared. Для big data — memory efficient. Concurrent — CopyOnWriteArrayList.

#### 2.8.19. Как устроен LinkedList сложность основных операций
LinkedList: Двусвязный список (Node с prev/next). <br>
Сложность: get O(n), addFirst/Last O(1), removeFirst/Last O(1), add(i)/remove(i) O(n). <br>
Для junior: Ссылки между элементами. Senior: Реализует Deque; для queues лучше; memory overhead высокий (2 pointers).

Для junior: Элементы связаны ссылками. Быстрые добавления на концах, но медленный доступ по индексу. <br>
Senior: Реализует Deque. Memory overhead (2 pointers). Для queues — ArrayDeque лучше. Не для random access.

#### 2.8.20. Почему LinkedList реализует и List и Deque
Deque: Двусторонняя очередь (addFirst/addLast). LinkedList подходит, так как эффективны операции на концах. <br>
Для junior: Для очередей с двух сторон. Senior: В Java 6+; альтернатива ArrayDeque (без legacy).

Для junior: LinkedList — как очередь с двух сторон. Полезно для стеков и очередей. <br>
Senior: В Java 6+ для compatibility. ArrayDeque — better для Deque (no legacy). Используйте для FIFO/LIFO.

#### 2.8.21. Как перестроить Связанный список в HashTable
Неправильный термин; вероятно, "LinkedList в HashSet". HashSet использует hash; для конверсии: new HashSet<>(linkedList). <br>
Или для hashing LinkedList: Переопределить hashCode (но не рекомендуется). <br>
Для junior: Создать HashSet из List. Senior: Для уникальности; hashCode должен быть consistent; избегайте mutable keys.

Для junior: Создать HashSet из LinkedList для уникальности. HashSet хэширует элементы. <br>
Senior: Конверсия O(n). Для mutable LinkedList — override hashCode/equals. Но лучше immutable keys. Не хэшируйте сам список.

#### 2.8.22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?
Ключи должны реализовывать equals и hashCode (consistent: равные объекты — равный hash). <br>
Идеально: Immutable (String, Integer). <br>
Для junior: equals и hashCode. Senior: Mutable keys опасны (изменение ломает map); в Java 8+ hash улучшен; для custom — @Override оба.

Для junior: Ключи должны быть "сравнимы" через equals и hashCode. Изменяемые ключи — плохо. <br>
Senior: Mutable keys ломают map при изменении. @Override оба метода. В Java 8+ hash улучшен. Для custom — final поля.

#### 2.8.23. Как работает HashMap?
**HashMap** хранит пары ключ-значение в массиве **buckets** (ячеек), где каждый **bucket** — это **linked list** или **red-black tree** узлов **Node<K,V>**. <br>
**Put** (вставка): Вычисляется **hash(key)**, индекс = **(n-1) & hash** (n — размер таблицы). Если коллизия (ключ уже есть или другой с тем же индексом), элемент добавляется в **list** или **tree**. <br>
С **Java 8+**: Каждый **bucket** начинается как **linked list**. Если длина списка превышает **TREEIFY_THRESHOLD** (8), проверяется размер таблицы: если **table.length >= MIN_TREEIFY_CAPACITY** (64), **bucket** конвертируется в **red-black tree** для **O(log n)** поиска вместо **O(n)** в худшем случае; иначе выполняется **resize** таблицы для снижения коллизий (таблица удваивается, элементы перехэшируются). Это предотвращает деградацию производительности при многих коллизиях. <br>
Обратно: Если после удалений дерево сжимается до **UNTREEIFY_THRESHOLD** (6), оно возвращается к **linked list** для экономии памяти. <br>
**Resize**: Происходит при превышении **load factor** (0.75 по умолчанию) — таблица удваивается в размере. <br>
**Get** (чтение): По **hash** находим **bucket**, затем проходим по **tree** (быстро) или **list** (линейно). <br>
Для **junior**: **Хэш** превращает ключ в индекс для быстрого доступа. При коллизиях элементы цепляются в **список**, но если список слишком длинный (больше 8 элементов) и таблица достаточно большая (минимум 64 **buckets**), он превращается в **дерево** для ускорения поиска. Иначе таблица просто расширяется. Это как перестроить беспорядок в организованную структуру, но только когда "места" хватает. **HashMap** быстрая, но не сохраняет порядок элементов. <br>
**Senior**: Вычисление **hash** улучшено: **hash = key.hashCode() ^ (h >>> 16)** для

#### 2.8.24. Как строиться красное-черное дерево?
Красное-черное дерево: Самобалансирующее BST (каждый путь ~равен). <br>
Вставка: Добавить как BST, затем rebalance (rotations, recolor) для соблюдения правил (root black, no 2 reds подряд, black height equal). <br>
Для TreeMap/TreeSet. <br>
Для junior: Балансируется автоматически. Senior: Гарантирует O(log n); в Java TreeMap использует; альтернатива AVL, но RB проще для concurrent.

Для junior: Дерево балансируется само при добавлении. Гарантирует быстрый поиск. <br>
Senior: Гарантирует O(log n). В Java TreeMap. Rotations: left/right. Recolor для balance. Альтернатива AVL.

#### 2.8.25. На чем основана HashSet?
HashSet основан на HashMap: Элементы — ключи, value — dummy Object. <br>
Для junior: HashMap без значений. Senior: Делит hash логику; synchronized — LinkedHashSet; null allowed.

Для junior: HashSet — оболочка над HashMap. Делит логику хэширования. <br>
Senior: Экономит код. Synchronized — LinkedHashSet. Null allowed. Для ordered — TreeSet.

#### 2.8.26. Какая структура подходит для хранения большого количества данных
Зависит: ArrayList для random access, LinkedList для insertions/deletions, HashSet для уникальных. <br>
Для большого: ArrayList (low memory), или ConcurrentSkipListSet для sorted concurrent. <br>
Для junior: ArrayList. Senior: Для миллиардов — off-heap (ByteBuffer); streams для processing.

Для junior: ArrayList для простоты и скорости доступа. <br>
Senior: Для миллиардов — off-heap (ByteBuffer). Streams для processing. Анализируйте memory/CPU trade-offs.

#### 2.8.27. Что может быть ключем в HashMap?
Любой Object, но предпочтительно immutable (String, Integer). <br>
Mutable (ArrayList) — риск, если изменится hash/equals. <br>
Для junior: Object с equals/hashCode. Senior: Wrapper types; custom keys — final поля; WeakHashMap для weak keys.

Для junior: Любые объекты, но лучше неизменяемые, как String. <br>
Senior: Wrapper types. Custom keys — final. WeakHashMap для GC keys.

#### 2.8.28. Параметры ArrayList
Initial capacity: 10. <br>
Load factor: N/A (manual resize). <br>
Growth: newCapacity = oldCapacity + (oldCapacity >> 1) (1.5x). <br>
Methods: add(E) — end, set(int, E) — replace. <br>
Для junior: Начинается с 10, растет в 1.5 раза. Senior: ensureCapacity() для prealloc; subList() shared backing.

Для junior: Начинается с 10, растет в 1.5 раза. Полезно знать для оптимизации. <br>
Senior: ensureCapacity() prealloc. SubList shared backing — осторожно с modifications.

#### 2.8.29. Stack
Stack: Устаревший (extends Vector), LIFO. <br>
Methods: push/pop/peek. <br>
Пример:
```java
Stack<Card> deck = new Stack<>();
deck.push(new Card("Рагнарос"));
deck.push(new Card("Пират Глазастик"));

System.out.println(deck.peek()); // Пират Глазастик
System.out.println(deck.pop()); // Пират Глазастик
```
Для junior: LIFO стек. Senior: Deprecated; используйте Deque (ArrayDeque); thread-safe — ConcurrentLinkedDeque.

Для junior: Стек — как стопка тарелок. Последний добавленный — первый извлекаемый. <br>
Senior: Deprecated; используйте Deque (ArrayDeque). Thread-safe — ConcurrentLinkedDeque.

#### 2.8.30. Comparator vs Comparable
Comparable: Интерфейс для natural order (compareTo(T)). Реализуется в классе. <br>
Comparator: External comparator (compare(T1,T2)). Для custom sorting. <br>
Пример: Collections.sort(list, comparator). <br>
Для junior: Comparable — в классе, Comparator — отдельно. Senior: Comparator.thenComparing(); в Java 8+ lambdas; nullsFirst().

Для junior: Comparable — в классе для естественного порядка, Comparator — отдельный для кастомного. <br>
Senior: Comparator.thenComparing(). Lambdas в Java 8+. NullsFirst().

#### 2.8.31. Какие есть конкурентные коллекции в Java?
Concurrent collections: ConcurrentHashMap, CopyOnWriteArrayList, ConcurrentLinkedQueue, BlockingQueue (ArrayBlockingQueue). <br>
Отличия: Thread-safe без synchronized (locks сегментов). <br>
Для junior: Без блокировок. Senior: ConcurrentHashMap — segmented; для read-heavy — CopyOnWrite; в Java 21+ Sequenced Collections concurrent.

Для junior: Коллекции для многопоточных программ без блокировок. <br>
Senior: ConcurrentHashMap segmented. CopyOnWrite для read-heavy. Java 21+ sequenced.

#### 2.8.32. Как работает Stream API с коллекциями?
Stream: Lazy sequence от коллекций (collection.stream()). <br>
Operations: Intermediate (filter, map) — lazy, Terminal (collect, forEach) — eager. <br>
Пример: list.stream().filter(x -> x > 0).collect(Collectors.toList()). <br>
Для junior: Для обработки данных. Senior: Parallel streams (parallelStream()); avoid side-effects; Collectors для grouping; в Java 9+ takeWhile/dropWhile.

Для junior: Streams — для обработки данных, как фильтр и сборка. <br>
Senior: Parallel streams. Avoid side-effects. Collectors grouping. Java 9+ takeWhile.

### END ---------------- 2.8. Коллекции ----------------

## END ---------------- 2. Java ----------------

## 3. Memory Management

+ [3.1. Garbage Collection](#31-garbage-collection)
  <details>
  	<summary>Навигация</summary>

    + [3.1.1. Как устроена память в Java?](#311-как-устроена-память-в-java)
    + [3.1.2. Что является мусором (garbage) в Java?](#312-что-является-мусором-garbage-в-java)
    + [3.1.3. Этапы сборки мусора](#313-этапы-сборки-мусора)
    + [3.1.4. Что означают поколения объектов?](#314-что-означают-поколения-объектов)
    + [3.1.5. Зачем нужны поколения объектов?](#315-зачем-нужны-поколения-объектов)
    + [3.1.6. Как происходит заполнение областей памяти?](#316-как-происходит-заполнение-областей-памяти)
    + [3.1.7. Какие есть сборщики мусора в Java?](#317-какие-есть-сборщики-мусора-в-java)
    + [3.1.8. Как работает сборщик CMS GC (Concurrent Mark Sweep)?](#318-как-работает-сборщик-cms-gc-concurrent-mark-sweep)
    + [3.1.9. Как работает G1 GC (Garbage First)?](#319-как-работает-g1-gc-garbage-first)
    + [3.1.10. Что такое Minor GC и Major GC?](#3110-что-такое-minor-gc-и-major-gc)
    + [3.1.11. Как настроить параметры сборки мусора?](#3111-как-настроить-параметры-сборки-мусора)
    + [3.1.12. Какие бывают ссылки в Java и в чем их отличия?](#3112-какие-бывают-ссылки-в-java-и-в-чем-их-отличия)
    + [3.1.13. Чистит ли GC String Pool?](#3113-чистит-ли-gc-string-pool)
  </details>

+ [3.2. Java Memory Model (JMM)](#32-java-memory-model-jmm)
  <details>
  	<summary>Навигация</summary>

    + [3.2.1. Что обозначает JMM?](#321-что-обозначает-jmm)
    + [3.2.2. Зачем нужен JMM?](#322-зачем-нужен-jmm)
    + [3.2.3. Ключевые концепции JMM](#323-ключевые-концепции-jmm)
    + [3.2.4. Что такое happens-before в JMM?](#324-что-такое-happens-before-в-jmm)
    + [3.2.5. Как избежать race conditions с помощью JMM?](#325-как-избежать-race-conditions-с-помощью-jmm)
    + [3.2.6. Что такое volatile в контексте JMM?](#326-что-такое-volatile-в-контексте-jmm)
    + [3.2.7. Как JMM влияет на производительность?](#327-как-jmm-влияет-на-производительность)
  </details>

+ [3.3. Ссылки и Области Памяти](#33-ссылки-и-области-памяти)
  <details>
  	<summary>Навигация</summary>

    + [3.3.1. Какие бывают ссылки в Java и в чем их отличия?](#331-какие-бывают-ссылки-в-java-и-в-чем-их-отличия)
    + [3.3.2. Что такое soft, weak, phantom ссылки?](#332-что-такое-soft-weak-phantom-ссылки)
    + [3.3.3. Чистит ли GC String Pool?](#333-чистит-ли-gc-string-pool)
    + [3.3.4. Что такое Heap, Stack и Metaspace?](#334-что-такое-heap-stack-и-metaspace)
    + [3.3.5. Как происходит переполнение стека (StackOverflowError)?](#335-как-происходит-переполнение-стека-stackoverflowerror)
    + [3.3.6. Что такое ReferenceQueue и зачем она нужна?](#336-что-такое-referencequeue-и-зачем-она-нужна)
    + [3.3.7. Как области памяти влияют на производительность и GC?](#337-как-области-памяти-влияют-на-производительность-и-gc)
  </details>

+ [3.4. Профилирование и Мониторинг](#34-профилирование-и-мониторинг)
  <details>
  	<summary>Навигация</summary>

    + [3.4.1. Какие инструменты для профилирования памяти в Java?](#341-какие-инструменты-для-профилирования-памяти-в-java)
    + [3.4.2. Как выявить утечку памяти?](#342-как-выявить-утечку-памяти)
    + [3.4.3. Что такое heap dump и как его анализировать?](#343-что-такое-heap-dump-и-как-его-анализировать)
    + [3.4.4. Что такое JFR (Java Flight Recorder) и как его использовать?](#344-что-такое-jfr-java-flight-recorder-и-как-его-использовать)
    + [3.4.5. Как мониторить JVM с помощью JMX?](#345-как-мониторить-jvm-с-помощью-jmx)
  </details>

### 3.1. Garbage Collection

+ [3.1.1. Как устроена память в Java?](#311-как-устроена-память-в-java)
+ [3.1.2. Что является мусором (garbage) в Java?](#312-что-является-мусором-garbage-в-java)
+ [3.1.3. Этапы сборки мусора](#313-этапы-сборки-мусора)
+ [3.1.4. Что означают поколения объектов?](#314-что-означают-поколения-объектов)
+ [3.1.5. Зачем нужны поколения объектов?](#315-зачем-нужны-поколения-объектов)
+ [3.1.6. Как происходит заполнение областей памяти?](#316-как-происходит-заполнение-областей-памяти)
+ [3.1.7. Какие есть сборщики мусора в Java?](#317-какие-есть-сборщики-мусора-в-java)
+ [3.1.8. Как работает сборщик CMS GC (Concurrent Mark Sweep)?](#318-как-работает-сборщик-cms-gc-concurrent-mark-sweep)
+ [3.1.9. Как работает G1 GC (Garbage First)?](#319-как-работает-g1-gc-garbage-first)
+ [3.1.10. Что такое Minor GC и Major GC?](#3110-что-такое-minor-gc-и-major-gc)
+ [3.1.11. Как настроить параметры сборки мусора?](#3111-как-настроить-параметры-сборки-мусора)
+ [3.1.12. Какие бывают ссылки в Java и в чем их отличия?](#3112-какие-бывают-ссылки-в-java-и-в-чем-их-отличия)
+ [3.1.13. Чистит ли GC String Pool?](#3113-чистит-ли-gc-string-pool)

#### 3.1.1. Как устроена память в Java?
В Java память управляется JVM и делится на несколько областей для эффективного выполнения программ. Основные компоненты:

- **Native Memory**: Вся доступная системная память, включая память, используемую JVM и приложением.
- **Heap (куча)**: Основная область для хранения объектов JVM. Это общее пространство для всех потоков приложения. Heap делится на Young Generation и Old Generation для оптимизации сборки мусора.
- **Stack (стек)**: Используется для хранения локальных переменных, параметров методов и стека вызовов. Каждый поток имеет свой собственный стек, что обеспечивает изоляцию данных.
- **Metaspace (метаданные)**: Хранит метаданные классов, такие как информация о полях, методах и константах. Ранее назывался PermGen. Это общее пространство, заменяющее PermGen в Java 8+.
- **CodeCache (кэш кода)**: JIT-компилятор компилирует часто исполняемый байт-код в нативный машинный код и кэширует его для ускорения выполнения. Это повышает производительность, но требует памяти.

Эти области управляются JVM автоматически, но разработчики могут влиять на них через параметры запуска (например, -Xmx для Heap).

#### 3.1.2. Что является мусором (garbage) в Java?
Мусором (garbage) в Java считаются объекты, которые больше не доступны для использования программой. Объект становится мусором, если на него нет ни одной сильной (strong) ссылки от корневых объектов (root references), таких как локальные переменные, статические поля или объекты в стеке. Сборщик мусора (GC) автоматически находит и удаляет такие объекты, освобождая память.

Важно: GC не удаляет объекты немедленно — он работает асинхронно. Для junior-разработчиков это означает, что утечки памяти могут происходить из-за ненужных ссылок (например, статические коллекции). Senior-разработчики используют инструменты вроде VisualVM для анализа heap dumps и выявления утечек.

#### 3.1.3. Этапы сборки мусора
Сборка мусора (GC) в Java обычно состоит из трех основных этапов, хотя конкретные шаги зависят от сборщика. Общий алгоритм (например, в Serial GC):

- **Mark (маркировка)**: GC сканирует все объекты и помечает живые (доступные из корней). Это обычно вызывает паузу (Stop-the-World), чтобы избежать изменений во время сканирования.
- **Sweep (очистка)**: Освобождается память, занятая объектами, не помеченными как живые. Память становится фрагментированной.
- **Compact (уплотнение)**: Объекты, пережившие очистку, перемещаются в единый непрерывный блок памяти для минимизации фрагментации и улучшения производительности аллокации.

Для junior: Это базовый процесс. Senior: Разные сборщики (например, G1) модифицируют эти этапы для параллельной работы, снижая паузы. Примеры: CMS пропускает compact для скорости, но может фрагментировать память.

#### 3.1.4. Что означают поколения объектов?
Объекты в Java делятся на поколения для оптимизации GC, основываясь на гипотезе о поколениях: большинство объектов умирают молодыми.

- **Young Generation (молодое поколение)**:
    - **Eden**: Здесь создаются новые объекты.
    - **Survivor Spaces (S0 и S1)**: Области для выживших объектов после minor GC.
- **Old Generation (Tenured)**: Долго живущие объекты, пережившие несколько minor GC.

В Java 8+ Old Generation называется Tenured. Это разделение позволяет GC фокусироваться на областях с высоким оборотом мусора.

#### 3.1.5. Зачем нужны поколения объектов?
Поколения оптимизируют GC, основываясь на наблюдении, что:
- Большинство объектов живут недолго (создаются и быстро умирают).
- Если объект выживает несколько GC, он, вероятно, будет жить долго.

Преимущества:
- **Быстрая обработка**: Mark и sweep быстрее в Young Generation, где много мусора.
- **Снижение пауз**: Полная сборка (major GC) происходит реже, только для Old Generation.
- **Эффективность**: Избегает сканирования всей кучи каждый раз.

Для senior: Это снижает latency в приложениях с высокой аллокацией, но требует настройки (например, -XX:NewRatio).

#### 3.1.6. Как происходит заполнение областей памяти?
Процесс заполнения памяти в Java связан с аллокацией и GC:

1. Новые объекты создаются в **Eden** (Young Generation).
2. Когда Eden заполняется, происходит **Minor GC** (быстрая сборка для Young Generation): живые объекты копируются в S0 (Survivor).
3. При следующем Minor GC: объекты из Eden и S0 копируются в S1, возраст объектов увеличивается. S0 и S1 меняются ролями.
4. Объекты, пережившие несколько копирований (возраст > порога, обычно 15), перемещаются в **Old Generation**.
5. Когда Old Generation заполняется, происходит **Major GC** (или Full GC): сборка для всей кучи.

Это предотвращает фрагментацию и оптимизирует память. Senior: Настройка размеров поколений (например, -Xmn) влияет на частоту GC.

#### 3.1.7. Какие есть сборщики мусора в Java?
JVM предоставляет несколько сборщиков мусора, каждый с преимуществами и недостатками. Основные:

| Сборщик мусора | Описание | Преимущества | Когда использовать | Флаги для включения |
|----------------|----------|--------------|---------------------|---------------------|
| **Serial GC** | Однопоточный, использует один поток для GC. | Низкие накладные расходы, эффективен на малых кучах. | Однопроцессорные машины, небольшие приложения, где паузы приемлемы. | -XX:+UseSerialGC |
| **Parallel GC** | Многопоточный, использует несколько потоков. | Высокая пропускная способность, ускоряет GC. | Многопроцессорные системы, приложения с большими данными, где важна производительность, а паузы до 1 сек приемлемы. | -XX:+UseParallelGC |
| **CMS (Concurrent Mark Sweep)** | Работает параллельно с приложением, избегает длинных пауз. | Низкая latency, подходит для интерактивных приложений. | Когда важны короткие паузы (до 100 мс), но возможна фрагментация. | -XX:+UseConcMarkSweepGC |
| **G1 GC** | Региональный, ориентирован на большие кучи, минимизирует паузы. | Баланс пропускной способности и latency, масштабируемый. | Большие кучи (>4GB), многопроцессорные системы, где паузы <1 сек важны. | -XX:+UseG1GC |
| **ZGC** | Низколатентный, работает параллельно, для очень больших куч. | Минимальные паузы (<10 мс), высокая пропускная способность. | Приложения с требованием низкой задержки, большие кучи (до TB). | -XX:+UseZGC |
| **Shenandoah** | Аналогично ZGC, но с фокусом на concurrency. | Низкие паузы, компактификация без STW. | Подобно ZGC, для больших систем. | -XX:+UseShenandoahGC |

Выбор зависит от требований: latency vs throughput. Senior-разработчики тестируют с JMH или профилируют.

#### 3.1.8. Как работает сборщик CMS GC (Concurrent Mark Sweep)?
CMS (Concurrent Mark Sweep) — сборщик для низких пауз, работает параллельно с приложением. Использует ту же организацию памяти (Young/Old), но оптимизирует Old Generation.

Этапы:
1. **Initial Mark (начальная маркировка)**: STW-пауза, помечает корневые объекты.
2. **Concurrent Marking**: Параллельно с приложением помечает все живые объекты.
3. **Remark (финальная маркировка)**: STW-пауза, корректирует маркировку (использует SATB для учета изменений).
4. **Concurrent Sweep**: Параллельно очищает мертвые объекты, без уплотнения (может фрагментировать память).

Преимущества: Низкие паузы. Недостатки: Плавающий мусор, фрагментация (требует Full GC). Для senior: Подходит для веб-серверов, но устарел в Java 9+ (заменен G1).

#### 3.1.9. Как работает G1 GC (Garbage First)?
G1 — региональный сборщик для больших куч (>4GB), минимизирует паузы. Куча делится на регионы (~1-32MB).

**Структура**: Регионы логически делятся на Eden, Survivor, Old. Регионы могут менять роли.

**Принцип**:
1. **Young Collection**: Minor GC копирует выживших в регионы Survivor/Old.
2. **Mixed Collection**: После цикла маркировки очищает Young + часть Old регионов.
3. **Цикл маркировки**: Initial Mark (STW), Concurrent Marking, Remark (STW с SATB), Cleanup (STW).

Выбирает регионы с максимальным мусором для очистки. Преимущества: Предсказуемые паузы, масштабируемость. Senior: Настраивается через -XX:MaxGCPauseMillis.

#### 3.1.10. Что такое Minor GC и Major GC?
- **Minor GC**: Сборка в Young Generation. Быстрая, копирует выживших в Survivor/Old. Происходит часто, вызывает короткие паузы.
- **Major GC (или Full GC)**: Сборка в Old Generation (и иногда всей кучи). Более медленная, вызывает длинные паузы. Включает mark-sweep-compact.

В G1 Major GC — это mixed collection. Для junior: Minor GC — для молодых объектов, Major — для старых. Senior: Мониторят через JMX, настраивают для избежания OOM.

#### 3.1.11. Как настроить параметры сборки мусора?
Настройка GC включает JVM-флаги для оптимизации производительности. Основные:

- **Выбор сборщика**: -XX:+UseG1GC, -XX:+UseParallelGC и т.д.
- **Размеры кучи**: -Xmx (max heap), -Xms (initial heap), -Xmn (Young size).
- **Паузы**: -XX:MaxGCPauseMillis (для G1), -XX:GCTimeRatio (пропускная способность).
- **Поколения**: -XX:NewRatio (Old/Young), -XX:SurvivorRatio.
- **Другие**: -XX:+PrintGCDetails (логи), -XX:+HeapDumpOnOutOfMemoryError.

Пример: java -Xmx4g -Xms2g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 MyApp. Senior: Профилируют с VisualVM, тестируют нагрузку. Неправильная настройка может вызвать OOM или частые паузы.

#### 3.1.12. Какие бывают ссылки в Java и в чем их отличия?
В Java ссылки — это указатели на объекты, влияющие на GC. Типы:

- **Strong Reference**: Обычная ссылка (`Object obj = new Object();`). GC не удалит объект, пока есть strong ссылка. Самая сильная.
- **Soft Reference**: `SoftReference<Object> ref = new SoftReference<>(obj);`. Удаляется только при нехватке памяти. Подходит для кэшей (например, картинки).
- **Weak Reference**: `WeakReference<Object> ref = new WeakReference<>(obj);`. Удаляется при следующем GC, если нет strong/soft. Для метаданных или кэшей с коротким сроком.
- **Phantom Reference**: `PhantomReference<Object> ref = new PhantomReference<>(obj, queue);`. Не предотвращает удаление, используется для финализации (например, освобождение ресурсов).

Отличия: Сила влияния на GC. Strong — полная защита, Phantom — минимальная. Senior: Используют для управления памятью в кэшах (Guava Cache).

#### 3.1.13. Чистит ли GC String Pool?
String Pool — область для интернированных строк (статический пул уникальных строк).

- До Java 7: Pool в PermGen, GC не чистил (мог вызвать OOM).
- С Java 7: Pool в Heap, GC может очистить неиспользуемые строки.

GC очищает, если нет ссылок. Однако, intern() создает strong ссылки, так что pool может расти. Senior: Мониторят с heap dumps, избегают чрезмерного intern() для предотвращения утечек.

### END ---------------- 3.1. Garbage Collection ----------------

### 3.2. Java Memory Model (JMM)

+ [3.2.1. Что обозначает JMM?](#321-что-обозначает-jmm)
+ [3.2.2. Зачем нужен JMM?](#322-зачем-нужен-jmm)
+ [3.2.3. Ключевые концепции JMM](#323-ключевые-концепции-jmm)
+ [3.2.4. Что такое happens-before в JMM?](#324-что-такое-happens-before-в-jmm)
+ [3.2.5. Как избежать race conditions с помощью JMM?](#325-как-избежать-race-conditions-с-помощью-jmm)
+ [3.2.6. Что такое volatile в контексте JMM?](#326-что-такое-volatile-в-контексте-jmm)
+ [3.2.7. Как JMM влияет на производительность?](#327-как-jmm-влияет-на-производительность)

#### 3.2.1. Что обозначает JMM?
JMM (Java Memory Model) — это спецификация, определяющая, как Java-программы взаимодействуют с памятью. <br>
Она описывает правила видимости и упорядочения операций над переменными в многопоточных приложениях. <br>
JMM — это абстракция, скрывающая от разработчика сложности взаимодействия с аппаратной памятью и кешами процессоров. <br>
Для junior-разработчиков: Это как "правила дорожного движения" для потоков — без них хаос. Senior-разработчики знают, что JMM эволюционировал (JSR-133 в Java 5+), устранив проблемы предыдущих версий, как double-checked locking без volatile.

#### 3.2.2. Зачем нужен JMM?
Без JMM, поведение многопоточных программ на разных платформах было бы непредсказуемым. <br>
Разные процессоры и операционные системы имеют свои собственные модели памяти, и код, который работает корректно на одном компьютере, может давать сбои на другом. <br>
JMM предоставляет единую модель памяти для всех платформ, обеспечивая переносимость и предсказуемость Java-приложений. <br>
Для junior: Гарантирует, что ваш код работает одинаково на Intel и ARM. Senior: JMM предотвращает race conditions, но требует явной синхронизации; без неё оптимизации компилятора (например, reordering) могут сломать логику.

#### 3.2.3. Ключевые концепции JMM
- Видимость (Visibility): Гарантирует, что изменения, внесенные одним потоком в переменную, будут видны другим потокам. <br>
  Без этой гарантии, один поток мог бы читать устаревшее значение переменной, даже если другой поток уже его изменил. <br>
- Упорядочение (Ordering): Определяет порядок выполнения операций над переменными. <br>
  В однопоточной программе порядок операций обычно интуитивно понятен. <br>
  Однако, в многопоточной программе, порядок выполнения операций может быть переупорядочен компилятором или процессором для повышения производительности. <br>
  JMM гарантирует, что определенные операции будут выполняться в заданном порядке, предотвращая race conditions. <br>
- Операции памяти: JMM определяет абстрактные операции памяти, такие как read, load, use, assign, store, write. Эти операции отражают то, как данные перемещаются между основной памятью и кэшами процессоров. <br>
- Основные механизмы синхронизации: JMM полагается на механизмы синхронизации, такие как synchronized блоки, volatile переменные и <br>
  locks (например, из java.util.concurrent.locks пакета), для обеспечения правильной видимости и упорядочения. <br>
  Эти механизмы обеспечивают межпотоковые барьеры, гарантируя, что некоторые операции будут выполнены до других. <br>
  Для junior: Видимость — как "обновление экрана" для других потоков. Senior: Упорядочение предотвращает reordering, но final fields имеют особые правила (final freeze).

#### 3.2.4. Что такое happens-before в JMM?
Happens-before — это частичный порядок выполнения, который определяет, какие операции происходят до других. <br>
Это ключевой механизм, обеспечивающий видимость и упорядочение. <br>
Например, запись в переменную happens-before чтение этой же переменной другим потоком, если это чтение происходит после надлежащей синхронизации (например, использование volatile, synchronized или locks). <br>
Happens-before транзитивен: если A happens-before B, и B happens-before C, то A happens-before C. <br>
Для junior: Это "цепочка событий" — гарантирует порядок. Senior: Используется для доказательства корректности; инструменты вроде JCStress тестируют happens-before нарушения.

#### 3.2.5. Как избежать race conditions с помощью JMM?
Race conditions возникают, когда несколько потоков одновременно изменяют общие данные без синхронизации, приводя к непредсказуемым результатам. <br>
JMM помогает избежать их через гарантии видимости и упорядочения: <br>
- Используйте synchronized блоки: Обеспечивают эксклюзивный доступ и happens-before. <br>
- Volatile переменные: Гарантируют видимость изменений, но не атомарность операций (например, ++ не атомарен). <br>
- Locks (ReentrantLock): Более гибкие, чем synchronized, с явными lock/unlock. <br>
- Atomic классы (AtomicInteger): Атомарные операции без блокировок. <br>
  Для junior: Всегда синхронизируйте shared state. Senior: Профилируйте с Thread Sanitizer; избегайте false sharing (padding полей).

#### 3.2.6. Что такое volatile в контексте JMM?
Volatile — ключевое слово для переменных, обеспечивающее видимость и упорядочение в JMM. <br>
- Видимость: Запись в volatile переменную сразу видна всем потокам (как будто в main memory). <br>
- Упорядочение: Операции с volatile создают барьеры, предотвращая reordering. <br>
  Неатомарно для сложных операций (например, volatile int x; x++ не атомарен). <br>
  Для junior: Используйте для флагов (boolean running). Senior: Volatile дешевле synchronized, но не заменяет locks; в Java 9+ volatile работает с VarHandles.

#### 3.2.7. Как JMM влияет на производительность?
JMM добавляет накладные расходы для гарантий, но оптимизирован: <br>
- Компилятор/процессор могут reordering, но не нарушают happens-before. <br>
- Volatile/locks добавляют барьеры (memory fences), замедляя доступ к памяти. <br>
- В высоко конкурентных приложениях (например, с CAS в Atomic) производительность выше, чем с locks. <br>
  Для junior: Синхронизация медленнее, но необходима. Senior: Настраивайте с -XX:+PrintCompilation; используйте JMH для измерения; JMM эволюционирует (например, relaxed memory в Project Loom).

### END ---------------- 3.2. Java Memory Model (JMM) ----------------

### 3.3. Ссылки и Области Памяти

+ [3.3.1. Какие бывают ссылки в Java и в чем их отличия?](#331-какие-бывают-ссылки-в-java-и-в-чем-их-отличия)
+ [3.3.2. Что такое soft, weak, phantom ссылки?](#332-что-такое-soft-weak-phantom-ссылки)
+ [3.3.3. Чистит ли GC String Pool?](#333-чистит-ли-gc-string-pool)
+ [3.3.4. Что такое Heap, Stack и Metaspace?](#334-что-такое-heap-stack-и-metaspace)
+ [3.3.5. Как происходит переполнение стека (StackOverflowError)?](#335-как-происходит-переполнение-стека-stackoverflowerror)
+ [3.3.6. Что такое ReferenceQueue и зачем она нужна?](#336-что-такое-referencequeue-и-зачем-она-нужна)
+ [3.3.7. Как области памяти влияют на производительность и GC?](#337-как-области-памяти-влияют-на-производительность-и-gc)

#### 3.3.1. Какие бывают ссылки в Java и в чем их отличия?
В Java существуют четыре типа ссылок: Strong (обычные), Soft, Weak и Phantom. <br>
- Strong Reference: Обычная ссылка (Object obj = new Object()). Предотвращает сборку мусора, пока ссылка существует. <br>
- Soft Reference: Позволяет GC собирать объект при нехватке памяти (например, для кэшей изображений). <br>
- Weak Reference: GC может собрать объект в любой момент, даже если памяти достаточно (для слабых кэшей). <br>
- Phantom Reference: Не предотвращает сборку, используется для отслеживания финализации (с ReferenceQueue). <br>
  Отличия: Strong — самая сильная (GC игнорирует), Soft — при low memory, Weak — всегда уязвима, Phantom — только для уведомлений. <br>
  Для junior: Strong — "не трогай", остальные — для оптимизации памяти. Senior: Используйте WeakHashMap для кэшей; в Java 9+ phantom references улучшены для cleanup.

#### 3.3.2. Что такое soft, weak, phantom ссылки?
Soft Reference (java.lang.ref.SoftReference): Объект собирается только при нехватке памяти (threshold на основе -XX:SoftRefLRUPolicyMS). Идеально для кэшей, где данные можно перезагрузить. <br>
Weak Reference (WeakReference): GC собирает объект при первой возможности, независимо от памяти. Полезно для избежания утечек в коллекциях (WeakHashMap). <br>
Phantom Reference (PhantomReference): Самая слабая; объект считается "мертвым" сразу после достижения finalize, но ссылка не дает доступа к объекту. Используется с ReferenceQueue для пост-GC действий (например, cleanup ресурсов). <br>
Для junior: Soft — "если тесно", Weak — "сразу", Phantom — "уведоми о смерти". Senior: Избегайте finalize (deprecated в Java 9+); используйте Cleaner API; тестируйте с -XX:+ExplicitGCInvokesConcurrent для симуляции.

#### 3.3.3. Чистит ли GC String Pool?
Да, GC чистит String Pool, но только для interned строк, которые больше не используются. <br>
String Pool (в Heap, с Java 7+ в main heap) хранит уникальные строки из String.intern(). <br>
Если на строку нет strong ссылок, она может быть собрана (как любой объект). <br>
Литералы ("hello") интернированы автоматически, но GC их не трогает, если они в коде. <br>
Для junior: Pool экономит память, GC его поддерживает. Senior: В Java 7+ pool в heap, так что G1/ZGC чистят его эффективно; мониторьте с jstat -gc; избегайте чрезмерного intern() для предотвращения OOM.

#### 3.3.4. Что такое Heap, Stack и Metaspace?
- Heap: Основная область для объектов и массивов (young/old gen). Динамическая, управляется GC. Размер: -Xms/-Xmx. <br>
- Stack: Для локальных переменных, параметров методов и фреймов вызовов. Каждый поток имеет свой stack (по умолчанию 1MB). <br>
- Metaspace: С Java 8 заменяет PermGen; хранит метаданные классов, константы, статические поля. Неограничен по умолчанию (-XX:MaxMetaspaceSize). <br>
  Для junior: Heap — "объекты живут", Stack — "временные данные метода", Metaspace — "классы". Senior: Heap делится на Eden/Survivor/Old; StackOverflow от глубокой рекурсии; Metaspace OOM от динамической загрузки классов (например, в Spring); настройте -XX:MetaspaceSize для proactive GC.

#### 3.3.5. Как происходит переполнение стека (StackOverflowError)?
StackOverflowError возникает, когда стек потока переполняется (по умолчанию 1MB на поток). <br>
Причины: Глубокая рекурсия без базового случая (например, factorial(10000)), бесконечный цикл вызовов методов или слишком большие локальные массивы в методе. <br>
JVM увеличивает стек фреймами при каждом вызове; при исчерпании — ошибка. <br>
Для junior: Рекурсия может "залить" стек. Senior: Увеличьте стек с -Xss (например, 8m), но лучше избегайте глубокой рекурсии (используйте итерацию или tail recursion в новых JVM); мониторьте с ThreadMXBean; в многопоточных apps (ForkJoinPool) стек меньше по умолчанию.

#### 3.3.6. Что такое ReferenceQueue и зачем она нужна?
ReferenceQueue — очередь для отслеживания ссылок, которые GC пометил для очистки (Soft/Weak/Phantom). <br>
Когда GC собирает объект, соответствующая ссылка добавляется в очередь (если указана при создании Reference). <br>
Зачем: Для cleanup действий после сборки (например, закрытие файлов в PhantomReference, обновление кэша в Weak). <br>
Использование: new WeakReference<>(obj, queue); затем poll() из очереди. <br>
Для junior: "Список мертвых ссылок" для уведомлений. Senior: Эффективно для resource management (лучше finalize); в Java 9+ интегрируется с Cleaner; тестируйте в unit-тестах с System.gc() для симуляции.

#### 3.3.7. Как области памяти влияют на производительность и GC?
- Heap: Большой heap замедляет GC (longer pauses), но позволяет больше объектов; tuning (G1/ZGC) минимизирует latency. <br>
- Stack: Глубокий стек (много методов) увеличивает overhead на вызовы; в reactive apps (Project Loom) виртуальные threads имеют tiny stacks. <br>
- Metaspace: Переполнение вызывает full GC; динамическая загрузка (JNI/classes) требует tuning для избежания OOM. <br>
  Общее: GC паузы зависят от поколений (young fast, old slow); false sharing в heap влияет на multi-core. <br>
  Для junior: Правильный размер — ключ к скорости. Senior: Используйте JFR/JMH для profiling; -XX:+UseZGC для low-latency; в микросервисах минимизируйте heap для быстрого старта; мониторьте с Prometheus/Grafana.


### END ---------------- 3.3. Ссылки и Области Памяти ----------------

### 3.4. Профилирование и Мониторинг

+ [3.4.1. Какие инструменты для профилирования памяти в Java?](#341-какие-инструменты-для-профилирования-памяти-в-java)
+ [3.4.2. Как выявить утечку памяти?](#342-как-выявить-утечку-памяти)
+ [3.4.3. Что такое heap dump и как его анализировать?](#343-что-такое-heap-dump-и-как-его-анализировать)
+ [3.4.4. Что такое JFR (Java Flight Recorder) и как его использовать?](#344-что-такое-jfr-java-flight-recorder-и-как-его-использовать)
+ [3.4.5. Как мониторить JVM с помощью JMX?](#345-как-мониторить-jvm-с-помощью-jmx)

#### 3.4.1. Какие инструменты для профилирования памяти в Java?
Основные инструменты: VisualVM (бесплатный, встроен в JDK до 8, теперь отдельно), JProfiler (коммерческий, детальный), YourKit (коммерческий, с плагинами для IDEA). <br>
Встроенные: jmap (для heap dumps), jstat (статистика GC), jcmd (команды JVM). <br>
Для junior: VisualVM — простой старт, показывает графики heap/CPU. Senior: JFR (в JDK 11+) для low-overhead profiling; интегрируйте с Micrometer/Prometheus в production; сравнивайте профили перед/после оптимизаций.

#### 3.4.2. Как выявить утечку памяти?
Признаки: Постоянный рост heap (jstat -gc показывает old gen растет), OOM, частые full GC. <br>
Шаги: 1) Мониторьте heap с jconsole/jvisualvm. 2) Создайте heap dump (jmap -dump). 3) Анализируйте на retained objects (MAT/Eclipse Memory Analyzer). 4) Ищите static поля, не закрытые ресурсы, listeners. <br>
Для junior: Если heap не уменьшается после GC — утечка. Senior: Используйте heap histograms (jcmd GC.heap_info); в микросервисах проверяйте с нагрузкой; автоматизируйте с JMH для регрессии; избегайте ThreadLocal без cleanup.

#### 3.4.3. Что такое heap dump и как его анализировать?
Heap dump — снимок heap в момент времени (hprof формат), показывает объекты, ссылки, размеры. <br>
Создание: jmap -dump:file=heap.hprof <pid> или jcmd <pid> GC.heap_dump heap.hprof. <br>
Анализ: Eclipse MAT (find dominators, leak suspects), VisualVM (inspect objects), jhat (устаревший, веб-интерфейс). <br>
Для junior: Dump — "фото" памяти для поиска "толстых" объектов. Senior: Фокусируйтесь на shallow/deep retained size; в production используйте -XX:+HeapDumpOnOutOfMemoryError; интегрируйте с APM (New Relic/Elastic APM); для больших dumps (GB) используйте sampling.

#### 3.4.4. Что такое JFR (Java Flight Recorder) и как его использовать?
JFR — инструмент в JDK (с 7, полноценно в 11+) для low-overhead recording событий JVM (GC, locks, I/O, allocations). <br>
Использование: Запуск с -XX:StartFlightRecording (или jcmd <pid> JFR.start); анализ в JDK Mission Control (JMC) — бесплатный GUI. <br>
Преимущества: Минимальный overhead (<1%), continuous recording. <br>
Для junior: JFR — "черный ящик" JVM для поиска bottleneck'ов. Senior: Настройте events (например, только GC); в production используйте для troubleshooting (например, high CPU); интегрируйте с OpenTelemetry; сравнивайте recordings после изменений.

#### 3.4.5. Как мониторить JVM с помощью JMX?
JMX (Java Management Extensions) — стандарт для мониторинга/управления JVM (MBeans для heap, GC, threads). <br>
Доступ: jconsole (GUI), jvisualvm, или программно (MBeanServer). <br>
Примеры: MemoryMXBean для heap usage, GarbageCollectorMXBean для GC stats. <br>
Для junior: JMX — "панель управления" JVM. Senior: В production используйте JMX с exporters (Prometheus JMX exporter) для dashboards; настройте remote JMX с аутентификацией (-Dcom.sun.management.jmxremote); автоматизируйте alerts на thresholds (например, heap >90%).

### END ---------------- 3.4. Профилирование и Мониторинг ----------------

## END ---------------- 3. Memory Management ----------------


+ [Garbage collector](#garbage-collector)
+ [JMM](#jmm)
+ [Classloader](#classloader)
+ [ООП](#ооп)
+ [Коллекции](#коллекции)
+ [База данных](#база-данных)
+ [Concurrency](#concurrency)
+ [Способы выполнения запросов к другим источникам](#способы-выполнения-запросов-к-другим-источникам)
+ [Spring изнутри](#spring-изнутри)
+ [Spring](#spring)
+ [Spring Кеш](#spring-кеш)
+ [Spring Transactional](#spring-transactional)
+ [Spring Patterns](https://github.com/JuliWolf/Spring/blob/master/Spring-patterns/README.md)
+ [Hibernate & JPA](#hibernate--jpa)
+ [Kafka](#kafka)
+ [Stream](#stream)
+ [SOLID](#solid)
+ [ENUM](#enum)
+ [Maven](#maven)
+ [Servlet](#servlet)
+ [Swagger](#swagger)
+ [Nginx](#Nginx)
+ [Java 8](#java-8)
+ [Аутентификация и авторизация](#аутентификация-и-авторизация)
+ [JIT компилятор](#jit-компилятор)
+ [JsonB](https://github.com/JuliWolf/Java_Base/blob/main/JsonB/README.md)
+ [Mockito & Junit](https://github.com/JuliWolf/Spring/blob/master/mockito/README.md)
+ [DDD](ddd.md)

## Коллекции

+ [1. Что такое коллекция?](#1-что-такое-коллекция)
+ [2. Расскажите про иерархию коллекций?](#2-расскажите-про-иерархию-коллекций)
+ [3. Почему Map - это не Collection, в то время как List и Set являются Collection?](#3-почему-map---это-не-collection-в-то-время-как-list-и-set-являются-collection)
+ [4. В чем разница между классами java.util.Collection и java.util.Collections?](#4-в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
+ [5. Что такое «fail-fast поведение»?](#5-что-такое-fail-fast-поведение)
+ [6. Какая разница между fail-fast и fail-safe?](#6-какая-разница-между-fail-fast-и-fail-safe)
+ [7. Чем различается Enumeration и Iterator?](#7-чем-различается-enumeration-и-iterator)
+ [8. Как между собой связаны Iterable, Iterator и «for-each»?](#8-как-между-собой-связаны-iterable-iterator-и-for-each)
+ [9. Сравните Iterator и ListIterator.](#9-сравните-iterator-и-listiterator)
+ [10. Как поведёт себя коллекция, если вызвать iterator.remove()?](#10-как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
+ [11. Чем Set отличается от List?](#11-чем-set-отличается-от-list)
+ [12. Расскажите про интерфейс Set](#12-расскажите-про-интерфейс-set)
+ [13. Что будет если добавлять элементы в TreeSet по возрастанию?](#13-что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
+ [14. Как устроен HashSet, сложность основных операций (16)](#14-как-устроен-hashset-сложность-основных-операций-16)
+ [15. Как устроен LinkedHashSet сложность основных операций](#15-как-устроен-linkedhashset-сложность-основных-операций)
+ [16. Как устроен TreeSet сложность основных операций](#16-как-устроен-treeset-сложность-основных-операций)
+ [17. Расскажите про интерфейс List](#17-расскажите-про-интерфейс-list)
+ [18. Как устроен ArrayList сложность основных операций](#18-как-устроен-arraylist-сложность-основных-операций)
+ [19. Как устроен LinkedList сложность основных операций](#19-как-устроен-linkedlist-сложность-основных-операций)
+ [20. Почему LinkedList реализует и List и Deque](#20-почему-linkedlist-реализует-и-list-и-deque)
+ [21. Как перестроить Связанный список в HashTable](#21-как-перестроить-связанный-список-в-hashtable)
+ [21. Как перестроить Связанный список в HashTable](#21-как-перестроить-связанный-список-в-hashtable)
+ [22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?](#22-существуют-ли-какие-нибудь-требованию-к-объектам-используемым-в-качестве-ключа-в-hashmap)
+ [23. Как работает HashMap?](#23-как-работает-hashmap)
+ [24. Как строиться красное-черное дерево?](#24-как-строиться-красное-черное-дерево)
+ [25. На чем основана HashSet?](#25-на-чем-основана-hashset)
+ [26. Какая структура подходит для хранения большого количества данных](#26-какая-структура-подходит-для-хранения-большого-количества-данных)
+ [27. Что может быть ключем в HashMap?](#27-что-может-быть-ключем-в-hashmap)
+ [28. Параметры ArrayList](#28-параметры-arraylist)
+ [29. Stack](#29-stack)
+ [30. Comparator vs Comparable](#30-comparator-vs-comparable)

### 1. Что такое коллекция?
Коллекции - это наборы однородных элементов

### 2. Расскажите про иерархию коллекций?

   Первая иерархия</br>
   Collection делится на подколлекции:</br>
    - Set - описывает такую структуру как множество, содержащее неупорядоченные уникальные элементы. Есть стандартные реализации - TreeSet, HashSet,LinkedHashSet</br>
    - List - структура данных, которая хранит упорядоченную последовательность объектов. Реализации - ArrayList, Vector, LinkedList</br>
    - Queue - Хранит элементы в виде очереди, которая следует правилу First In First Out. Реализации - LinkedList, PriorityQueue</br></br>

   Вторая иерархия</br>
   Map делится на подколлекции:</br>
    - HashTable, LinkedHashMap, TreeMap

### 3. Почему Map - это не Collection, в то время как List и Set являются Collection?
Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».

### 4. В чем разница между классами java.util.Collection и java.util.Collections?
java.util.Collections - набор статических методов для работы с коллекциями.</br></br>

java.util.Collection - один из основных интерфейсов Java Collections Framework.

### 5. Что такое «fail-fast поведение»?
fail-fast означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом
</br></br>
Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.</br></br>

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):</br>
- при изменении коллекции счетчик модификаций так же изменяется;
- при создании итератора ему передается текущее значение счетчика;
- при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.

### 6. Какая разница между fail-fast и fail-safe?
В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.
</br></br>
Fail-fast коллекции
Когда коллекция модифицируется во время итерации, fail-fast коллекции мгновенно выбрасывают ConcurrentModificationException для предотвращения возможной инконсистентности данных.
ArrayList, HashMap, HashSet
```java
List<String> list = new ArrayList<>();
Iterator<String> iterator = list.iterator();
list.add("element"); // Приведет к ConcurrentModificationException
```
</br></br>
Fail-safe коллекции работают с копией данных во время итерации для предотвращения инконсистентности
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
  map.put("key", 1);
  for (String key : map.keySet()) {
  map.put(key + "new", 2);
  }
```

### 7. Чем различается Enumeration и Iterator?
- с помощью Enumeration нельзя добавлять/удалять элементы;
- в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
- Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.

### 8. Как между собой связаны Iterable, Iterator и «for-each»?
Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.

Iterable
1. Интерфейс Iterable является базовым интерфейсом для любого класса, которые может быть перебираемым
2. Предоставляет метод iterator(), который возвращает объект типа iterator
3. Может быть использован в цикле for-each

Iterator
1. Интерфейс Iterator представляет собой объект, который позволяет последовательно перебирать элементы коллекции
2. Имеет 3 основных метода: hasNext() (проверяет наличие следующего элемента), next() (получает следующий элемент) и remove() (удаляет текущий элемент).

Iterable - используется для указания, что класс может быть пересобираемым
Iterator - используется для перебора элементов в коллеции

### 9. Сравните Iterator и ListIterator.
- ListIterator расширяет интерфейс Iterator
- ListIterator может быть использован только для перебора элементов коллекции List;
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next().</br>
  Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
- ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove().
  Iterator не поддерживает данного функционала.

### 10. Как поведёт себя коллекция, если вызвать iterator.remove()?
Если вызову iterator.remove() предшествовал вызов iterator.next(),</br>
то iterator.remove() удалит элемент коллекции, на который указывает итератор,</br>
в противном случае будет выброшено IllegalStateException().

### 11. Чем Set отличается от List?
List допускает дубликаты</br>
Set имеет только уникальные значения

### 12. Расскажите про интерфейс Set
Интерфейс Set расширяет интерфейс Collection</br>
Представляет набор уникальных элементов</br></br>

Реализации:
- SortedSet - NavigableSet
- AbstractSet - HashSet - LinkedHashSet
- TreeSet

### 13. Что будет если добавлять элементы в TreeSet по возрастанию?
Так как в основе TreeSet будет красное черное дерево, поэтому все элементы буду сбалансированы

### 14. Как устроен HashSet, сложность основных операций (16)
- Реализует интерфейс Set
- Базовой структурой для HashSet является HashTable
- Повторяющиеся элементы не допускаются
- порядок элементов не сохранится, так как для сохранения элементов происходит на основании хеш-кода

### 15. Как устроен LinkedHashSet сложность основных операций
- Реализует интерфейс Set
- Базовой структурой для LinkedHashSet является LinkedList
- Порядок элементов будет сохранен
- Повторяющиеся элементы не допускаются

### 16. Как устроен TreeSet сложность основных операций
- Реализует интерфейс Set
- Базовой структурой для TreeSet является TreeMap
- Используется природный порядок элементов, основанный на Comparator

### 17. Расскажите про интерфейс List</br>
Интерфейс List расширяет интерфейс Collection</br>
Представляет собой список

### 18. Как устроен ArrayList сложность основных операций
- Это список реализованный на основе массива
- Доступ к элементу по индексу за константное время
- Доступ к элементам по значению за линейное время
- Вставка в конеч за константное время
- Удаление из списка варьируется
- Вставка элемента варьируется
- необходимо одно единое пространство для хранения

### 19. Как устроен LinkedList сложность основных операций
- Это двусвязный список, основанный на объектах с ссылками между ними
- на получение элемента по индексу необходимо линейное время
- На добавление и удаление потребуется константное время
- На поиск позиции и вставки или удаления за константное время

### 20. Почему LinkedList реализует и List и Deque
- LinkedList позволяет добавлять элементы в начало и в конец списка, что хорошо согласуется с Deque

### 21. Как перестроить Связанный список в HashTable
Переопределить hashCode и использовать  "адрес в память"

### 22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?
у них должен быть реализован метод для создания ключа и значения должны быть финализированы</br>
equals и hashCode

### 23. Как работает HashMap?
- HashMap представляет собой динамический массив, так как он умеет расширяться
- Пока в HashMap нет ни одного элемента массив не иницализируется
- После инициализации массива, каждый элемент массива будет представлять из себя корзину `bucket`, представленный в виде LinkedList
- Каждый элемент LinkedList представлдяет собой Node, с полями (hash, key, value, next) (односвязанный список)
- При добавлении элемента
  - Вычисляется хэш ключа, который использует hashCode (сделано для оптимизации распределения элементов)
  ```
  // default
  static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```
  - Вычисляется индекс бакета
  ```
  // n - длина массива
  i = (n - 1) & hash
  ```
  - Создается объект Node
  - Получаем список по индексу
    - Если в списке пусто, то размещаем элемент</br>
    - Если в списке есть элементы, то хэш и ключ первого элемента поочередно сравнивается с хэшами элементов из списка
    `(p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))`
    - Если в результате всех проверок всегда был возвращен false, то элемент добавляется в конец листа
    - Если было найдено совпадение, то заменяем текущие значения на новые
  - Увеличиваем количество элементов
  - Проверяем loadFactor - если проверка loadFactor возвращает true, то массив увеличивается в 2 раза
- При удалении элемента
  - Если количество элементов в бакете становится меньше или равно 6, то красное-черное дерево превращается в связанный список
  
### 24. Как строиться красное-черное дерево?
- Элементы сортируется по хеш-коду
- Делятся на 2 ветки, начиная с первого элемента списка
- Остальные элементы распределяются направо и налево в зависимости от значения хешей
- Все левые меньше своего корневого, все правые больше
- Если хеш код элементов совпадает, то вызывается нативный `System.identityHashCode()` для вычисления хеша

### 25. На чем основана HashSet?
HashSet работает так же как и HashMap только для значения она использует объект-заглушку

### 26. Какая структура подходит для хранения большого количества данных
ArrayList

### 27. Что может быть ключем в HashMap?
- любой объект, который реализует интерфейс `java.lang.Object`

- Ключи HashMap должны быть неизменяемым, чтобы гарантировать их уникальность и согласовааное поведение
- Поэтому ArrayList, которая может измениться, может вернуть другой ключ

### 28. Параметры ArrayList
1. Начальный размер 10
2. loadFactor - 1
3. growth rate - current_size + current_size/2 
4. add - для добавления в конец 
5. set - замена сущетсвующего значения по индексу

### 29. Stack
```java
// Добавление
Stack<Card> deck = new Stack<>();
deck.push(new Card("Рагнарос"));
deck.push(new Card("Пират Глазастик"));
deck.push(new Card("Сильвана Ветрокрылая"));
deck.push(new Card("Миллхаус Манашторм"));
deck.push(new Card("Эдвин ван Клифф"));

// Посмотреть последний элемент
System.out.println(deck.peek());

// удаление
System.out.println(deck.pop());
```

### 30. Comparator vs Comparable

Comparable - используется для сортировки классов на основе их естественного порядка 
Должен быть реализован в классе, который будет использоваться для сортировки
Используется пользовательская реализация метода `int CompareTo(T var1)`

Comparator - Это интерфейс, который также используется для сортировки коллекций
Интерфейс не обязательно должен быть реализован в исходном классе

## END ---------------- Коллекции ----------------

## Classloader

+ [1. Задачи classloader](#1-задачи-classloader)
+ [2. Этапы получения работающего JVM кода](#2-этапы-получения-работающего-jvm-кода)
+ [3. Условия для выполнения этапов](#3-условия-для-выполнения-этапов)
+ [4. Типы загрузчиков](#4-типы-загрузчиков)
+ [5. От какого класса наследуются все загрузчики?](#5-от-какого-класса-наследуются-все-загрузчики)
+ [6. От какого класса наследуются базоый загрузчик?](#6-от-какого-класса-наследуются-базоый-загрузчик)
+ [7. Какие методы надо реализовывать при реализации Classloader](#7-какие-методы-надо-реализовывать-при-реализации-classloader)
+ [8. Какой метод является точной входа для загрузки классов](#8-какой-метод-является-точной-входа-для-загрузки-классов)
+ [9. Логика работы `classLoader`](#9-логика-работы-classloader)
+ [10. Принципы загрузки классов](#10-принципы-загрузки-классов)
+ [11. Схема загрузки классов](#11-схема-загрузки-классов)
+ [12. Все ли классы загружаются сразу](#12-все-ли-классы-загружаются-сразу)

### 1. Задачи classloader
- Для поставки в JVM скомпилированного байт-кода, который хранится в файлах с расширением `.class`, но модет быть также получен из других источников

### 2. Этапы получения работающего JVM кода
- Загрузить байт-код из ресурсов и создание экземпляра класса `Class`
    - Поиск запрошенного класса среди загруженных ранее
    - Получение байт-кода для загрузки и проверки его корректности
    - Создание экземпляра класса `Class`
    - Загрузка родительских классов
- Связываение (линковка)
    - `Verification` - проверка корректности полученного байт-кода
    - `Preparation` - выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию
    - `Resolution` - разрешение символьных ссылок типов, полей и методов
- Инициализация полученного объекта

### 3. Условия для выполнения этапов
- Класс должен быть полностью загружен прежде, чем слинкован
- Класс должен быть полностью проверен и подготовлен прежде, чем проиницилизирован
- Ошибки разрешения ссылок происходят во время выполнения программ, даже если быть обнаружены на этапе линковки

### 4. Типы загрузчиков
- **Bootstrap** - базовый загрузчик, также называется `Primodial Classloader`
    - загружает стандартные классы JDK из архива rt.jar
- **Extension ClassLoader** - загрузчик расширенный
    - Загружает классы расширений, которые по умолчанию находятся в каталоге `jre/lib/ext`, но могут быть заданы системным свойством `java.ext.dirs`
- **System Classloader** - системный загрузчик
    - загружает классы приложения, опрределенные в переменной среды окружения CLASSPATH

(*) Используется иерархия загрузчиков классов
- Корневой - базовый
- Загрузчик расширений
- Системный загрузчик

### 5. От какого класса наследуются все загрузчики?
абстрактный классс `Classloader`

### 6. От какого класса наследуются базоый загрузчик?
базовый загрузчик является нативным и его реализация включена в JVM

### 7. Какие методы надо реализовывать при реализации Classloader
- loadClass(String name)
- loadClass(String name, boolean resolve)
- findLoadedClass(String name)
- getParent()
- findClass(String name)
- resolveClass(Class<?> c)

### 8. Какой метод является точной входа для загрузки классов
- Метод `loadClass(String name)`

### 9. Логика работы `classLoader`
- Вызывается метод `loadClass(String name)`
- Его реализация сводится к вызову protected метода `loadClass(String name, boolean resolve)`
    - На вход этого метода подаются два параметра
    - 1 бинарное имя класса, который необходимо загрузить
    - 2 флаг, определяющий, требуется ли выполнять процедуру разрешения символьных ссылок (по умолчанию false)
- Далее происходит вызов метода `findLoadedClass(String name)`
    - Проверяет был ли класс уже загружен ранее
        - Если был, то вернет ссылку на класс
        - Иначе вызывает метод загрузки класса у родительского загрузчика
        - Если ни один из загрузчиков не смог найти загруженный класс, каждый из них следуя в обратном порядке попытается этот класс найти и загрузить, переопределяя метод `findClass(String name)`
- Послед загрузки определяется стоит ли выполнять загрузку классов по символьным ссылкам

### 10. Принципы загрузки классов
- **Дегерирование**
    - Запрос на загрузку класс передается родительскому загрузчику
    - Попытка загрузить класс самостоятельно выполняется, только если родительский загрузчик не смог найти и загрузить класс
    - Позволяет загружать классы тем загрузчиком, который максимально близко к базовому
- **Видимость**
    - Загрузчик видит только свои классы и классы родителя и понятия не имеет о классах, которые были загружены его потомком
- **Уникальность**
    - Класс может быть загружен только однажды

### 11. Схема загрузки классов
1. Приходит вызов загрузки класса
2. Происходит поиск этого класса в кеше уже загруженных классов текущего загрузчика
3. Если класс не загружался ранее
    1. Управление передается родительскому загрузчику (делегирование)
        1. Если класс уже был загружен и загрузчик знает о его местонахождении, то будет возвращен объект `Class` этого класса
        2. Если нет, поиск будет продолжаться до тех пор, пока не дойдет до базового загрузчика
            1. Если в базовом загрузчике нет информации об искомо классе, будет выполнен поиск байт-кода
                - Если класс загрузить н удается, то управление возвращается обратно к загрузчику-потомку
                - Потомок будет выполнять загрузку из известным ему источников и передавать ниже по цепочке

```
| Генерируется исключение java.lang.ClassNotFoundException | <---------------------------------------  < нет | класс загружен? | да >--
                                                                                                                         ^
                                                                                                                         |
                                                                                                                загрузка |
| Программа запросила класс {name} | --------------------------------> |*********************** System Classloader ***********************|
                                   |                                             | поиск в кеше                          ^
                                   |                                             |                                       | нет
                                   |                                             v                                       | нет
                                   | <--------------------------------<да | Класс найден? |                       | Класс загружен? | да >--
                                   |                                         нет |                                       ^
                                   |                                             |                                       |
                                   |                                             v                              загрузка |
                                   |                                   |********************* Extension ClassLoader **********************|
                                   |                                             | поиск в кеше                          |
                                   |                                             |                                       | нет
                                   |                                             v                                       | нет
                                   | <--------------------------------<да | Класс найден? |                       | Класс загружен? | да >--
                                   |                                         нет |                                       ^
                                   |                                             |                                       |
                                   |                                             v                              загрузка |
                                   |                                   |************************* Bootstrap ******************************|
                                   |                                             | поиск в кеше                          ^
                                   |                                             |                                       |
                                   |                                             v                                       |
                                   | <--------------------------------<да | Класс найден? | нет>-----------------> | Попытка загрузить класс |
```

### 12. Все ли классы загружаются сразу
Нет, классы загружаются по мере необходимости во время выполнения программы

3 этапа загрузки класса
1. Загрузка: Класс загружается когда он впервые используется в программе. В этот момент классовый загрузчик загружает файл класса их файловой системы или с другого источника
2. Связываение: На этом этапе происходит проверка целостности и семантическая проыерка загруженного класса, а также разрешение ссылок на другие классы и ресурсы
3. Инициализация: Происходит инициализация статических полей и выполнение статических блоков иницилизации в классе

## END ---------------- Classloader ----------------

## ООП

+ [1. Что такое ООП?](#1-что-такое-ооп)
+ [2. Что такое объект?](#2-что-такое-объект)
+ [3. Что такое класс?](#3-что-такое-класс)
+ [4. Какие преимущства у ООП?](#4-какие-преимущства-у-ооп)
+ [5. Какие недостатки у ООП?](#5-какие-недостатки-у-ооп)
+ [6. Основные принципы ООП](#6-основные-принципы-ооп)
+ [7. Что такое ассоциация?](#7-что-такое-ассоциация)
+ [8. Что такое агрегация?](#8-что-такое-агрегация)
+ [9. Что такое композиция?](#9-что-такое-композиция)
+ [10. Раннее и позднее связывание](#10-раннее-и-позднее-связывание)
+ [11. Можно ли переопределить private или static методы?](#11-можно-ли-переопределить-private-или-static-методы)
+ [12. Можно ли менять модификатор доступа у унаследованных методов,свойств](#12-можно-ли-менять-модификатор-доступа-у-унаследованных-методовсвойств)
+ [13. Можно ли получить доступ к нестатическому полю из статического метода?](#13-можно-ли-получить-доступ-к-нестатическому-полю-из-статического-метода)
+ [14. Что такое diamond problem и как она решена в Java](#14-что-такое-diamond-problem-и-как-она-решена-в-java-)

### 1. Что такое ООП?
- ООП - это объектно ориентированное программирование.
- Это программирование с помощью классов и объектов

### 2. Что такое объект?
- Объект  - это сущность, одновременно содержащая данные и поведения.
- Объекты - это строительные блоки объектно-ориентированных программ.

```
Данные объектов - состояние объекта(атрибуты).
Пример: атрибуты работника (SocialSecurityNumber, Gender, DateOfBirth)

Поведения объектов - что объект может сделать( в процедурных языках определяется процедурами, функциями и подпрограммами) (методы).
Пример: методы работника (setGender() getGender() - для установки и получения пола).
```

### 3. Что такое класс?
Класс - это "чертеж" объекта

### 4. Какие преимущства у ООП?
- Модульность - инкапсуляция объектов в себе упрощает разработку, уменьшает количество ошибок
- Реюзабельность кода
- Высокая скорость разработки - классы и интерфейсы в ООП могут легко трансформироваться в подобие полноценных библиотек
- Расширяемость - ООП легко развивать, дополнять и менять. Этому способствует независимая модульная структура
- Простота восприятия
- Безопасность - инкапсулированных код недоступен извне, поэтому поломать что-либо сложнее
- Гибкость - полиморфизм позволяет быстро адаптировать ООП-код под свои нужды

### 5. Какие недостатки у ООП?
- Объекты во главе угла - из-за особенного внимания к объектам, меньше внимания уделяется вычислениям и алгоритмам
- Негативно сказывается на скорости компиляции кода

### 6. Основные принципы ООП
- Инкапсуляция - свойство системы, позволяющее объеденить данные и методы, работающие с ним, в классе. В частности, некоторые языки подразумевают сокрытие этих компонентов от доступа из вне.
- Наследование - Свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью
- Полиморфизм поддтипов - свойство системы, позволяющее использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта
- Полиморфизм параметрический - свойство семантики системы типов, позволяющее обрабатывать значения разных типов идентичным образом, то есть исполнять физически один и тот же код для данных разных типов
- Полиморфизм ad hoc - это свойство языка программирования, позволяющее создать функцию, семантика которой будет зависеть от типов входных параметров
- Абстракция - каждый верхний слой над объектом (классы) более абстрактный

### 7. Что такое ассоциация?
https://i.stack.imgur.com/BBNy5.png

Объекты между собой никак не связаны. Первый объект может принадлежать сразу нескольким объектам одновременно и не управляться ими</br>
Наследование позволяет одному классу наследовать от другого, поэтому мы можем абстрагировать атрибуты и поведения для общих классов

### 8. Что такое агрегация?
Это вложенность одного класса в другой, но при этом класс обертка не управляет сроком жизни вложенного объекта</br>
части могут принадлежать более чем одному целому за раз, и целое не управляет существованием и временем жизни частей

- Например, отношения между человеком и его домашним адресом. У каждого человека есть свой адрес. Однако этот адрес может принадлежать более чем одному человеку за раз</br>
  Однако этот адрес не управляется человеком — адрес существовал до того, как человек заселился и будет существовать после того, как человек выселится.

### 9. Что такое композиция?
это отношения части-целого. Часть в композиции может быть частью только одного объекта за раз</br></br>

- Например: сердце, которое является частью тела одного человека, не может быть частью тела ещё одного человека одновременно.

### 10. Раннее и позднее связывание
- Раннее - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода
- Позднее - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.

### 11. Можно ли переопределить private или static методы?
нельзя

### 12. Можно ли менять модификатор доступа у унаследованных методов,свойств
- Понижать уровень доступа нельзя
- Повышать уровень доступа можно

### 13. Можно ли получить доступ к нестатическому полю из статического метода?
нет

### 14. Что такое diamond problem и как она решена в Java
Diamond problem это Когда классы B и C наследуют А, а класс D наследуюет B и C</br>
При этом классы A, B, C определяют метод test что приводит к непонимаю какую именно имплементацию метода test должен унаследовать класс D

В java запрещено множественное наследование

## END ---------------- ООП ----------------

## База данных

+ [1. Что такое схема, таблица](#1-что-такое-схема-таблица)
+ [2. В чем разница между Statement и PreparedStatement?](#2-в-чем-разница-между-statement-и-preparedstatement)
+ [3. План исполнения запроса](#3-план-исполнения-запроса)
+ [4. Как работает индекс в таблице](#4-как-работает-индекс-в-таблице)
+ [5. Блокировка таблицы](#5-блокировка-таблицы)
+ [6. Оптимистическая/пессимистическая блокировки](#6-оптимистическаяпессимистическая-блокировки)
+ [7. Транзакции](#7-транзакции)
+ [8. Пул соединений к БД](#8-пул-соединений-к-бд)
+ [9. Функция vs Процедура](#9-функция-vs-процедура)
+ [10. Что означает ASID](#10-что-означает-asid)
+ [11. Какие ошибки отменяют транзакцию?](#11-какие-ошибки-отменяют-транзакцию)
+ [12. Как удалить все записи из таблицы](#12-как-удалить-все-записи-из-таблицы)
+ [13. Как работает while loop](#13-как-работает-while-loop)
+ [14. Что такое postgres view](#14-что-такое-postgres-view)
+ [15. Какие бывают типы ключей](#15-какие-бывают-типы-ключей)
+ [16. Тип ключа `check`](#16-тип-ключа-check)
+ [17. Тип ключа `not-null`](#17-тип-ключа-not-null)
+ [18. Тип ключа `unique`](#18-тип-ключа-unique)
+ [19. Тип ключа `primary keys`](#19-тип-ключа-primary-keys)
+ [20. Тип ключа `foreign keys`](#20-тип-ключа-foreign-keys)
+ [21. Типы поведений при использовании foreig keys](#21-типы-поведений-при-использовании-foreig-keys)
+ [22. Тип ключа `exclusion constrains`](#22-тип-ключа-exclusion-constrains)
+ [23. Как происходит блокировка во время транзации в Postgresql](#23-как-происходит-блокировка-во-время-транзации-в-postgresql)
+ [24. Виды блокировок](#24-виды-блокировок)

### 1. Что такое схема, таблица
- Схема - это формальное описание структуры и взаимосвязи таблиц и других объектов в бд
  - определение таблиц
  - определение столбцов
  - определение типов данных
  - определение ограничений
  - определение отношений
  - определение индексов
- Таблицы - основной элемент базы данных. Состоит из:
  - столбцов
  - строк

### 2. В чем разница между Statement и PreparedStatement?
Statement - не защищен</br>
PreparedStatement - переданные параметры защищены от sql инъекций

### 3. План исполнения запроса
Пример Postgresql</br></br>

   Explain [(OPTION [,...])]</br>
- Analyze [boolean] - запрос выполнится и составит план выполнения
- Verbose [boolean] - добавит дополнительную информацию
- Costs [boolean] - добавит стоимость каждого запроса
- Buffer [boolean] - определяет число блоков с диска и из кеша
- Timing [boolean] - Время запуска и время выполнения на каждом узле
- Summary [boolean]
- Format [TEXT|XML|JSON|YAML] - для подготовки отчета

### 4. Как работает индекс в таблице
1. Таблица без индексов выглядит как куча (Heap). При запросе будет сканироваться вся таблица
2. Преимущества индексов
   - Повышают скорость поиска информации и производительность запросов
3. Недостатки
   - Требуют много места на диске и в оперативной памяти
   - Замедляют производительность системы (медленнее выполняются операции вставок, обновлений, удалений)
4. Структура
   - Состоят из:
   - наборов страниц
   - узлов, имеющих древовидную структуру, иерархическую
   - Хранятся в виде сбалансированных B-деревьев
   - При создании индекса создаются указатели на строки таблицы, которые удовлетворяют условию
5. Виды индексов
   - Составной (несколько колонок)
   - Функциональные или индекс по выражению
   - Обычный, по одной колонке
6. Типы индексов
   - B-tree (дефолтное)
   - Hash - хранятся в 32-битной хеш код, полученный из значения индексируемого столбца
     Обрабатывает только операции равенства (медленнее чем B-tree в Posgtresql)
   - Gist - это инфраструктура, в которой можно реализовать множество стратегий индексирования</br>
   Подходит для вычисления гео данных, расстояние, пересечение площадей</br>
   Есть триграм, позволяет искать по вхождению и индексировать (regexp)
   - Sp-gist - это инфраструктура, которая поддерживает различные виды поиска.
     Позволяет реализовать несбалансированные дисковые структуры данных
   - Gin - инвертированные индексы, которые подходят для данных, содержащих компонентные значения, например массивы
   - Brin - хранят сводки о значениях, хранящихся в последовательных диапазонах физических блоков таблицы

### 5. Блокировка таблицы
Виды блокировок
- Разделяемые (shared locks) - блокировка на чтение
- Монолитные (exclusive locks) - блокировка на чтение и запись</br>

   --- Табличная блокировка (exclusive lock)

   `Lock Tables`

| +         | -      | 
|---------------------|-----------------------------|
| требуют небольшого объема памяти  | Отстуствует параллелизм   |
| быстрая работа при блокировке большого количества таблиц     | Все остальные операции ждут |
| быстрая работа при операциях Group by или при полном сканировании |   |
 | Подходит когда данные меняются редко                      |     |


   --- Пользовательская блокировка - конкретной строки
   ```SELECT GET_LOCK(‘key’, 10); - key & timeout```

| +         | -                                                                            | 
|------------------------------------------------------------------------------|-----------------------------|
| одна блокировка для всех приложений  | Небезопасно использовать с репликацией на основе SQL-выражений               |
| Блокировка на уровне приложения | Из-за возможности вызвать сколько угодно lock опасность множества блокировок |
| Подобие транзакции |                                                                              |
| Меньше издержки чем у транзакции |                                                                              |


   ---Глобальная блокировка

   При применении
    - конфликтует с другими блокировками
    - Вызывает снятие всех предыдущих блокировок

| +         | -      | 
|---------------------|-----------------------------|
| Для получения резервной копии  | Нужно быть аккуратным и знать что делать  |
| Эту команду использует для быстрого alter таблиц | Может быть довольно длительной, так как будет дожидаться выполнения всех Select запросов |
| не так затратна как полная остановка сервера, так как большая часть информации кешируется |   |
| Используется для восстановления |     |

   ---Построчные блокировка

| +         | -      | 
|---------------------|-----------------------------|
| Лучшее управление конкуретным доступом  | Максимальные издержки |
| Позволяет одновременно выполнять несколько изменений одного ресурса | Приводит к взаимоблокировки |
| Позволяет заблокировать одну строку на долгое время | Работают медленнее табличных блокировок если используется большая часть таблицы|
| Меньше конфликтов блокировок |  Работают намного медленней при полном сканировании таблицы или для группировок Group by |

### 6. Оптимистическая/пессимистическая блокировки
- **Оптимистическая блокировка** - множество транзакция могут завершиться без влияния друг на друга
    - могут выполняться без блокировок тех ресурсов, на которые влияют
    - Перед коммитом, каждая транзакция проверяет, что ни одна другая транзакция не модифицировала ее данные
    - Если проверка выявила конфликтующие модицикации, транзакция откатывается
- **Пессимистичная блокировка** - параллельные транзакции будут конфликтовать каждая друг с другом и требует блокировки после их чтения и снятия после завершения использования данных

+ [13. Как реализовать блокировки в Hibernate](#13-как-реализовать-оптимистическую-блокировку)

### 7. Транзакции
- Каждая транзация начинается с инструкции
  Begin Transaction и заканчивается
  Commit или Rollback

- Транзакция - это совокупность операций над базов, которые могут быть либо выполнены все вместе либо не будет выполенна ни одна из них

- Транзакции основаны на многоверсионной модели (Multiversion Concurrency Control)
    - каждый Sql оператор видит так называемый снимок данных (snapshot)
    - Снимок - это не физическая копия всей базы, это несколько чисел, которые идентифицируют текущую транзакцию и те транзакции,
      которые уже выполнились в момент начала текущей

**Свойства транзакий**
- Атомарность - транзакция либо выполняется полностью, либо не выполняется совсем
- Согласованность - после успешного выполнения транзакции база данных должны быть приведена из олного состояние в другое
- Изолированность - Во время выполнения транзации другие транзакции должны оказывать минимальное влияние на нее
- Долговечность - После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных

**Риски**
   
  - _Потерянное обновление (lost update)_ - Когда разные транзакции одновременно изменяют ожни и те же данные, то после фиксации изменений может оказаться,
  что одна транзакция перезаписала другую
  - Грязное чтение (dirty read) - Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась.
  Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе
  - _Неповторяющиеся чтение (non-repeatable read)_ - При повторном чтении тех же данных в рамках одной транзакции оказывается, что другая транзакция успела изменить
  и зафиксировать эти данные
  - _Фантомное чтение (phantom read)_ - Транзакция выполняет сборку данных и параллельно другая транзакция добавляет строки
  - _Аномалия сериализации (serialization anomaly)_ - Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одной
  из возможных вариантов упорядочения этих транзакций

**Уровни изоляции**

- Read uncommitted (dirty read)
- Read committed - только зафиксированные изменения - есть в Posgresql (по умолчанию)
- Repeatable read (phantom read) - видим вставленные записи - есть в Posgresql
- Serializable - самый безопасный - есть в Posgresql

| isolation level  | dirty read | nonrepeatable read | phantom read | serialization anomaly |
|------------------|------------|--------------------|--------------|-----------------------|
| read uncommitted | + (not PG) | +                  | +            | +                     |
| read committed   | -          | +                  | +            | +                     |
| repeatable read  | -          | -                  | + (not PG)   | +                     |
| serializable     | -          | -                  | -            | -                     |

### 8. Пул соединений к БД
   Это шаблон доступа к данным, основной целью которого является снижение накладных расходов, связанных с выполнение подключений к бд</br></br>

   Этапы соединения с БД</br>
    - Открытие соединения с БД с помощью драйверов
    - Открытие TCP  сокетов для чтения/записи
    - Чтение/запись данных через сокет
    - Закрытие соединения
    - Закрытие порта</br></br>

   Так как открытие соединения с БД это трудозатратная операция, мы можем настроить ряд соединений при старте приложения,</br>
   которыми мы будем пользоваться в процессе

### 9. Функция vs Процедура

**Функции**
- Имеет возвращаемый тип и возвращаемое значение
- Использование DML(insert, update,delete) запросов внутри функции невозможно.
  Разрешены только SELECT запросы
- Не имеет выходных аргументов
- Вызов хранимой процедуры из функции невозможен
- Вызов функции внутри SELECT запросов возможен

```
   //создает или заменяют функцию с именем
   CREATE [or REPLACE] FUNCTION function_name
   (param_list)
   // возвращаемый тип
   RETURN return_type
   LANGUAGE plpgsql
   as
   $$
   // объявление переменных
   DECLARE
   -- variable declaration
   // начало запроса
   BEGIN
   -- logic
   // окончание запроса
   END;
   $$
```
**Процедура**
- Не имеет возвращаемого типа, но имеет выходные аргументы 
- Использование DML запросов возможно 
- Имеет входные и выходные аргументы 
- Использование или управление транзакциями возможно в хранимой процедуре 
- Вызов процедуры из SELECT запросов невозможен
```
   CREATE [or REPLACE] PROCEDURE procedure_name
   (param_list)
   LANGUAGE language_name
   AS
   $$
   -- stored-procedure-body
   $$
```

### 10. Что означает ASID
- Atomicity - Атомарность
- Consistency - Согласованность
- Isolation - Изолированность
- Durability - Надежность</br>

1. _Атомарность_ гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем</br>
Не допускаются промежуточные состояния
- При попытке перевода денег с одного на друго операция или будет выполнена и синхронизирована или отменена
2. _Согласованность_ - транзакция, достигающая своего завершения(EOT - end of transaction) и, тем самым, фиксирующая свои результаты, согхраняет согласованность базы данных</br>
Упорядоченное множество операций, переводщих базу данных из одного согласованного состояние в другое
- Все обязательные поля пользователя обязательно должны быть заполнены
- Если мы записываем и пользователя и его контактные данные, то и пользователь и контактные данные будут заполнены
3. Изолированность - во время выполнения транзакции параллельные транзакции не должны оказывать влияния на ее результат
- 
4. Надежность - Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя

### 11. Какие ошибки отменяют транзакцию?
Error

### 12. Как удалить все записи из таблицы
- Удалить данные из одной таблицы
```
TRUNCATE table_name;
DELETE FROM table_name;
```
- Удалить данные из нескольких таблицы
```
TRUNCATE table_a, table_b, …, table_z;
```

### 13. Как работает while loop
```
DO $$
DECLARE 
_id int :=0;
BEGIN
	WHILE _id < 6 LOOP
	INSERT INTO dummy_insert(id)VALUES(_ID);
	_id := _id+1;
	END LOOP;
END $$;

SELECT * FROM dummy_insert;
```

### 14. Что такое postgres view
view - э виртуальная таблица. Хранит результат выполнения SELECT запроса</br>
С помощью вьюхи можно сохранить SELECT запрос и получить быстрый доступ к часто используемым данным
```
CREATE VIEW influencers AS
  SELECT name, email, created_at
  FROM users
  WHERE follower_count > 1000;
  
DROP view [ IF EXISTS ] view_name;
```

### 15. Какие бывают типы ключей
- check constrains
- not-null constrains
- unique constrains
- primary keys
- foreign keys
- exclusion constrains

### 16. Тип ключа `check`
- Позволяет определить булево выражение
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);
```
- Можно задать отдельное имя ключу
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```
- Определить ключ, который относится к нескольким колонкам
```
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

### 17. Тип ключа `not-null`
- Колонка всегда должна содержать значение отличное от null
```
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);
```
- Колонка может иметь несколько ключей
```
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price > 0)
);
```

### 18. Тип ключа `unique`
- Значение в каждой строче не должно повторяться, должно быть уникально
```
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);
```
- Группа колонок
```
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);
```
- 2 значения null не считаются одиннаковыми, поэтому стоит добавлять `NULLS NOT DISTINCT`
```
CREATE TABLE products (
    product_no integer UNIQUE NULLS NOT DISTINCT,
    name text,
    price numeric
);
```

### 19. Тип ключа `primary keys`
- Колонка или группа колонок может использоваться как уникальный идентификатор
```
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
```
идентично
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

### 20. Тип ключа `foreign keys`
- Обозначает, что данное значение связано с колонкой в другой таблице
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```
- Если мы хотим хранить ключи только на те элементы, которые действительно есть в другой таблице
```
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
```
- Группа ключей
```
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```
- Реализация many-to-many
```
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

### 21. Типы поведений при использовании foreig keys
- `ON DELETE RESTRICT` Запрет на удаление элементов
- `ON DELETE CASCADE` При удалении удалить все связанные элементы
- `ON DELETE NO ACTION` - дефолтное поведение, ничего не происходит, при проверке ключа будет выброшена ошибка
- `ON DELETE SET NULL` - При удалении будут выставлены нуловые значения
- `ON DELETE SET DEFAULT` - При удалении будут выставлены дефолтные значения (если дефолтное значение не будет соотвествовать условиям, то операция не будет выполнена)
```
CREATE TABLE tenants (
    tenant_id integer PRIMARY KEY
);

CREATE TABLE users (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    user_id integer NOT NULL,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE TABLE posts (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    post_id integer NOT NULL,
    author_id integer,
    PRIMARY KEY (tenant_id, post_id),
    FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL (author_id)
);
```

### 22. Тип ключа `exclusion constrains`
- При сравнении колонок, ни одно из сравнений не вернет true
```
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &&)
);
```

### 23. Как происходит блокировка во время транзации в Postgresql
PostgreSQL использует многоуровневую систему блокировок для обеспечения согласованности данных при транзакциях

Типы блокировок:
- Блокировка на уровне таблицы - блокируется доступ ко всей таблице
- Блокировка на уровне строки - Блокируют доступ к конкретным строкам в таблице

Как происходит блокировка:
- НАчало транзакции - Когда транзакция начинается, PostreSQL устанавливает блокировку на уровне таблицы для всех таблиц, которые будут затронуты транзакцией
- Чтение данных - Когда транзакция читает данные из таблицы, PostgeSQL устанавливает разделяемую блокировку на уровне строки для каждой прочитанной строки
- Изменение данных - Когда транзация изменяет данные в таблице, PostgreSQL устанавливает исключительную блокировку на уровне строки для каждой измененной строки
- Завершение транзакции - Когда транзакция завершается, PostgreSQL освобождает все установленные ею блокировки

Блокировки гарантируют:
- Данные не будут изменены другой транзакцией, пока она е завершится
- Две транзакции не смогут одновременно изменить одну и ту же строку


### 24. Виды блокировок
**Блокировка на уровне таблиц:**
- ACCESS SHARE. Позволяет читать таблицу, но не изменять её.
```postgresql
BEGIN;
SELECT * FROM your_table;
-- ACCESS SHARE блокировка установлена на your_table
COMMIT;
```
- ROW SHARE. Используется для команд SELECT FOR UPDATE и SELECT FOR SHARE.
```postgresql
BEGIN;
SELECT × FROM your_table WHERE id = 1 FOR UPDATE;
-- ROW SHARE блокировка установлена на your_table
COMMIT;

BEGIN;
SELECT × FROM your_table WHERE id = 1 FOR SHARE;
-- ROW SHARE блокировка установлена на your_table
COMMIT;
```
- ROW EXCLUSIVE. Применяется для команд, которые вносят изменения в таблицу (UPDATE, DELETE, INSERT).
```postgresql
BEGIN;
INSERT INTO your_table (column1) VALUES ('value');
-- ROW EXCLUSIVE блокировка установлена на your_table
COMMIT;
```
- SHARE UPDATE EXCLUSIVE. Используется для команд VACUUM (без FULL), ANALYZE, CREATE INDEX CONCURRENTLY и некоторых видов ALTER INDEX и ALTER TABLE.<br>
```postgresql
BEGIN;
VACUUM your_table;
-- SHARE UPDATE EXCLUSIVE блокировка установлена на your_table
COMMIT;sql
BEGIN;
ANALYZE your_table;
-- SHARE UPDATE EXCLUSIVE блокировка установлена на your_table
COMMIT;sql
CREATE INDEX CONCURRENTLY idx_your_table_column1 ON your_table(column1);
-- SHARE UPDATE EXCLUSIVE блокировка установлена на your_table на время создания индекса
```

* Блокировки на уровне таблиц устанавливаются автоматически системой базы данных, но их можно запросить явно с помощью команды LOCK.<br><br>


**Блокировка на уровне строк:**
- FOR UPDATE. Строки, выданные оператором SELECT, блокируются как для изменения.
```postgresql
BEGIN;
SELECT * FROM your_table WHERE id IN (1, 2, 3) FOR UPDATE;
-- Строки с id 1, 2 и 3 заблокированы FOR UPDATE
UPDATE your_table SET column1 = 'new_value' WHERE id = 1; -- Это пройдет успешно
COMMIT;
```
- FOR NO KEY UPDATE. Действует подобно FOR UPDATE, но блокировка слабее: не блокирует команды SELECT FOR KEY SHARE.
```postgresql
BEGIN;
SELECT * FROM your_table WHERE id IN (1, 2, 3) FOR NO KEY UPDATE;
-- Строки с id 1, 2 и 3 заблокированы FOR NO KEY UPDATE
UPDATE your_table SET column1 = 'new_value' WHERE id = 1; -- Это пройдет успешно
COMMIT;
```
- FOR SHARE. Для каждой из полученных строк запрашивается разделяемая, а не исключительная блокировка.
```postgresql
BEGIN;
SELECT * FROM your_table WHERE id IN (1, 2, 3) FOR SHARE;
-- Строки с id 1, 2 и 3 заблокированы FOR SHARE
SELECT * FROM your_table WHERE id = 1; -- Это пройдет успешно
-- UPDATE your_table SET column1 = 'new_value' WHERE id = 1; -- Это будет заблокировано
COMMIT;
```
- FOR KEY SHARE. Устанавливает более слабую блокировку: блокирует SELECT FOR UPDATE, но не SELECT FOR NO KEY UPDATE.
```postgresql
BEGIN;
SELECT * FROM your_table WHERE id IN (1, 2, 3) FOR KEY SHARE;
-- Строки с id 1, 2 и 3 заблокированы FOR KEY SHARE
SELECT * FROM your_table WHERE id = 1 FOR KEY SHARE; -- Это пройдет успешно
-- SELECT * FROM your_table WHERE id = 1 FOR UPDATE; -- Это будет заблокировано
COMMIT;
```
<br><br>

**Примеры использования блокировок:**
- Защита данных при вставке внешнего ключа. Можно получить блокировку SHARE для таблицы первичного ключа, чтобы предотвратить одновременные изменения данных.
- Выполнение операции удаления. Для таблицы с первичным ключом подходит режим SHARE ROW EXCLUSIVE, который позволяет выполнять только одну операцию удаления за раз.

## END ---------------- База данных ----------------

## Concurrency

+ [1. В чем разница между sleep() и wait()?](#1-в-чем-разница-между-sleep-и-wait)
+ [2. От какого количества начинается многопоточность?](#2-от-какого-количества-начинается-многопоточность)
+ [3. Какие есть издержки у многопоточности?](#3-какие-есть-издержки-у-многопоточности)
+ [4. Какие потоки создает JVM при запуске?](#4-какие-потоки-создает-jvm-при-запуске)
+ [5. Какой класс является потокобезопасным?](#5-какой-класс-является-потокобезопасным)
+ [6. Какие операции являются атомарными](#6-какие-операции-являются-атомарными)
+ [7. Что может являться монитором?](#7-что-может-являться-монитором)
+ [8. Как обезопасить использование объектов](#8-как-обезопасить-использование-объектов)
+ [9. Как создать потокобезопасный класс](#9-как-создать-потокобезопасный-класс)
+ [10. Что происходит при использовании synchronized](#10-что-происходит-при-использовании-synchronized)
+ [11. Как работает неблокирующая read блокировка](#11-как-работает-неблокирующая-read-блокировка)
+ [12. Как работает Оптимистическая блокировка](#12-как-работает-оптимистическая-блокировка)
+ [13. Как работают классы Atomic из пакета java.util.concurrent.atomic](#13-как-работают-классы-atomic-из-пакета-javautilconcurrentatomic)
+ [14. Чем отличается Runnable от Callable](#14-чем-отличается-runnable-от-callable)
+ [15. Конкурентные коллекции - классы для работы с коллекциями внутри потоков](#15-конкурентные-коллекции---классы-для-работы-с-коллекциями-внутри-потоков)
+ [16. `ConcurrentHashMap`](#16-concurrenthashmap)
+ [17. `CopyOnWriteArrayList`](#17-copyonwritearraylist)
+ [18. Блокирующие очереди](#18-блокирующие-очереди)
+ [19. Паттерн "Производитель-потребитель"](#19-паттерн-производитель-потребитель)
+ [20. Паттерн "Кража работ"](#20-паттерн-кража-работ)
+ [21. Блокирующие и прерываемые методы](#21-блокирующие-и-прерываемые-методы)
+ [22. Синхронизаторы - Классы для создания синхронизирующих точек](#22-синхронизаторы---классы-для-создания-синхронизирующих-точек)
+ [23. Синхронизатор - Защелки - latch](#23-синхронизатор---защелки---latch)
+ [24. `CountDawnLatch`](#24-countdawnlatch)
+ [25. `ReentrantLock`](#25-reentrantlock)
+ [26. `ReentrantReadWriteLock`](#26-reentrantreadwritelock)
+ [27. Синхронизаторы - FutureTask](#27-синхронизаторы---futuretask)
+ [28. Синхронизаторы - Семафоры](#28-синхронизаторы---семафоры)
+ [29. `Semaphore`](#29-semaphore)
+ [30. Синхронизаторы - Барьеры](#30-синхронизаторы---барьеры)
+ [31. `CyclicBarrier`](#31-cyclicbarrier)
+ [32. Какие недостатки у неограниченного количества потоков](#32-какие-недостатки-у-неограниченного-количества-потоков)
+ [33. Executors](#33-executors)
+ [34. Методы Executors](#34-методы-executors)
+ [35. Методы жизненного цикла Executors](#35-методы-жизненного-цикла-executors)
+ [36. Что такое "утечка потока"](#36-что-такое-утечка-потока)
+ [37. Жизненный цикл задачи, выполняемой исполнителем](#37-жизненный-цикл-задачи-выполняемой-исполнителем)
+ [38. Что такое `CompletionService`](#38-что-такое-completionservice)
+ [39. `ExecutorCompletionService`](#39-executorcompletionservice)
+ [40. Сколько куч будет при множественных потоках](#40-сколько-куч-будет-при-множественных-потоках)
+ [41. Что такое shutdown hook](#41-что-такое-shutdown-hook)

### 1. В чем разница между sleep() и wait()?
wait - освобождает монитор</br>
sleep- не освобождает монитор

### 2. От какого количества начинается многопоточность?
- от двух

### 3. Какие есть издержки у многопоточности?
- Context switches - контекстные переключения</br>
Приостановка работы активных потоков для работы других потоков</br>
Они сохраняют и восстанавливают контекст выполнения, но приводят к потере локальности и процессорного времени

### 4. Какие потоки создает JVM при запуске?
- Главный поток main
- Потоки для служебных задач (например сбора мусора)

### 5. Какой класс является потокобезопасным?</br>
Если он ведет себя правильно во время допуска из многочисленных потоков, независимо от того, как выполнение этих потоков планируется или перемещается рабочей средой</br>
и без дополнительной синхронизации или другой координации со стороны вызывающего</br>
Инкапсулируют любую логику необходимую для синхронизации сами и не нуждаются в помощи клиента

### 6. Какие операции являются атомарными</br>
Операции являются атомарными если с точки зрения потока, выполняющего операцию А, операция В либо была выполнена целиком другим потоком, </br>
либо не выполнена даже частично

### 7. Что может являться монитором?</br>
Каждый объект Java может неявно действовать как замок для целей синхронизации, то есть внутренним замком (intrinsic lock)</br>
или мониторным замком (monitor locks)</br></br>

Внутренние замки действуют как взаимоисключающие замки - мьютексы(mutual exclusion locks)

### 8. Как обезопасить использование объектов
- Ограничение одним потоком
- Совместный доступ только для чтения
- Совместная потокобезопасность - объект выполняет синхронизацию внутренне, поэтому потоки свободно обращаются к нему через его публичный интерфейс
- Защищенность - с удержанием конкретного замка можно обращаться к объекту, инкапсулированному в другие потокобезопасные объекты, а также к опубликованному объекту, защищенному замком

### 9. Как создать потокобезопасный класс
- Ограничение одним экземпляром - объект инкапсулируется в другой объект, к коорому имеют доступ только некоторые известные ветки кода (Collections.synchronizedList)
- Мониторный шаблон Java (HashTable) - состояние под защитой внутреннего замка

### 10. Что происходит при использовании `synchronized`
- Попытка блокирования монитора
- Блокировка потока
- Разблокировка монитора
- Разблокировка потока

### 11. Как работает неблокирующая read блокировка
- Не ожидает пока данные будут готовы для чтения
- Если данные не готовы в момент обращения, то возвращается пустой ответ или код ошибки
- Операция является асинхронной

### 12. Как работает Оптимистическая блокировка
- Основана на идее, что два потока могут изменить один и тот же ресурс

1. Поток сначала делает копию ресурса в локальный буффер
2. Изменяет ресурс
3. Сравнивает с оригинальным ресурсом
4. Если никакой другой поток не изменил ресурс, то изменения применяются
5. Если ресурс был изменен, то поток сбрасывает свои изменения и потовряет все с пункта 1

### 13. Как работают классы Atomic из пакета `java.util.concurrent.atomic`
- Использует "Оптимистическую блокировку"

### 14. Чем отличается Runnable от Callable
| Runnable                                                                                 | Callable                                                                         |
|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Возвращает значение                                                                      | Может вернуть результат вычисления                                               |
| Содержит только 1 метод run(), который не принимает аргументов и не возвращает результат | Содержит метод call(), который может выбразывать исключения, не требуя обработки |
| Для выполнения можно использовать   ExecutorService и Thread лассы                       | Для выполнения можно использовать ExecutorService и FutureTask классы            |

### 15. Конкурентные коллекции - классы для работы с коллекциями внутри потоков
- `ConcurrentHashMap`
    - При записи блокируется только часть (сегмент)
- `CopyOnWriteArrayList`
    - Блокирующий на запись
    - Не блокирующий на запись
- `CopyOnWriteArraySet`
    - CopyOnWriteArrayList без значений
- `ConcurrentSkipListMap`
- `ConcurrentSkipListSet`
    - ConcurrentSkipListMap без значений
- `Queue`
  - Для временногого хранений множества элементов во время ожидания ими обработки
  - `ConcurrentLinkedQueue` - традиционная очередь с дисциплиной доступа FIFO
  - `PriorityQueue` - неконкурентная упорядоченная очередь с приоритетом
- `DelayQueue`
    - PriorityBlockingQueue разрешающая получить элемент только после определенной задержки
- `LinkedTransferQueue`

### 16. `ConcurrentHashMap`
- Это хешировання ассоциациативный массив Map
- Не использует синхронизацию каждого метода на общем замке и ограничение доступа одним потоком за раз
- Использует **замковое расщепление на полосы (lock striping)**
- Обеспечивает конкурентность между читающими потоками, между читателями и писателями
- Предоставляет итераторы, которые не выдают исключение `ConcurrentModificationException`

### 17. `CopyOnWriteArrayList`
- Принцип "Копировать при записи"
- При создании и публикации копии коллекции после каждого ее изменения реализуется мутируемость
- Итераторы сохраняют ссылку на резервный массив, который был актуальным в начале итератичного обхода

### 18. Блокирующие очереди
- `BlockingQueue`
    - Если очередь пустая, то операция извлечения заблокирована
    - Если ограниченная очередь заполнена, то операция вставки будет заблокирована
- `LinkedBlockingQueue`
  - Однонаправленный BlockingQueue
- `ArrayBlockingQueue`
    - четкая очередь для передачи сообщений из одного потока в другой
    - Запрещает null значения
    - Емкость очереди указывается при создании
- `LinkedBlockingQueue`
    - Однонаправленный BlockingQueue
- `PriorityBlockingQueue`
- `SynchronousQueue`
  - не содержит места для хранения элементов
  - поддерживает список потоков, ожидающих постановки элемента в очередь или его удаления
( Двухсторонные очереди )
- `LinkedBlockingDeque`
    - Двунаправленный BlockingQueue
- `BlockingDeque`

### 19. Паттерн "Производитель-потребитель"
- Производители помещают данные в очередь, ничего не зная о потребителях, которые будут извлекать эти данные
- Потребитель не должны знать откуда берется работа
- Паттерн поддерживает **серийное ограничение одним потоком (serial thread confinement)** мутируемых объектов
  - Если пул содержит внутреннюю синхронизацию, 
  - а кликенты не собираются публиковать принадлежащий пулу объект или использовать его после возвращения в пул
  - владение может безопасно передаваться из потока в поток

```
public class FileCrawler implements Runnable {
    private final BlockingQueue<File> fileQueue;
    private final FileFilter fileFilter;
    private final File root;
    ...
    public void run () {
        try {
            crawl(root);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void crawl (File root) throws InterruptedException {
        File[] entries = root.listFiles(fileFilter);
        if (entries != null) {
            for (File entry : entries) {
                if (entry.isDirectory()) {
                    crawl(entry);
                } else if (!alreadyIndexed(entry)) {
                    fileQueue.put(entry);
                }
            }
        } 
    }
}

public class Indexer implements Runnable {
    private final BlockingQueue<File> queue;
    
    public Indexer (BlockingQueu<File> queue) {
        this.queue = queue;
    }
    
    public void run () {
        try {
            while (true) {
                indexFile(queue.take());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

}

public static void startIndexing (File[] roots) {
    BlockingQueue<File> queue = new LinkedblockingQueue<File>(BOUND);
    FileFilter filter = new FileFilter(){
        public boolean accept (File file) { return true; }
    };
    
    for (File root : roots) {
        new Thread (new FileCrawler(queue, filter, root)).start();
    }
    
    for (int i = 0; i < N_CONSUMERS, i++) {
        new Thread (new Indexer(queue)).start();
    }
}
```

### 20. Паттерн "Кража работ"
- Двухсторонняя очередь позволяет эффективно вставлять и удалять как голову очередь так и ее хвост
- Каждый потребитель исчерпывает работу в своей очередь
- Может украсть работу из чужой очереди
- Просмотр чужой очереди начинается с конца
( Используется )
- В алгоритмах разведывания графов - маркировка кучи во время сборки мусора

### 21. Блокирующие и прерываемые методы
- Прерывание представляет собой кооперативный механизм
  - Когда поток А пытается прерывать поток В, то просто просит поток В прекратить это делать
- При вызове метода interrupt нужно учитывать
1. **Распространить исключение** InterruptedException
   - неотлавливание исключение
   - или отлавливание и его повторная выдача после обработки
2. **Восстановить прерывание**
   - Когда невозможно распространить исключение необходимо перехватить исключение и восстановить статус прерванности (например в Runnable)

### 22. Синхронизаторы - Классы для создания синхронизирующих точек
- Это любой объект, координирующий поток управления в остальных потоках, основываясь на их состоянии
- Синхронизаторы инкапсулируют состояние, которое определяет пропускать или отправлять в ожидание поступающие потоки

### 23. Синхронизатор - Защелки - latch
- Синхронизатор, который может зардерживать продвижение потоков до достижения своего конечного состояния
- Предназначены для ожидания событий

- `CountDownLatch`
- `ReentrantLock`
- `ReentrantReadWriteLock`

1. Состояние защелки состоит из счетчика, инициализируемого положительным числом ожидаемых событий 
2. Метод `countDown` уменьшает счетчик, сигнализируя о том, что произошло событие
3. Метод `await` ожидают до тех пор, пока счетчик не достигнет нуля

### 24. `CountDawnLatch`
- Позволяет ожидать завершения других потоков
- При инициализации указывается количество блокирующих операций
- Как только CountDawnLatch.countDown будет вызван указанное количество раз и счетчик станет равен 0, тогда поток разблокируется
- Не зависимо от того, сколько раз будет вызван `await` в рамках одного потока, достаточно одного вызова `countDown` для освобождения счетчика

```
public class TestHarness {
    public long timeTasks (int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        
        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread () {
                public void run () {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) { }
                }
            };
            
            t.start();
        }
        
        long start = System.nanotTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end-start;
    }
}
```

### 25. `ReentrantLock`
- Блокировка
    - Может блокировать доступ к ресурсу на нескольких уровнях
    - При использовании метода `lockInterruptibly` блокировка может быть прервана
- Свободный доступ
    - Метод tryLock позволяет проверить свободен ли ресурс и попытаться захватить если он свободен
- Инкремент счетчика блокировок
    - Создержит внутренний счеткик блокировок, что позволяет увеличивать его каэдый раз, когда поток пытается захватить блокировку
    - Таким образом может блокировать доступ к ресурсу только тому же потоку, который блокировал его ранее
    - Если другой поток запросит доступ к ресурсу, пока он заблокирован, он будет заброкирован, пока первый поток не освободит блокировку

```
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
  private final ReentrantLock reentrantLock = new ReentrantLock();

  public void accessResource() {
    reentrantLock.lock();
    try {
      // Доступ к общему ресурсу
    } finally {
      reentrantLock.unlock();
    }
  }
}
```

```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class SharedResource {
  private final ReentrantLock lock = new ReentrantLock();
  private final Condition condition = lock.newCondition();

  public void accessResource() throws InterruptedException {
    lock.lock();
    try {
      while (!conditionIsMet()) {
        condition.await();
      }
      // Доступ к общему ресурсу
    } finally {
      lock.unlock();
    }
  }

  public void notifyCondition() {
    lock.lock();
    try {
      // Изменение состояния условия
      condition.signalAll();
    } finally {
      lock.unlock();
    }
  }

  private boolean conditionIsMet() {
    // Проверка условия
  }
}
```

### 26. `ReentrantReadWriteLock`
- Read lock - Если ни один поток не пишет, то любое число потоков может читать
- Write Lock - Если ни один поток не читает, то один поток может писать

### 27. Синхронизаторы - FutureTask
- Реализует `Future`, описывающий абстрактные вычсисления, приносящие результат, котоыре реализуется с помощью интерфейса `Callable`
- Могут находиться в состоянии ожидания выполнения
* Не рекомендуется запускать поток из конструктора или статического инициализатора
```
public class Preloader {
    private final FutureTask<ProductInfo> future = 
        new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    
    private final Thread thread = new Thread(future);
    
    public void start () { thread.start(); }
    
    public ProductInfo get () throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException) {
                throw (DataLoadException) cause;
            } else {
                throw launderThrowable(cause);
            }
        }
    }
}
```

### 28. Синхронизаторы - Семафоры
- Регулируют число действий, способных обращаться к определенному ресурсу или выполнять одну и ту же задачу в одной и то же время

- `Semaphore`

### 29. `Semaphore`
- ограничивает количество потоков, которые могут получить доступ до секции
- Управляет набором вируальных разрешений (permits)
- Начальное число значений передается конструктору
- Действия могут приобретать разрешения (`acquire`)
- Действия могут освобождать разрешения (`release`)
- Превращает любую коллекцию в блокирубющуя связанную коллекцию

### 30. Синхронизаторы - Барьеры
- Блокируют группу потоков до наступления какого-то события
- Заствялют потоки вместе проходить барьерную точку в одно и то же время
- Предназначены для ожидания других потоков

- `CyclicBarrier`
- `Exchanger` - двухсторонний барьер
- `Phaser` - расширяет функциональность `CyclicBarrier`

### 31. `CyclicBarrier`
- Выполняет синхронизацию заданного количества потоков в одной точке

### 32. Какие недостатки у неограниченного количества потоков
- создание каждого потока занимает время и требует некоторой обрабатывающей деятельности
- Ресурсопотребление - Потоки потребляют системные ресурсы, в особенности память
- Стабильность - есь лимит на число создаваемых потоков

### 33. Executors
Использование Executor является одним из способов реализации паттерна "производитель-потребитель"</br>

- Помогает повторно использовать освободившиеся потоки
- Помогает организовывать очереди из пула потоков
- Помогает подписываться на результат выполнения задачи

1. `ThreadPoolExecutor` - пул потоков с возможностью указывать рабочее и максимальное кол-во потоков в пуле
2. `ScheduledThreadPoolExecutor` - расширяет фунционал `ThreadPoolExecutor` возможностью выполнять задачи отложенно или регулярно
3. `ThreadPoolExecutor` - Более легкий пул потоков для "самовоспроизводящихся" задач

### 34. Методы Executors
- newFixedThreadPool - пул потоков фиксированного размера создает определенного число потоков по мере предоставления задач, а зачем стараетсяч держать размер пула
- newCachedThreadPool - кэшированный пул потоков убирает простаивающие потоки и при необходимости добавляет новые
- newSingleThreadExecutor - Создает один поток для последовательной обработки задач
- newScheduledThreadPool - пул потоков фиксированного размера, который поддерживает отложенное и переодическое выполнение задач

### 35. Методы жизненного цикла Executors
- Жизненный цикл имеет три состояния
  - работает
  - выключается
  - терминирован
```
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow(); // Возвращает список задач, которые не были начаты
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    ...
}
```

### 36. Что такое "утечка потока"
Timer - Поток не может отлавливать непроверяемое исключение, выдаваемое из задачи TimeTask, которое его терминирует

### 37. Жизненный цикл задачи, выполняемой исполнителем
- создана
- предоставлена
- запущена
- завершена
```
public interface Callable<V> {
    V call() throws Exception;
}

public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException, CancellationException;
    V get(long timeout, TimeUnit unit) thows InterruptedException, ExecutionException, CancellationException, TimeoutException;
}
```

### 38. Что такое `CompletionService`
- Сочетает в себе функционал исполнителя `Executor` и блокирующей очереди `BlockingQueue`
- Можно передавать ей задачи `Callable` на выполнение и использовать методы `take` и `poll`

### 39. `ExecutorCompletionService`
- может использовать один исполнитель `Executor` совместно
- В данном кейсе `CompletionService` действует как дескриптор для пакета вычислений.
  - Запоминает число задач
  - Подсчитывает число извлеченных завершенных результатов
- Можно узнать когда все результаты для данного пакеты были извлечены благодаря работе `CompletionService`

### 40. Сколько куч будет при множественных потоках
Куча всегда общая для всех потоков и все потоки имеют к ней доступ

### 41. Что такое Shutdown hook
Shutdown hook — это специальная конструкция в Java, которая позволяет зарегистрировать поток, который будет выполняться при выключении виртуальной машины Java (JVM).

Shutdown hooks подходят для таких задач, как:

 - закрытие файлов или сетевых соединений;
 - освобождение ресурсов или памяти;
 - сохранение состояния приложения в файл или базу данных.

## END ---------------- Concurrency ----------------

## Способы выполнения запросов к другим источникам

+ [1. Какие есть способы выполнения запросов к другому источнику](#1-какие-есть-способы-выполнения-запросов-к-другому-источнику)
+ [2. Как работает RestTemplate](#2-как-работает-resttemplate)
+ [3. Как работает WebClient](#3-как-работает-webclient)
+ [4. Пример RestTemplate](#4-пример-resttemplate)
+ [5. Пример WebClient](#5-пример-webclient)

### 1. Какие есть способы выполнения запросов к другому источнику
- RestTemplate
- WebClient

### 2. Как работает RestTemplate
Использует Java Servlet API, который использует 1-тред-на запрос
Это означает, что тред будет заблокирован пока не будет получен ответ
Проблема в том, что каждый тред будет забирать какое-то количество CPU

### 3. Как работает WebClient
Использует асинхронное, не блокирующее решение, которое предоставляет Spring Reactive framework
Под капотом запросы будут выстроены в очередь
Благодаря очередям будет создано меньшее количество тредов, что приведет к меньшей потребности в памяти

### 4. Пример RestTemplate
```
@Bean
public RestTemplate restTemplate (RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofMills(3000))
        .setReadTimeout(Duration.ofMills(3000))
        .build();
}

@Bean
public RestTemplate restTemplate () {
    RestTemplate restTemplate = new RestTemplate();
    return restTemplate;
}
```

### 5. Пример WebClient
```java
@GetMapping(value = "/tweets-non-blocking",
  produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<Tweet> getTweetsNonBlocking() {
  log.info("Starting NON-BLOCKING Controller!");
  Flux<Tweet> tweetFlux = WebClient.create()
  .get()
  .uri(getSlowServiceUri())
  .retrieve()
  .bodyToFlux(Tweet.class);

  tweetFlux.subscribe(tweet -> log.info(tweet.toString()));
  log.info("Exiting NON-BLOCKING Controller!");
  return tweetFlux;
  }
```

## END ---------------- Способы выполнения запросов к другим источникам ----------------

## Spring изнутри

+ [1. Ключевые понятие Spring](#1-ключевые-понятие-spring)
+ [2. Какая структура у Spring контейнера](#2-какая-структура-у-spring-контейнера)
+ [3. Какая структура у Spring](#3-какая-структура-у-spring)
+ [4. Что такое автоконфигурация в контексте Spring](#4-что-такое-автоконфигурация-в-контексте-spring)
+ [5. Условия создания бина](#5-условия-создания-бина)
+ [6. Что содержит аннотация `@SpringBootApplication`](#6-что-содержит-аннотация-springbootapplication)
+ [7. Что делает метод `SpringApplication.run()`](#7-что-делает-метод-springapplicationrun)
+ [8. Что такое `AnnotationConfigEmbeddedWebApplicationContext`](#8-что-такое-annotationconfigembeddedwebapplicationcontext)
+ [9. За что отвечает аннотация `EnableAutoConfiguration`](#9-за-что-отвечает-аннотация-enableautoconfiguration)
+ [10. Какие есть этапы инициализации](#10-какие-есть-этапы-инициализации)
+ [11. Этап Парсирование конфигурациии создание 'BeanDefinition'](#11-этап-парсирование-конфигурациии-создание-beandefinition)
+ [12. Этап Настройка созданных 'BeanDefinition'](#12-этап-настройка-созданных-beandefinition)
+ [13. Что содержит фабрика `BeanFactoryPostProcessor`](#13-что-содержит-фабрика-beanfactorypostprocessor)
+ [14. Этап Создание кастомных `FactoryBean`](#14-этап-создание-кастомных-factorybean)
+ [15. Этап Создание экземпляров бинов](#15-этап-создание-экземпляров-бинов)
+ [16. Этап Настройка созданных бинов](#16-этап-настройка-созданных-бинов)
+ [17. Как создаются контекст и бины? Опишите флоу создания спринг приложения](#17-как-создаются-контекст-и-бины-опишите-флоу-создания-спринг-приложения)
+ [18. Жизненный цикл бина](#18-жизненный-цикл-бина)
+ [19. Жизненный цикл spring](#19-жизненный-цикл-spring)
+ [20. Какой тип наследования используется при расширении бина](#20-какой-тип-наследования-используется-при-расширении-бина)
+ [21. Типы расширения бинов](#21-типы-расширения-бинов)

### 1. Ключевые понятие Spring
- Бины - это обычный объект, который живет внутри DI-контейнера
- DI-контейнер - Ключевой и фундаментальный механизм Spring.

Спринт - это по сути набор бинов, связанных вместе через DI контейнер</br>
При конфигурации например 'OAuth' в 'application.properties' спринт предоставляет бин 'OAuth2RestTemplate'</br>
При этом этот бин при обращении к внешнему API будет знать, куда и как пойти, чтобы получить OAuth токен</br>
как его обновлять, в какое место нашего запроса его добавлять и т.д.</br>
То есть контейнер - это механизм общения между нашим кодом и библиотеками, подключенными к проекту</br></br>

Использование инъекций зависимостей не подразумевает создания интерфейсов для каждого компонента.</br></br>

- Контекст - Представлен интерфейсом 'ApplicationContext'. Позволяет реагировать на различные события,</br>
  которые происходят внутри приложения, управлять жизненным циклом

- Конфигурация - описание доступных бинов</br>
  Бины могут быть описаны как в одном файле, так как и в разных

- Сканирование компонентов - спринг сканирует приложений на предмет таких аннотаций как @Component, @Service и т.д. и создает из них бины</br>
  при этом это считается неявным изменением контекста приложения</br></br>

### 2. Какая структура у Spring контейнера
- Можно представить в виде древовидной структуры
- Каждый узел представляет бин
- Родительский узел представлен контекстом

1. Класс "ApplicationContext" - это основной класс контекста Spring
   Содержит ссылки на все созданные бины
2. Класс "BeanDefinition" - это класс представляет метаданные о бине, такие как его класс зависимости, область видимости
   Содержит информацию для создания и настройки бина
3. Класс "BeanFactory" - это интерфейс, который определяет функциональность контейнера для создания, хранения и предоставлении бинов
Содержит методы для регистрации бинов и получения доступа к ним
4. Класс "DefaultListableBeanFactory" - Предоставляет реализацию интерфейса `BeanFactory` и предоставляет основную функицональность контейнера
Содержит структуры данных, такие как HashMaps для хранения и доступа к бинам
5. Класс "HierarchicalBeanFactory" - Интерфейс, который определяет иерархическую структуру контейнера, где контейнеры могут иметь родитеские контексты

### 3. Какая структура у Spring
1. Бины - Это объекты, которые управляются контейнером Spring
Бины создаются, настраиваются и внедряются в приложение. Представляют компоненты, такие как сервисы, репозитории, контроллеры
2. Конфигурационный метаданные (Configuration Metadata) - информация, необходимая для создания и настройки бинов
3. Контекст (Context) - среда, в которой бины создаются, настраиваются и связываются друг с другом
Обеспечивает доступ к бинам и контролирует их жизненные цикл</br>
Может быть иерархическим, то есть может иметь родительский контекст
4. Контроллеры (Controllers) - Компоненты, которые обрабатывают входящие запросы и возвращают соотвествующий ответ
5. Сервисы (Services) - Компоненты, которые содержат бизнес-логику
6. Репозитории (Repositories) - Предоставляют абстракцию для доступа к базе данных или другому источнику данных

### 4. Что такое автоконфигурация в контексте Spring
Это набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении.</br>
Можно сказать, что сам Embedded Servler Container - это тоже еще один бин</br></br>

- Включается аннотацией `@EnableAutoConfiguration`
- Работает в последнюю очередь, после регистрации пользовательских бинов
- Принимает решение о конфигурации на основании доступных в classpath классов, свойств в 'application.properties'
- Можно включать и выключать разные аспекты автоконфигурации
- Всегда отдает приоритет пользовательским бинам</br></br>

### 5. Условия создания бина
Логика при регистрации бинов управляется набором `@ConditionalOn*` аннотаций </br>
Можно указать, чтобы быин создавался при наличии в classpath (@ConditionalOnClass), </br>
наличии существующего бина (@ConditionalOnBean), отсутствии бина (@ConditionalOnMissingBean)

```
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

### 6. Что содержит аннотация `@SpringBootApplication`
 мета аннотация, алиас для нескольких аннотаций
- @SpringBootConfiguration
- @EnableAutoConfiguration
- @ComponentScan

### 7. Что делает метод `SpringApplication.run()`
это хелпер, который используя список предоставленных конфигураций создает 'ApplicationContext',</br>
конфигурирует его, выводит баннер в консоли и засекает время старта приложения</br>

### 8. Что такое `AnnotationConfigEmbeddedWebApplicationContext`
Наследник Spring Boot - знает о embedded servlet container-ах и умеет их запускать

### 9. За что отвечает аннотация `EnableAutoConfiguration`
включает автоконфигурацию
```
@Import(EnableAutoConfigurationImportSelector.class)
    public @interface EnableAutoConfiguration {
        ...
    }
}
```

`EnableAutoConfigurationImportSelector` - это конфигурация, которая добавит несколько бинов в контекст.</br>
Этот класс не объявляет бины сам, а использует так называемые фабрики.</br>
Класс смотрит в файл 'spring.factories' и загружает оттуда список значений, которые являются именами классов ((авто)конфигураций),</br>
которые Spring Boot импортирует</br></br>

### 10. Какие есть этапы инициализации
1. Парсирование конфигурациии создание 'BeanDefinition'
2. Настройка созданных 'BeanDefinition'
3. Создание кастомных `FactoryBean`
4. Создание экземпляров бинов
5. Настройка созданных бинов

### 11. Этап Парсирование конфигурациии создание 'BeanDefinition'
Задача данного этапа - это создание всех 'BeanDefinition'.</br>
'BeanDefinition' - это специальный интерфейсы, через который можно получить доступ к метаданным будущего бина

### 12. Этап Настройка созданных 'BeanDefinition'
После первого этапа у нас имеется Map, в котором хранятся 'BeanDefinition'</br>
Спринт дает нам возможность повлиять на то, какими будут наши бины еще до их создания,</br>
то есть мы можем получить доступ к метаданным класса.</br>
Для получения доступа к метаданным есть специальный интерфейс 'BeanFactoryPostProcessor'</br>
```
public interface BeanFactoryPostProcessor {
`void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
}
```

### 13. Что содержит фабрика `BeanFactoryPostProcessor`
фабрика содержит такие методы как 'getBeanDefinitionNames', через который можно получить все 'BeanDefinitionNames',</br>
а потом по конкретному имени получить 'BeanDefinition' для дальнейшей обработки метаданных</br></br>

Например, если в классе есть поля, которые должны быть заполнены из файла '.propeties' </br>
то после постпроцессинга они будут добавлены к класс бина</br></br>

### 14. Этап Создание кастомных `FactoryBean`
актуально если бины до сих пор создаются через xml и нужно создать ряд бинов, </br>
у которых не сильно отличаются настройки

### 15. Этап Создание экземпляров бинов
Созданием экземпляров бинов занимается 'BeanFactory' при этом можно дерегировать это кастомным 'FactoryBean'</br>
Экземпляры бинов создаются на основе ранее созданных 'BeanDefinition'</br>
После создания бина он добавляется в Map<BeanName, Bean></br></br>

### 16. Этап Настройка созданных бинов
Интерфейс 'BeanPostProcessor' позволяет вклиниться в процесс настройки бинов, до того как они попадут в контейнер
```
public interface BeanPostProcessor {
  Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // до init метода
  Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; // после init метода
}
```

* Если нужно сделать прокси над объектом, то лучше это делать в `postProcessAfterInitialization`
* `BeanPostProcessor` обязательно должен быть бином

### 17. Как создаются контекст и бины? Опишите флоу создания спринг приложения
- Application -> StartingEvent
  Когда мы пишем `SpringApplication.run`
    - Находит всех слушателей и кидает событие, что приложение начало строиться
- Application -> EnvironmentPreparedEvent, EnvironmentPostProcessor's
    - Слушателели находят `EnvironmentPostProcessor` и дают им настроить environment
- Application -> PreparedEvent, Application ContextInitializer's
    - В этот момент environment уже настроен и начинает строиться контекст
    - В этот же момент всем `ApplicationInitializer` получают возможность с данным контекстом что-то сделать
- Context -> RefreshEvent
    - Контекст настроен и начинают работать `BeanFactoryPostProcessor`, `BeanPostProcessor`
- EmbeddedServler -> Container InitializedEvent
- Application -> ReadyEvent

### 18. Жизненный цикл бина
1. Контекст приложения создает экземпляр бина
2. Если у бина есть зависимости на другие бины, контекст приложения рекурсивно создает их
3. Зависимости бинов внедряются
4. Если бин реализует интерфейс `InitializingBean`, он вызывает метод `afterPropertiesSet()`, который может быть использован для настройки бина
5. Если бин определен с аннотацией `@PostConstruct`, метод, помеченный этой аннотацией, вызывается для инициализации бина
6. Бин готов для использования в приложении
7. Когда контекст приложения завершает работу, он вызывает методы `destroy()` для бинов реализующих интерфейс `DisposableBean`
8. Если бин определен с использованием аннотации `@PreDestroy`, метод, помеченный аннотацией, вызывается пперд уничтожением бина

### 19. Жизненный цикл spring
1. **Загрузка контекста** - контейнер IoC загружает и инициализирует контекст приложения
Происходит считывание и обработка конфигурационных файлов приложения
2. **Создание бинов** - Контейнер IoC создает экземпляры бинов. Используется рефлексия и механизм инъекции зависимостей
3. **Внедрение зависимочтей** - Контейнер IoC внедряет зависимости бинов на основе их конфигурции. 
Может быть выполнение через конструктор, сеттеры или аннотации
4. **Инициализация бинов** - Если у бина есть методы инициализации (например помеченные `@PostConstruct`) они вызываются для подготовик бина к использованию
5. **Работа с приложением**
6. **Уничтожение приложения** - Контейнер IoC вызывает методы уничтожения бинов (например помеченные `@PreDestroy`)

### 20. Какой тип наследования используется при расширении бина
- JDK Dynamic Proxies (динамические прокси JDK)
- CGLIB (Code Generation Library)</br>

- JDK Dynamic Proxies - для интерфейсных бинов Spring создает динамические прокси. 
  - Работает путем создания объекта, который реализует тот же интерфейс, что и бин, и оборачивает вызовы методов вокруг оригинального объекта
- CGLIB - выполняет байтовую кодогенерацию и создает подклассы оригинального класса, котолрые оборачивают вызовы методов
  - Позволяет создавать прокси-объекты для публичиных и для защищенных/приватных методов класса</br>

Spring сам выбирает какой способ использовать
- Если класс имплементирует интерфейс, используется JDK Dynamic Proxies
- Если класс не импелемнтирует интерфейс или задан флаг `proxy-target-class` в настройках Spring, используется CGLIB

### 21. Типы расширения бинов
- `BeanPostProcessor` - позволяет вмешиваться в процесс создания бинов до и после и инициализации.
  - `postProcessBeforeInitialization` - перед иницализацией
  - `postProcessAfterInitialization` - после иницализации
- `BeanFactoryPostProcessor` - позволяет изменить метаданные бинов перед созданием их фабрикой (BeadnFactory)
  - `postProcessBeanFactory` - определяет метод, которые принимает BeanFactory в качестве аргумента
- `FactoryBean` - позволяет создавать бины, которые могут быть созданы специальной фабрикой, вместо непосредственного создания экземпляра бина
  - `getObject` - должен вернуть созданный бин
- `BeanDefinitionRegistryPostProcessor` - позволяет изменить конфигурации бинов всего приложения.
  - Работает аналогично `BeanFactoryPostProcessor`, но позволяет добавить, изменить или удалять дополнительные `BeanDefinitions` до и после фактории бинов
- `ApplicationListener` - позволяет реагировать на события, происходящие в контексте, например, события запуска и остановки контекста
- `InitializingBean` и `DisposableBean` - позволяют определить пользовательскую логику иницализации и уничтожения бинов
  - `InitializingBean.afterPropertiesSet` - выполяется после установки свойств бина
  - `DisposableBean.destroy` - выполняется перед уничтожением бина

## END ----------------- Spring изнутри -----------------

## Spring

+ [1. Что такое Autowiring и как работает](#1-что-такое-autowiring-и-как-работает)
+ [2. Плюсы и минусы @Autowired](#2-плюсы-и-минусы-autowired)
+ [3. В чём разница между @Component, @Service и @Repository аннотациями?](#3-в-чём-разница-между-component-service-и-repository-аннотациями)
+ [4. AOP](#4-aop)
+ [5. Spring boot](#5-spring-boot)
+ [6. Как активировать/деактивировать Бин](#6-как-активироватьдеактивировать-бин)
+ [7. Spring Filters](#7-spring-filters)
+ [8. @PreDestroy что это такое и зачем он нужен](#8-predestroy-что-это-такое-и-зачем-он-нужен)
+ [9. Кто уничтожает бин со Scope prototype](#9-кто-уничтожает-бин-со-scope-prototype)
+ [10. Аннотация @Cachable](#10-аннотация-cachable)
+ [11. Аннотация @Async](#11-аннотация-async-)
+ [12. Типы Repository](#12-типы-repository)
+ [13. Модули spring Session](#13-модули-spring-session)
+ [14. Какой аннотацией включается сессия](#14-какой-аннотацией-включается-сессия)
+ [15. Пример своего `WebSecurityConfig`](#15-пример-своего-websecurityconfig)
+ [16. Как заинджектить несколько бинов по одному интерфейсу](#16-как-заинджектить-несколько-бинов-по-одному-интерфейсу)
+ [17. @Primary](#17-primary)
+ [18. @Qualifier](#18-qualifier)
+ [19. Можно ли заинджекстить Singleton в Prototype](#19-можно-ли-заинджекстить-singleton-в-prototype)

### 1. Что такое `Autowiring` и как работает
**IOC** - Inversion of control</br>
делегирование части обязанностей внешнему компоненту</br>
Управление отдается на сторону, но мы получаем возможность гибко конфигурировать и подменять модули</br></br>

Бин - создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект</br></br>

ApplicationContext - Это сердце спринга. Как правило, он создается в самом начале работы приложения</br></br>

По умолчанию каждый бин имеет внутриспринговое свойство 'scope' в значении 'singleton',</br>
то есть создается ровно один экземпляр класса
```
Определение бина
ИЛИ В файле xml
<bean id="product" class="main.java.Product"></bean>
// Указание места сканирования
<context:component-scan base-package="main"/>
// Поднять контекст из файл xml
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```
Как работает</br>
При поднятии контекста создается бин-объект всех объектов, которые помечены аннотациями `@Component`, `@Service`, `@Controller`, `@Repository`</br>
Когда спринг видит аннотацию @Autowired он начинает искать подходящий бин. Если бин только один, то он без проблем его инжектит</br></br>

Аннотация `@Autowired` можно ставить
- На поле
- На сеттеры
- На определенные методы</br></br>

Если оддинаковых бинов несколько
- Для определения конкретного бина необходимо использовать аннотацию '@Qualifier("dependency1") ServiceDependency'
- Для использования всех бинов
```
@Autowired
public void setDependency(ServiceDependency[] dependencies)
```

### 2. Плюсы и минусы `@Autowired`

| +  | -   | 
|-----|-----|
|  Требует меньше кода  | Менее экспрессивный, чем явное инжектирование |
|  Уменьшает время разработки | Усложняет автонаписание инструкций |
|    | Множетвенные инъекции могут пересекаться с названием конкруктора|

**Ограничения**
- Явные зависимости и аргументы конструктора и свойства всегда переписывают инъекции
- Инъекции через констркутор всегда переписывают инекции свойств
- Нельзя переписать примитивы
- Сложно ориентироваться при большом количестве инъекций

### 3. В чём разница между @Component, @Service и @Repository аннотациями?
**@Component** - универсальный компонент</br></br>

**@Repository** - компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.class</br>
умеет перехватывать спецефичные для платфомы исключения и повторно генерирует их как одно из унифицированных непроверенных исключений Spring</br>
Бин проксируется и ему добавляются exception handlers</br></br>

**@Service** - фасад для некоторой бизнес логики</br></br>

**@Controller** - класс, в котором указываются контроллеры приложения</br>
Для получения объекта body внутри методов необходимо дополнительно использовать аннотацию @RequestBody</br>
Используется для возврата view
```
@Controller
@RequestMapping("books")
public class SimpleBookController {

    @GetMapping("/{id}", produces = "application/json")
    public @ResponseBody Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```

**@RestController** - Это специализированная сервис контроллера. Включает в себя @Controller и @ResponseBody аннотации</br>
Необходим при написании REST запросов
```
@RestController
@RequestMapping("books-rest")
public class SimpleBookRestController {
    
    @GetMapping("/{id}", produces = "application/json")
    public Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```

**@Configuration** - класс для настройки приложения, объявления бинов

### 4. AOP
Аспектно-ориентированное программирование - это парадигма программирования, являющейся в дальнейшем развитием процедурно и объектно-ориентированного программирования</br></br>

**Join Point** - это точки наблюдения, присоединения к коду, где планируется введение функциональности

```
@Pointcut("execution(* com.example.spring._10.AOP_order.dao.*.*(..)))")
public void forDaoPackage () {}
```
**Pointcut** - Это срез, запрос точек присоединения</br></br>

**Advice**  - набор инстракций выполняемых на точках среза (может быть несколько для одного Pointcut)
- Before - Перед вызовом метода
- After - После вызовом метода
- After returning - После возврата значения
- After throwing - В случае exception
- After finally - В случае выполения блока finally
- Around - можно сделать пред, пост обработку перед вызовом метода, а также вообще обойти вызов метода

**Aspect**</br>
модуль, в котором собраны описанные Pointcut и Advice

### 5. Spring boot
В базе используется сервер Tomcat</br></br>

Без Spring Boot
- Импортировать необходимые Spring-модули
- Импортировать библиотеку web-контейнеров (в случае web-приложения)
- Импортировать сторонние библиотеки (Hibernate, Jackson)
- Искать версии, совместимые со Spring
- Конфигурировать компонент DAO, такие как источник данных, управление транзакциями ит т.д.
- Конфигурировать компоненты web-слоя, такие как диспетчер ресурсов, view resolver
- Определить класс, который щагрузит все необходимые конфигурации</br></br>

  Основные особенности
    1. Управленияе зависимостями
    2. Автоматическая конфигурация
    3. Встроенные контейнеры сервлетов
    4. Создание архива, который можно запускать

- Spring упаковывает необходимые сторонние зависимости для каждого типа приложения посредством starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa)
- Spring автоматически конфигурирует зарегистрированные бины в зависимости от подключенного стартера
- Каждое Spring-boot приложение включает встроенные web-сервлеты
  Spring ам настроивает контейнер сервлетов.
  Приложение может запускаться как jar-файл</br></br>

Основной класс приложения

**@SpringBootApplication** - включает в себя
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan

### 6. Как активировать/деактивировать Бин
@Profile("dev")</br>
@Profile("production")</br></br>

Добавляет возможность включать/выключать бины для разных окружений</br></br>

В файлу 'application.properties'</br>
spring.profiles.active=dev</br></br>

Дополнительно в интерфейсе 'ConfigurableEnvironment' можно установить настройки активных профилей вызвав 'SpringApplication.setAdditionalProdiles(...)'

NOTE: `@Profile` не может быть применен на свойство

### 7. Spring Filters

Для создания фильтры необходимо создать бин и заинжектить интерфейс 'Filter'
```
@Component
@Order(1)
public class TransactionFilter implements Filter {
    @Override
    public void doFilter (
        ServlerRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOExeprion, ServlerException {
        HTTPServlerRequest req = (HTTPServlerRequest) request;
        
        LOG.info("Staring a transaction for req: {}");
        
        req.getRequestURI();
        
        chain.doFilter(request, response);
        
        LOG.info("Commiting a transaction for req: {}");
        
        req.fetRequestURI();
    }
}
```
Мы можем извлечь

`url = req.getRequestURI();`

`method = req.getMethod();`

`contentType = res.getContentType();`

Регистрация бина
```
@Bean
public FilterRegistrationBean<RequestResponseLoggingFilter> loggingFilter () {
FilterRegistrationBean<RequestResponseLoggingFilter> registrationBean = new FilterRegistrationBean<>();

    registrationBean.setFilter(new RequestResponseLoggingFilter());
    registrationBean.addUrlPattern("users");
    registrationBean.setOrder(2);

    return registrationBean;
}
```

### 8. @PreDestroy что это такое и зачем он нужен
Если мы указывем аннотацию @PreDestroy над методом, то этот метод будет вызван при закрытии контекста

### 9. Кто уничтожает бин со Scope prototype
Он уничтожается garbage collector после того как все ссылки на него будут уничтожены</br>
В некоторых случаях советую явно уничтожать подобные бины</br>
Для этго можно написать пост процессор, методы которого будут явно уничтожать компоненты прототипа

### 10. Аннотация `@Cachable`
https://habr.com/ru/companies/rosbank/articles/694768/ </br>
Если мы хотим закешировать методы, мы ставим данную аннотацию, которая создать мапу с закешированными значениями
```
@Cacheable(cacheNames = {"signature"},  key = "{#userId}")
public Set<SignatureLevel> getSignatureLevels(long userId) {
      //логика
}
```

### 11. Аннотация `@Async`
Позволяет запускать методы в фоновом потоке </br>
- Для активации необходимо добавить аннотацию `@EnableAsync` над основным классом приложения
```
@Configuration
@EnableAsync
public class AsyncConfiguration extends AsyncConfigurerSupport {
//…. 
}
```
- Аннотация применяется только на публичных методах
- Нельзя вызывать метод из того же класса, к которому он принадлежит
- Если метод должен что-то возвращать, то возвращаемый тип должен быть `CompletableFuture`

### 12. Типы Repository
- `CrudRepository` - базовый интерфейс репозитория. Предоставляет методы для создания, чтения, обновления и удаление объектов
- `PagingAndSortingRepository` - Расширяет `CrudRepository` и добавляет методы для поддержки постраничного и сортированного доступа к данным
- `JpaRepository` - предоставляет дополнительную функциональность для работы с сущностями JPA(Java Persistence API)</br>
  Включает методы для поиска объектов по клитериям, обновления группы объектов и более удобного использования отношений между сущностями
- `JpaSpecificationExecutor` - добавляет возможность выполнять запросы с использовнием спецификаций. Дает возможность создать критерии поиска с использованием логических операторов
- `ReactiveCrudRepository` - Предоставляет асинхронную поддержку для чтения, записи и удаления оьбъектов

### 13. Модули spring Session 
Сессия спринга состоит из следующих модулей
- Spring Session core - Предоставляет основные API и функции для работы
- Spring Session Data Redis - предоставляет `SessionRepository` и `ReactiveSessionRepository` для Redis
- Spring Session JDBC - предоставляет реализации для реалиционных бд
- Spring Session Hazelcast - предоставляет реализации для Hazelcast
- Spring Session MongoDB - предоставляет реализации для MongoDB

### 14. Какой аннотацией включается сессия
`@EnableJdbcHttpSession`

### 15. Пример своего `WebSecurityConfig`
```
@EnableWebSecurity
@EnableJdbcHttpSession
@RequiredArgsConstructor
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    private final UserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationFailureHandler securityErrorHandler;
    private final ConcurrentSessionStrategy concurrentSessionStrategy;
    private final SessionRegistry sessionRegistry;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .cors().and()
                //для защиты о csrf атак
                .csrf().and()
                .httpBasic().and()
                .authorizeRequests()
                .anyRequest()
                .authenticated().and()
                //Логаут
                .logout()
                .logoutRequestMatcher(new AntPathRequestMatcher("/api/logout"))
                //Возвращаем при логауте 200(по умолчанию возвращается 203)
                .logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler(HttpStatus.OK))
                //Инвалидируем сессию при логауте
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                //Удаляем всю информацию с фронта при логауте(т.е. чистим куки, хидеры и т.д.)
                .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(Directive.ALL)))
                .permitAll().and()
                //Включаем менеджер сессий(для контроля количества сессий)
                .sessionManagement()
                //Указываем макимальное возможное количество сессий(тут указано не 1, т.к. мы будем пользоваться своей кастомной стратегией)
                .maximumSessions(3)
                //При превышение количества активных сессий(3) выбрасывается исключение  SessionAuthenticationException
                .maxSessionsPreventsLogin(true)
                //Указываем как будут регестрироваться наши сессии(тогда во всем приложение будем использовать именно этот бин)
                .sessionRegistry(sessionRegistry).and()
                //Добавляем нашу кастомную стратегию для проверки кличества сессий
                .sessionAuthenticationStrategy(concurrentSessionStrategy)
                //Добавляем перехватчик для исключений
                .sessionAuthenticationFailureHandler(securityErrorHandler);
    }

    //для инвалидации сессий при логауте
    @Bean
    public static ServletListenerRegistrationBean httpSessionEventPublisher() {
        return new ServletListenerRegistrationBean(new HttpSessionEventPublisher());
    }

    @Bean
    public static SessionRegistry sessionRegistry(JdbcIndexedSessionRepository sessionRepository) {
        return new SpringSessionBackedSessionRegistry(sessionRepository);
    }

    @Bean
    public static PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

}
```

### 16. Как заинджектить несколько бинов по одному интерфейсу
1. Создать несколько бинов имплементирующий один интерфейс
2. Заинджектить бин по интерфейсу
```
@Autowired
private List<Test> testList;
```

### 17. @Primary
- Используется в случае если мы хотим использовать бин, который был унаследован от ранее созданного бина
```
@Component
public class ParentBean {
  // properties and methods
}

@Component
@Primary
public class ChildBean extends ParentBean {
  // overridden properties and methods
}
```

### 18. @Qualifier
- Используется для конкретизации какую конкретно реализацию интерфейса следует использовать

### 19. Можно ли заинджекстить Singleton в Prototype
Singleton не может инжектироваться в Prototype напрямую из-за того, что Singleton обычно создается один раз при инициализации контекста приложения и всегда возвращается один и тот же экземпляр

Существует способ обойти это ограничение
```java
@Component
public class SingletonBean {

    private final Provider<PrototypeBean> prototypeBeanProvider;

    @Autowired
    public SingletonBean(Provider<PrototypeBean> prototypeBeanProvider) {
        this.prototypeBeanProvider = prototypeBeanProvider;
    }

    public void doSomethingWithPrototypeBean() {
        PrototypeBean prototypeBean = prototypeBeanProvider.get();
        // использование экземпляра прототипа
    }
}


@Component
@Scope("prototype")
public class PrototypeBean {
    // реализация прототипа
}
```

## END ----------------- Spring -----------------

## Spring Кеш

+ [1. Как активировать кеширование в Spring](#1-как-активировать-кеширование-в-spring)
+ [2. Как отметить данные, которые будут кешироваться](#2-как-отметить-данные-которые-будут-кешироваться)
+ [3. Как обновить данные в кеше?](#3-как-обновить-данные-в-кеше)
+ [4. Какую структуру по умолчанию Spring использует для кеша](#4-какую-структуру-по-умолчанию-spring-использует-для-кеша)

### 1. Как активировать кеширование в Spring
Для активации кеширование достаточно добавить аннотацию `@EnableCaching`
```
@SpringBootApplication
@EnableCaching
public class DemoCacheAbleApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoCacheAbleApplication.class, args);
	}
}
```

### 2. Как отметить данные, которые будут кешироваться
Добавить аннотацию `@Cacheable`
```
@Cacheable(cacheNames="person")
public Person findCacheByName(String name) {
  //...
}
```
```
@Component
public class PersonRepository {

    private static final Logger logger = LoggerFactory.getLogger(PersonRepository.class);
    private List<Person> persons  = new ArrayList<>();

    public void initPersons(List<Person> persons) {
       this.persons.addAll(persons);
    }

    private Person findByName(String name) {
        Person person = persons.stream()
                .filter(p -> p.getName().equals(name))
                .findFirst()
                .orElse(null);
        return person;
    }

    @Cacheable(cacheNames="person")
    public Person findCacheByName(String name) {
        logger.info("find person ... " + name);
        final Person person = findByName(name);
        return person;
    }
}
```
Можно обозначить `key` - имя параметра, какой использовать в качестве ключа
```
@Cacheable(cacheNames="person", key="#name")
public Person findByKeyField(String name, Integer age) {
```

### 3. Как обновить данные в кеше?
1. Использовать аннотацию `@CachePut`</br>
Фунция с этой аннотацией будет всегда вызываться код, а результат помещать в кеш
```
@CachePut(cacheNames="person")
public Person findByNameAndPut(String name) {
    logger.info("findByName and put person ... " + name);
    final Person person = findByName(name);
    logger.info("put in cache person " + person);
    return person;
}
```

2. Использовать аннотацию `@CacheEvict`</br>
Позволяет не просто посещать хранилище кеша, но и выселять. Полезно для удаления устаревших и неиспользуемых данных из кеша</br>
```
@SpringBootApplication
@EnableCaching
public class DemoCacheAbleApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoCacheAbleApplication.class, args);
	}

	@Bean
	public CacheManager cacheManager() {
		SimpleCacheManager cacheManager = new SimpleCacheManager();
		cacheManager.setCaches(Arrays.asList(
				new ConcurrentMapCache("person"),
				new ConcurrentMapCache("addresses")));
		return cacheManager;
	}
}
```

### 4. Какую структуру по умолчанию Spring использует для кеша
ConcurrentMapCache

## END ----------------- Spring Кеш -----------------

## Spring Transactional

+ [1. Как включить транзакции](#1-как-включить-транзакции)
+ [2. Какие настройки может иметь аннотация `@EnableTransactionManager`](#2-какие-настройки-может-иметь-аннотация-enabletransactionmanager)
+ [3. Что делает аннотация `@Transactional`](#3-что-делает-аннотация-transactional)
+ [4. Какие настройки есть у `@Transactional`](#4-какие-настройки-есть-у-transactional)
+ [5. Как создавать транзакцию без Spring](#5-как-создавать-транзакцию-без-spring)
+ [6. Как `TransactionInterceptor` обрабатывает транзакционный метод](#6-как-transactioninterceptor-обрабатывает-транзакционный-метод)
+ [7. Что такое `TransactionManager`](#7-что-такое-transactionmanager)
+ [8. Как реализовать оптимистическую блокировку](#8-как-реализовать-оптимистическую-блокировку)

### 1. Как включить транзакции
Добавить над конфигурацией аннотацию `@EnableTransactionManager`

### 2. Какие настройки может иметь аннотация `@EnableTransactionManager`
- `proxyTargetClass` - (по умолчанию false) - будет ли прокси создаваться через CGLIB(true) или через interface-based proxies (false)
- `mode` - (по умолчанию `AdviceMode.PROXY`)  -как будут применены ADVICE
  - `AdviceMode.PROXY` или
  - `AdviceMode.ASPECTJ` - если выбрать и настроить, то при компиляции будет сгенерирован код так, что лело метода будет уже обернуто кодом, управляющим транзакцией
- `order` - (по умолчанию `LOWEST_PRECEDENCE`) когда будет применен advice, по умолчанию последним в цепочке

### 3. Что делает аннотация `@Transactional`
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(TransactionManagementConfigurationSelector.class)
public @interface EnableTransactionManagement {...}
```

### 4. Какие настройки есть у `@Transactional`
- `propagation` - способ распространения транзакций
  - `MANDATORY` - если есть текущая активная транзакция, выполняется в ней, иначе выбрасывается исключение
  - `NESTED` - выполняется внутри вложенной транзакции, если есть активная, если нет - то аналогично `REQUIRED`
  - `NEVER` - выполняется вне транзакции, если есть активная - выбрасывается исключение
  - `NOT_SUPPORTED` - выполняется вне транзакции - если есть активная, она приостанавливается
  - `REQUIRED` - (по умолчанию) если есть активная, то выполняется в ней, если нет, то создается новая
  - `REQUIRES_NEW` - всегда создается новая транзакция, если есть активная - то она приостанавливается
  - `SUPPORTS` - если есть активная, то выполняется в ней, есои нет - то выполняется не транзакционно
- Правила управления откатом
  - `noRollbackFor` `noRollbackForClassName` - определяет исключения при которых транзакция НЕ будет откатана
  - `rollbackFor` `rollbackForClassName` - определяет исключения при которых транзакция БУДЕТ откатана

### 5. Как создавать транзакцию без Spring
1. Создаем соединение  - DriverManager.getConnection(...)
2. Выполняем запросы
3. Если нет ошибок, то выполняется commit
4. Если были ошибки - изменения откатываются 
```
Connection connection = DriverManager.getConnection(...);
try {
  connection.setAutoCommit(false);
  PreparedStatement firstStatement = connection.prepareStatement(...);

  firstStatement.executeUpdate();

  PreparedStatement secondStatement = connection.prepareStatement(...);

  secondStatement.executeUpdate();
  connection.commit();
} catch (Exception e) {
  connection.rollback();
}
```

### 6. Как `TransactionInterceptor` обрабатывает транзакционный метод
1. Получаем соединение/транзакцию - createTransactionIfNecessary
2. Выполняем необходимые запросы - invocation.proceedWithInvocation
3. Если не было ошибок - выполяем commitTransactionAfterReturning
4. Если были ошибки - откатываем изменения completeTransactionAfterThrowing
```
protected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)

  // получаем TransactionManager tm и TransactionAttribute txAttr
  // ...

  if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager) {
    //код для работы с реактивным стэком
    // ...
  }

PlatformTransactionManager ptm = asPlatformTransactionManager(tm);
final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) {
  // начинаем транзакцию, если нужно
  TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);

  Object retVal;
  try {
    // выполняем работу внутри транзакции
    retVal = invocation.proceedWithInvocation();
  } catch (Throwable ex) {
    // откатываемся, если нужно
    completeTransactionAfterThrowing(txInfo, ex);
    throw ex;
  } finally {
    // чистим ThreadLocal переменные
    cleanupTransactionInfo(txInfo);
  }

  if (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {
    //код для библиотеки vavr
    // ...
  }

  // выполняем commit, если не было ошибок
  commitTransactionAfterReturning(txInfo);
  return retVal;
} else {
  // код для WebSphere
  // ...
}
}
```

### 7. Что такое `TransactionManager`
- Это маркировачный интерфейс, не содержащий никаких методов
    - Его наследуют `ReactiveTransactionManager` и `PlatformTransactionManager`

### 8. Как реализовать оптимистическую блокировку
Использовать аннотацию @Version над полем
```java
import javax.persistence.*;

@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private double price;

    @Version
    private Long version; // The @Version field for optimistic locking

    // getters and setters
}
```
Для сравнения будет использоваться поле version после выполнения всех манипуляций. Если версия не будет совпадать, то транзакция будет откачена 

## END ----------------- Spring Transactional -----------------

## Hibernate & JPA

+ [1. Что такое Hibernate](#1-что-такое-hibernate)
+ [2. Проблема n+1 в Hibernate](#2-проблема-n1-в-hibernate)
+ [3. Как решить проблему n+1](#3-как-решить-проблему-n1)
+ [4. Плюсы и минусы](#4-плюсы-и-минусы)
+ [5. Hibernate ленивая инициализация (LazyInitialization)](#5-hibernate-ленивая-инициализация-lazyinitialization)
+ [6. Как реализовать пользовательский интерфейс repository](#6-как-реализовать-пользовательский-базовый-repository)
+ [7. Как добавить пользовательскую реализацию репозитория](#7-как-добавить-пользовательскую-реализацию-репозитория)
+ [8. Изменить поведение уже существующего метода](#8-изменить-поведение-уже-существующего-метода)
+ [9. Как использовать `Query` в запросах](#9-как-использовать-query-в-запросах)
+ [10. Что представляет собой EntityManager](#10-что-представляет-собой-entitymanager)
+ [11. В чем отличие merge от persist](#11-в-чем-отличие-merge-от-persist)
+ [12. Что такое Persistence Context](#12-что-такое-persistence-context)
+ [13. Как реализовать оптимистическую блокировку](#13-как-реализовать-оптимистическую-блокировку)
+ [14. Как реализовать пессимистическую блокировку](#14-как-реализовать-пессимистическую-блокировку)
+ [15. В чем преимущество испльзования JPQL синтаксиса](#14-как-реализовать-пессимистическую-блокировку)
+ [16. Уровни кешей](#16-уровни-кешей)
+ [17. Реализация составного ключа](#17-реализация-составного-ключа)
+ [18. Есть ли JPA для mongoDB](#18-есть-ли-jpa-для-mongodb)
+ [19. Аннотация EntityGraph](#19-аннотация-entitygraph)

### 1. Что такое Hibernate
ORM - Object-relational mapping - это отображение объектов какого-либо объектно-ориентированного языка в структуры реляционных баз данных

Hibernate - заботится о связи Java классов с таблицами бд, а также предоставляет средства для автоматического построения запросов и извлечения данных

Внутри используется собственный язык запросов Query Language или HQL

### 2. Проблема n+1 в Hibernate
-Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.</br>
-При использовании `FetchType.EAGER` все данные не будут загружены в одном запросе, а бадут загружаться отдельными запросами на каждую сущность
```
SELECT
    pc.id AS id1_1_,
    pc.post_id AS post_id3_1_,
    pc.review AS review2_1_
FROM
    post_comment pc
 
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 1
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 2
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 3
SELECT p.id AS id1_0_0_, p.title AS title2_0_0_ FROM post p WHERE p.id = 4
```
- При работе с кешом второго уровня
```
List<PostComment> comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    order by pc.post.id desc
    """, PostComment.class)
.setMaxResults(10)
.setHint(QueryHints.HINT_CACHEABLE, true)
.getResultList();
```
Если PostComment не находится в кэше второго уровня, то будет выполнено N запросов для получения каждого отдельного PostComment:
```
SELECT pc.id AS id1_1_0_,
       pc.post_id AS post_id3_1_0_,
       pc.review AS review2_1_0_
FROM post_comment pc
WHERE pc.id = 3
  
SELECT pc.id AS id1_1_0_,
       pc.post_id AS post_id3_1_0_,
       pc.review AS review2_1_0_
FROM post_comment pc
WHERE pc.id = 2
  
SELECT pc.id AS id1_1_0_,
       pc.post_id AS post_id3_1_0_,
       pc.review AS review2_1_0_
FROM post_comment pc
WHERE pc.id = 1
```

### 3. Как решить проблему n+1
1. Использовать `FetchType.LAZY` - по сути откладывает проблему до момента обращения к lazy
2. Использовать `JOIN FETCH`
```
List<PostComment> comments = entityManager.createQuery("""
    select pc
    from PostComment pc
    join fetch pc.post p
    """, PostComment.class)
.getResultList();
 
for(PostComment comment : comments) {
    LOGGER.info(
        "The Post '{}' got this review '{}'",
        comment.getPost().getTitle(),
        comment.getReview()
    );
}
```
```
SELECT
    pc.id as id1_1_0_,
    pc.post_id as post_id3_1_0_,
    pc.review as review2_1_0_,
    p.id as id1_0_1_,
    p.title as title2_0_1_
FROM
    post_comment pc
INNER JOIN
    post p ON pc.post_id = p.id
     
-- The Post 'High-Performance Java Persistence - Part 1' got this review
-- 'Excellent book to understand Java Persistence'
 
-- The Post 'High-Performance Java Persistence - Part 2' got this review
-- 'Must-read for Java developers'
 
-- The Post 'High-Performance Java Persistence - Part 3' got this review
-- 'Five Stars'
 
-- The Post 'High-Performance Java Persistence - Part 4' got this review
-- 'A great reference book'
```

### 4. Плюсы и минусы
(+)
1. Превращает sql запросы в объекты java 
2. Маппит результат sql запроса в класс

(-)
1. Не подходит при работе с большим количеством данных, так как на каждую сущность создает объект
2. Есть проблемы n+1

### 5. Hibernate ленивая инициализация (LazyInitialization)
@OneToMany(fetch=FetchType.Lazy)

Для акцивации такой связи необходимо проверить било ли инициализировано</br>
boolean success = Hibernate.isInitialized(products);</br></br>

Инициализировать</br>
Hibernate.initialize(post);

### 6. Как реализовать пользовательский базовый repository
- Создать свой интерфейс, который будет экстендиться от CrudRepo
```
@NoRepositoryBean
public interface BaseRepository <T extends BaseEntity, ID extends Serializable>
        extends JpaRepository<T, ID> {

    void delete(T entity);
}
```
- Реализовать интерфейс
```
//Базовый пользовательский класс имплементирующий BaseRepository
public class BaseRepositoryImpl <T extends BaseEntity, ID extends Serializable>
        extends SimpleJpaRepository<T, ID>
        implements BaseRepository<T, ID> {

    private final EntityManager entityManager;

    public BaseRepositoryImpl(JpaEntityInformation<T, ?> entityInformation,
                     EntityManager entityManager) {
        super(entityInformation, entityManager);
        this.entityManager = entityManager;
    }

    @Transactional
    @Override
    public void delete(BaseEntity entity) {
        entity.setDeleted(true);
        entityManager.persist(entity);
    }
}
```

### 7. Как добавить пользовательскую реализацию репозитория
- Объявляем интерфейс
```
public interface CustomizedEmployees<T> {

    List<T> getEmployeesMaxSalary();

}
```
- Имплементируем интерфейс
```
public class CustomizedEmployeesImpl implements CustomizedEmployees {

    @PersistenceContext
    private EntityManager em;

    @Override
    public List getEmployeesMaxSalary() {
        return em.createQuery("from Employees where salary = (select max(salary) from Employees )", Employees.class)
                .getResultList();
    }
}
```
- Расширяем репозиторий
```
@Repository
public interface CustomizedEmployeesCrudRepository extends CrudRepository<Employees, Long>, CustomizedEmployees<Employees> 
```

### 8. Изменить поведение уже существующего метода
```
public interface CustomizedEmployees<T> {

    void delete(T entity);
    // ...
}
// Имплементация CustomizedEmployees
public class CustomizedEmployeesImpl implements CustomizedEmployees {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    @Override
    public void delete(Object entity) {
        Employees employees = (Employees) entity;
        employees.setDeleted(true);
        em.persist(employees);
    }
}
```

### 9. Как использовать `Query` в запросах
- Используется если нужен специфичный метод или его реализация, которую нельзя описать через имя метода
```
@Repository
public interface CustomizedEmployeesCrudRepository extends CrudRepository<Employees, Long>, CustomizedEmployees<Employees> {

    @Query("select e from Employees e where e.salary > :salary")
    List<Employees> findEmployeesWithMoreThanSalary(@Param("salary") Long salary, Sort sort);
    // ...
}
```
** Если запросы должны лишь модифицируеющие, то можно использовать аннотацию `@Modifying`
```
@Modifying
@Query("update Employees e set e.firstName = ?1 where e.employeeId = ?2")
int setFirstnameFor(String firstName, String employeeId);
```

Пример: Получить список объектов с признаком "удален" или "активный"
```
@NoRepositoryBean
public interface ParentEntityRepository<T> extends Repository<T, Long> {

    @Query("select t from #{#entityName} t where t.deleted = ?1")
    List<T> findMarked(Boolean deleted);
}
```

### 10. Что представляет собой EntityManager
- Это интерфейс из Java Persistence API (JPA)
- Является основным объектом для работы с объектами сущностей в контексте управления сущностями
- Представляет собой набор методов для выполнения операций с сущностями, такими как создание, чтение, обновление и удаление
- Позволяет управлять жизненным циклом сущностей, отслеживать изменения и сохранять их в базе данных

### 11. В чем отличие merge от persist
- persist - используется для сохранения нового объекта в бд
Если объект уже есть в бд, то будет сгенерировано исключение</br>
Устанавливает идентификатор объекта после сохранени в бд</br>
Не возвращает измененное состояние объекта, после сохранения в бд</br>
Требует, чтобы объект находился в текущем сеансе
- merge - используется для обновления существующего объекта в бд
Если объект уже есть в бд, то его значения будут обновлены, иначе объект будет сохранен как новый</br>
Если объект уже существует, но не связан с текущим сеансом Hibernate, то его состояние будет сгенерировано в объект, связанный с текущим сеансом</br>
Возвращает копию объекта с обновленным состоянием

### 12. Что такое Persistence Context
Это механизм, который отслеживает состояние объектов, связанных с бд</br>
Предоставляет управление и кеширование объектов, в также обеспечивает обнаружение изменений и синхронизацию с бд

- Каждая сессия имеет свой собственный контекст сохранения, который представляет собой некоторое хранилище для объектов
- Когда вы загружаете или сохраняете объекты, Hibernate помещает их в контекст сохранения

Преимущества:</br>
- Обеспечивает кеширование объектов
- Отслеживает изменения в объектах и автоматически сихронизириует их с бд при необходимости
- Обеспечивает согласованность данных между объектами и бд, обеспечивая целостность данных в рамках транзакций
- Позволяет использовать отложенную загрузку (lazy loading)

### 13. Как реализовать оптимистическую блокировку
1. Использовать `@Version`
- Версия мапится в колонку OPTLOCK
- менеджер сущностей использует ее для выявления конфликтующих обновлений и предотвращения потери обновлений
```
@Entity
public class Flight implements Serializable {
...
@Version
@Column(name="OPTLOCK")
public Integer getVersion() { ... }
}
```
- Возможные параметры

| Имя                                    | Описание                                                                                               |
|----------------------------------------|--------------------------------------------------------------------------------------------------------|
| column<version_column>                 | Имя колонки, в которой находится номер версии (опционально)                                            |
| name<propertyName>                     | Имя свойства персистентного класса                                                                     |
| type<typename>                         | Тип номера версии (опционально - default: integer)                                                     |
| access<field/property/ClassName>       | Стратегия Hibernate для доступа к значению свойства (опционально - default: property)                  |
| unsaved-value<null/negative/undefined> | Показывает, что экземпляр только что создан и тем самым не сохранен (опционально - default: undefined) |
| generated<never/always>                | Показывает, что свойство версии должно генерироваться базой данных (опционально - default: never)      |
| insert                                 | Включать или нет колонку версии в выражение SQL-insert (опционально - default: true)                   |

Версия в hbm.xml
```
<version
        column="version_column"
        name="propertyName"
        type="typename"
        access="field|property|ClassName"
        unsaved-value="null|negative|undefined"
        generated="never|always"
        insert="true|false"
        node="element-name|@attribute-name|element/@attribute|."
        />
```
2. Использовать `@Timestamp`
```
@Entity
public class Flight implements Serializable {
...
@Version
public Date getLastUpdate() { ... }
}
```
- Возможные параметры

| Имя                                    | Описание                                                                                                                    |
|----------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| column<version_column>                 | Имя колонки, в которой находится номер версии (опционально)                                                                 |
| name<propertyName>                     | Имя JavaBeans-свойства типа Date или Timestamp у персистентного свойства                                                    |
| access<field/property/ClassName>       | Стратегия Hibernate для доступа к значению свойства (опционально - default: property)                                       |
| unsaved-value<null/negative/undefined> | Показывает, что экземпляр только что создан и тем самым не сохранен (опционально - default: undefined)                      |
| generated<never/always>                | Показывает, что свойство версии должно генерироваться базой данных (опционально - default: never)                           |
| source                                 | Извлекает ли Hibernate метку из БД или из текущей JVM. Метку нужно запрашивать из БД каждый раз для определения инкремента  |

Timestamp в hbm.xml
```
<timestamp
        column="timestamp_column"
        name="propertyName"
        access="field|property|ClassName"
        unsaved-value="null|undefined"
        source="vm|db"
        generated="never|always"
        node="element-name|@attribute-name|element/@attribute|."
        />
```

### 14. Как реализовать пессимистическую блокировку
- Класс `LockMode` для определения уровня блокировки
  - `LockMode.WRITE` - захватываются автоматичсеки, когда Hibernate обновляет или вставляет строку
  - `LockMode.UPGRADE` - захватывается после явного запроса пользователя с использованием `SELECT...FOR UPDATE`
  - `LockMode.UPGRADE_NOWAIT` - захватывается после явного запроса пользователя с испоьзованием `SELECT… FOR UPDATE NOWAIT` (oracle)
  - `LockMode.READ` - захватывается автоматически когда Hibernate читает данные под уровнями изоляции Repeatable Read или Serializable
  - `LockMode.NONE` - Все объекты переключается на этот режим в конце транзакции

### 15. В чем преимущество испльзования JPQL синтаксиса
- Запросы кешируются
- Универсальны при изменение драйвера базы данных (созданный запрос не нужно переписывать)

### 16. Уровни кешей
- Кеш первого уровня (First-level cache); (по умолчанию)
- Кеш второго уровня (Second-level cache);
- Кеш запросов (Query cache);

1. Кеш первого уровня привязан к объекту сессии. Он хранит объекты, полученные из бд в рамках текущей сесии.
2. Кеш второго уровня привязан к объекту-фабрике сессий. Общий кеш, который может использоваться между несколькими сессиями. 
3. Кеш запросов привязан к параметрам запроса. Специальный кеш, который хранит результаты выполнения запросов к бд.

### 17. Реализация составного ключа
```java
@Entity
@org.hibernate.annotations.Table(appliesTo = House.TABLE_NAME,
    indexes = {
            @Index(name = "IDX_XDN_DFN",
                    columnNames = {House.XDN, House.DFN}
            )
    }
)
@Table(name="house")
public class House {
    ...

  @Index(name = "index1")
  public String getFoo();
  @Index(name = "index1")
  public String getBar();
}
```

### 18. Есть ли JPA для mongoDB
нет, JPA  не поддерживает mongoDB напрямую.

Существует несколько альтернативных решщений для работы с mongoDB
- Spring Data MongoDB
- Morphia
- Java MongoDB Driver


### 19. Аннотация EntityGraph
`@EntityGraph` - улучшает производительность загрузки связанных сущностей.
`@EntityGraph(attributePaths = {"comments"})` - граф будет включать в себя загрузку всех базовых полей пользователя, который создал пост, а также комментарии и их авторов
```sql
select
        p1_0.id,
        c1_0.post_id,
        c1_0.id,
        c1_0.reply,
        c1_0.user_id,
        p1_0.subject,
        p1_0.user_id 
    from
        post p1_0 
    left join
        comment c1_0 
            on p1_0.id=c1_0.post_id 
    where
        p1_0.subject=?
```

У самого `EntityGraph` есть 2 вида загрузки:
- `EntityGraph.EntityGraphType.FETCH` - используется по умолчанию. Ассоциативные атрибуты, явно объявленные для загрузки, будут выгружены жадно `FetchType.EAGER`, остальные будут загружены лениво `FetchType.LAZY`
- `EntityGraph.EntityGraphType.LOAD` - Выбранные атрибуты будут загружены жадно, а остальные атрибуты будут загружены в соотвествии с тем, какой FetchType указан в модели

```
@EntityGraph(attributePaths = {"comments"}, type = EntityGraph.EntityGraphType.LOAD)
List<Post> findEntityGraphTypeLoadBySubject(String subject);
```

## END ----------------- Hibernate & JPA -----------------

## Kafka

+ [1. Основной принцип работы kafka](#1-основной-принцип-работы-kafka)
+ [2. Если у нас есть несколько инстансов одного микросервиса сообщений, как отправить только одно сообщение](#2-если-у-нас-есть-несколько-инстансов-одного-микросервиса-сообщений-как-отправить-только-одно-сообщение)
+ [3. Максимальный объем сообщения](#3-максимальный-объем-сообщения)
+ [4. Какие гарантии Kafka дает](#4-какие-гарантии-kafka-дает)
+ [5. Подходит ли Kafka для пересылки больших сообщений](#5-подходит-ли-kafka-для-пересылки-больших-сообщений)
+ [6. Что произойдет если Kafka отправит большое сообщение (Poison Message)](#6-что-произойдет-если-kafka-отправит-большое-сообщение-poison-message)
+ [7. Что означает Идемпотентность](#7-что-означает-идемпотентность)
+ [8. Как настроить отправку только одного сообщения (exactly one)](#8-как-настроить-отправку-только-одного-сообщения-exactly-one-)
+ [9. Из чего состоит](#9-из-чего-состоит)
+ [10. Жизненный цикл сообщений](#10-жизненный-цикл-сообщений)
+ [11. Как долго kafka хранит сообщения](#11-как-долго-kafka-хранит-сообщения)
+ [12. Какая структура сообещения Kafka](#12-какая-структура-сообещения-kafka)
+ [13. Как организованы и как хранятся сообщения](#13-как-организованы-и-как-хранятся-сообщения)
+ [14. Как организованы Партиции](#14-как-организованы-партиции)
+ [15. Что такое consumer group](#15-что-такое-consumer-group)
+ [16. Каким образом обозначить сообщения в партиции, как обработанные](#16-каким-образом-обозначить-сообщения-в-партиции-как-обработанные)

### 1. Основной принцип работы kafka
- Kafka использует pull (получатели сами достают из топика сообщения)</br>
  (+)
    - сами отправляют запрос раз в n секунд на сервер для получения новой порции сообщений</br>
    - Позволяет группировать сообщения в батчи, таким образом достигая лучшей пропускной способности
  
  (-)
    - Потенциальная разбалансированность нагрузки между разными консьюмерами, а также более высокую задержку обработки данных
  
- Другие сервисы используют push ратегию (отправляют сообщения получателям)
  - сервер делает запрос к клиенту, посылая ему новую порцию данных
  - Позволяет эффективно балансировать распределение сообщений по консьюмерам

### 2. Если у нас есть несколько инстансов одного микросервиса сообщений, как отправить только одно сообщение
- consumer group концепция
- Назначить consumer group id для инстансов, после чего кафка сама позаботится о разделении сообщения для разных инстансов
- Необходимо чтобы все инстансы одного микросервиса имели один и тот же group id

### 3. Максимальный объем сообщения
10 мб

### 4. Какие гарантии Kafka дает
Что сообщение будет доставлено как минимум одному получателю

### 5. Подходит ли Kafka для пересылки больших сообщений
Нет, Kafka заточена под пересылку большого количества сообщений небольшого размера</br>
Если необходимо отправить большой файл, то нужно его сохранить в какое-то хранилище и в сообщении передать ссылку на него

### 6. Что произойдет если Kafka отправит большое сообщение (Poison Message)
У получателя произойдет ошибка, которую скорее всего он не обрабатывает. Эта ошибка повлияет на последющие сообщения</br>
Для избежания таких ситуаций можно добавить кастомную обработку при получении сообщений

### 7. Что означает Идемпотентность
https://habr.com/ru/companies/badoo/articles/333046/ </br>
свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом (чистые функции)

### 8. Как настроить отправку только одного сообщения (exactly one)
```
enable.idempotence=true
```
Каждый пакет, отправленный Kafka, будет содержать порядковый номер, при помощи которого блокер сможет устранить дублирование данных

### 9. Из чего состоит
1. Сервер
2. Продюсеры, которые отправляют сообщения в некую именованную очередь, заранее сконфигурированную администратором на сервере
3. Консьюмеры, который считывают те же самые сообщения по мере их появления

### 10. Жизненный цикл сообщений
1. Продюсер отправляет сообщение на сервер
2. Консьюмер фетчит сообщение и его уникальный идентификатор сервера
3. Сервер помечает сообщение как in-flight. Сообщения в таком состоянии все еще хранятся на сервере, но временно не доставляются другим консьюмерам.</br>
Таймаут этого состояния контролируется специальной настройкой
4. Консьюмер обрабатывает сообщение, следуя бизнес-логике. Затем отправляет ack или nack-запрос обратно на сервер, используя уникальный идентификатор,</br>
полученный ранее - тем самым либо подтверждая успешную обработку сообщения, либо сигнализируя об ошибке
5. В случае успеха сообщение удаляется с сервера навсегда. В случае ошибки или таймаута состояния in-flight сообщение доставляется консьюмеру для повторной обработки

### 11. Как долго kafka хранит сообщения
- Сообщения в Kafka не удаляется брокерами по мере их обработки комнсьюмерами - данные в Kafka могут храниться днями, неделями, годами
- Одно и то же сообщение может быть обработано сколько угодно раз разными консьюмерами и в разных контекстах

### 12. Какая структура сообещения Kafka
- Каждое сообщение состоит из ключа, значения, таймстампа и опционального набора метаданных (хедеров)
```
{
 key: "Alice",
 Value: "Registered on out website",
 Timestamp: "Jun 25, 2023",
 Headers: [{"X-Generated-By": "web"}]
}
```

### 13. Как организованы и как хранятся сообщения
- Сообщения организованы и хранятся в именованных топиках (Topic)
- Каждый топик состояит из одной более партиций (Partition), распределенных между брокерами внутри одного кластера
- Когда новое сообщение добавляется в топик, оно записывается в одну из партиций этого топика
- Сообщения с одинаковыми ключами всегда записываются в одну и ту же партицию, тем самым гарантируя очередность или порядок записи и чтения

### 14. Как организованы Партиции
- У каждой партиции есть "лидер" - брокер, который работает с клиентами. Лидер работает с продюсерами и в общем случае отдает сообщения консьюмерам
- К лидеру осуществляют запросы фолловеры - брокеры, которые хранят реплику всех данных партиций
- партиция - это распределенный, реплицируемый лог

### 15. Что такое consumer group
- Каждый консьюмер обычно является частью какой-нибудь консьюмер-группы
- Каждый группа имеет уникальное название и регистрируется брокерами в кластере Kafka
- Данные из одного и того же топика могут считываться множеством консьюмер-групп одновременно
- Когда несколько консьюмеров читают данные и являются членами одной и той же группы, то каждый из них получает сообещния из разных партиций топика

* Внутри одной группы партиции назначаются консьюмерами уникально, чтобы избежать повторной обработки
* Если консьюмер не справляется с текущим объемом данных, то следует добавить новую партицию в топик

### 16. Каким образом обозначить сообщения в партиции, как обработанные
- Для этого используется механизм консьюмеров-офсетов
- Каждое сообщение партиции имеет свой собственный, уникальный, монотонно возрастающий офсет
- Консьюмер делает запрос к брокеру (offset-commit) с указанием своей группы, идентификатора топик-партиции и офсета, который должен быть отмечен как обработанный
  - Сдвигается относительно consumer-group, чтобы сообщения обрабатывались последовательно
- Брокер сохраняет эту информацию в собственном топике
- При рестарте консьюмер запрашивает у сервера последний закомиченный офсет для нужной топик-партиции и продолжает чтения с этой позиции

## END ----------------- Kafka -----------------

## Stream

+ [1. Стримы Общее](#1-стримы-общее)
+ [2. Collectors](#2-collectors)
+ [3. Функциональный интерфейсы](#3-функциональный-интерфейсы)
+ [4. Меняет ли начальные данные stream?](#4-меняет-ли-начальные-данные-stream)
+ [5. Почему стримы, в чем основная фишка](#5-почему-стримы-в-чем-основная-фишка)
+ [6. Как можно обработать исключение, выброшенное в ходе работы Stream](#6-как-можно-обработать-исключение-выброшенное-в-ходе-работы-stream)

### 1. Стримы Общее
1. Stream из массива</br>
   Arrays.stream(array)</br></br>

2. Stream из ArrayList</br>
   list.stream()</br></br>

3. Stream из Map</br>
   map.entrySet.stream()</br></br>

4. Stream из указанных элементов</br>
   Stream.of("1", "2", "3")</br></br>

5. Лист из указанных элементов</br>
   Arrays.asList("a1", "a2", "a3").stream()</br></br>

6. Стрим из файла</br>
   Files.lines(Paths.get("file.txt"))</br></br>

7. Стрим из строки</br>
   "123".chars()</br></br>

8. Создание из Stream.builder</br>
   Stream.builder().add("a1").add("a2").add("a3").build()</br></br>

9. Создание параллельного стрима</br>
   collection.parallelStream()</br></br>

10. Создание бесконечного стрима</br>
    Stream.iterate(1, n -> n +1)</br></br>

11. Создание бесконечных стримов с помощью</br>
    Stream.generate(() -> "a1"))</br></br>

   Методы
   1. Конвейерные - возвращают другой stream, то есть работают как builder
   2. Терминальные - Возвращают другой объект, такой как коллекция, примитивы, объекты, Optional</br></br>

        ! У стрима может быть сколько угодно вызовов конвейерных методов  и в конце один терминальный</br>
        При этом все конвеейрные методы выполняются лениво и пока не будет вызван терминальный, никаких действий не происходит</br>

```
Конвейерные методы
   'filter'
   collection.stream()
    .filter("a1"::equals)
    .count()

    'skip' - позволяет пропускать первые N элементов
    collection.stream()
        .skip(collection.size() - 1)
        .findFirst()
        .orElse("1")

    'distinct' - возвращает стрим без дубликатов
    collection.stream()
        .distinct()
        .collect(Collectors.toList())

    'map' - преобразует каждый элемент массива
    collection.stream()
        .map((s) -> s + "_1")
        .collect(Collectors.toList())

    'peek' - возвращает тот же стрим, но применяет функцию к каждому элементу
    collection.stream()
        .map(String::toUpperCase)
        .peek((e) -> System.out.println("," + e))
        .collect(Collectors.toList())

    'limit' - ограничивает выборку определенным количеством элементов
    collection.stream()
        .limit(2)
        .collect(Collectors.toList())

    'sorted' - позволяет сортировать значения либо в натуральном порядке либо задавая Comparable
    collection.stream()
        .sorted()
        .collect(Collectors.toList())

    'mapToInt' - аналог map, но возвращает числовой стрим
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .toArray()

    'mapToDouble'
    'mapToLong'

    'flatMap' - похоже на map, о может создавать из одного элемента несколько
    'flatMapToInt'
    'flatMapToDouble'
    'flatMapToLong'

    collection.stream()
        .flatMap((p) -> Arrays.asList(p.split(",").stream()))
        .toArray(String[]::new)

```
```
Терминальные методы
    
    'reduce' - позволяет выполнять агрегатные функции на всей коллекцией, возвращает одно значение для стрима (Optional)
    collection.stream()
        .reduce((s1, s2) -> s1 + s2)
        .orElse(0)
    
    'findFirst' - возвращает первый элемент из стрима (Возвращает Optional)
    collection.stream()
        .findFirst()
        .orElse("1")

    'findAny' - возвращает плюбой подходящий элемент из стрима (Возвращает Optional)
    collection.stream()
        .findAny()
        .orElse("1")

    'collect' - представление результатов в виду коллекций и других структур данных
    collection.stream()
        .filter((s) -> s.contains("1"))
        .collect(Collectors.toList())

    'anyMatch' - возвращает true если условие выполняется хотя бы для одного значения
    collection.stream()
        .anyMatch("a1"::equals)

    'count' - возвращает количество элементов в стриме
    collection.stream()
        .filter((s) -> s.contains("1"))
        .count()

    'noneMatch' - возвращает true если условие не выполняется ни для одного элемента
    collection.stream()
        .noneMatch((s) -> s.contains("1"))

    'allMatch' - возвращает true если условие выполняется для всех элементов
    collection.stream()
        .allMatch((s) -> s.contains("1"))

    'min' - возвращает минимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .min(String::compareTo)
        .get()

    'max' - возвращает максимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .max(String::compareTo)
        .get()

    'forEach' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
    set.stream()
        .forEach((p) -> p.append("_1"))

    'forEachOrdered' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении гарантируется
    list.stream()
        .forEachOrdered((p) -> p.append("_1"))

    'toArray' - возвращает массив значений стрима
    collection.stream()
        .map(String::toUpperCase)
        .toArray(String[]::new)
```
```
Дополнительные методы числовых стримов

    'sum' - Возвращает сумму чисел
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .sum()

    'average' - Возвращает среднее арифметическое
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .average()

    'mapToObj' - Преобразует числовой стрим обратно в объект
    Stream.mapToObj((id) -> new Key(id))
        .toArray()
```
```
Другие методы
   'isParallerl' - Узнать является ли стрим параллельным

    'parallel' - Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
    
    collection.stream()
        .peek(...) // операция последовательная
        .parallel()
        .map(...) // операция мождет выполняться параллельно
        .sequential()
        .reduce(...) // операция снова последовательна
```

### 2. Collectors
   Методы стататические

   `toList` - Представляет стрим в виде списка
   `toCollection` - Представляет стрим в виде коллекции
   `toSet` - Представляет стрим в виде множества</br></br>

   `toConcurrentMap` - Преобразовывает стрим в Map
   `toMap` - Преобразовывает стрим в Map</br></br>

   `averagingInt` - Среднее значение
   `averagingDouble`
   `averagingLong`</br></br>

   `summingInt` - Возвращает сумму
   `summingDouble`
   `summingLong`</br></br>

   `partitioningBy` - разделяет коллекцию на две части по соответствующему условию</br>
   и возвращает как Map<Boolean, List></br></br>

   `groupingBy` - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>></br></br>

   `mapping` - дополнительные преобразования значений для сложных Collector-ов</br></br>

```
strings.stream()
    .collect(Collectors.joining(" "), "<b>", "</b>")

string.stream()
    .collect(Collectors.groupingBy((p) -> p.substring(0, 1)))
```

### 3. Функциональный интерфейсы

`Predicate`(filter) - означает, что он будет пропускать только те элементы, которые возвращают true
```
public static void main(String[] args) {
    List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
        .filter(x -> x % 2==0)
        .collect(Collectors.toList());
}
```

`Consumer`(peek, forEach)
```
public static void main(String[] args) {
    List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
        .peek(x -> System.out.println("Hello " + x + " !!!"))
        .collect(Collectors.toList());
}
```
`Supplier`(generate)
```
public static void main(String[] args) {
    ArrayList<String> nameList = new ArrayList<>();
    nameList.add("Elena");
    nameList.add("John");
    nameList.add("Alex");
    nameList.add("Jim");
    nameList.add("Sara");
    
    Stream.generate(() -> {
        int value = (int) (Math.random() * nameList.size());
        return nameList.get(value);
    }).limit(5).forEach(System.out::println);
}
```
`Function`(map)
```
public static void main(String[] args) {
    List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
}
```
`UnaryOperator`(iterate)

1. Элемент, с котрого начинается генерация
2. Указывает принцип генерации новых элементов
```
public static void main(String[] args) {
    Stream.iterate(9, x -> x * x)
        .limit(4)
        .forEach(System.out::println);
}
```

### 4. Меняет ли начальные данные stream?
   нет

### 5. Почему стримы, в чем основная фишка
При одиннаковых получаемых аргументах всегда возвращает один и тот же результат</br>
Являются потокобекзопасными, так как работают или с атомарными значениями или финализированными значениями </br>
Лучше всего подходит для манипуляции над одной структурой, без ее изменения

- Параллелизм - Stream способен автоматически распределять операции на несколько потоков
- Лаконичность
- Нестрокое выполнение - Stream не привязан к размеру исходных данных, что дает возможность его использования во время выполнения программы
- Изолированность - не изменяются исходные данные
- Тестирование

### 6. Как можно обработать исключение, выброшенное в ходе работы Stream
- С помощью блока try-catch
```
Runnable runnable = () -> {
  try {
    // код, который может сгенерировать исключение
  } catch (Exception e) {
    // обработка исключения
  }
};
```
- Обертывание лямбда-выражения в метод, который объявляет исключение:
```
@FunctionalInterface
interface MyRunnable {
  void run() throws Exception;
}

MyRunnable myRunnable = () -> {
  // код, который может сгенерировать исключение
};

try {
  myRunnable.run();
} catch (Exception e) {
  // обработка исключения
}
```
- Использование функционального интерфейса, который объявляет исключение:
```
@FunctionalInterface
interface MyFunction<T, R> {
  R apply(T t) throws Exception;
}

MyFunction<String, Integer> myFunction = (s) -> {
  // код, который может сгенерировать исключение
  return Integer.parseInt(s);
};

try {
  int result = myFunction.apply("42");
} catch (Exception e) {
  // обработка исключения
}
```


## END ---------------- Stream ----------------

## SOLID

- Single Responsibility Principle (Принцип единственной ответственности).
- Open Closed Principle (Принцип открытости/закрытости).
- Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
- Interface Segregation Principle (Принцип разделения интерфейса).
- Dependency Inversion Principle (Принцип инверсии зависимостей).</br></br>

'Single Responsibility Principle' - никогда не должно быть больше одной причины изменить класс.
</br></br>
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс
</br></br>
Пример:</br>
    Представьте себе модуль, который обрабатывает заказы.</br>
    Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа
</br></br>
Данный класс протировечит SRP так как он отвечает за 3 обязанности.</br>
В идеале это должны быть 3 отдельных класса, каждый из которых отвечает за свою область</br></br>

`Open Closed Principle` - программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.</br>
Должна быть возможность изменять внешнее поведеление класс, не внося физические изменения в сам класс.</br>
Класс должны разрабатываться так, чтобы для поднастройки класс к конкретным условиям применения было доставточно расширить его или переопределить некоторые функции
</br></br>
`Liskov’s Substitution Principle` - объекты в программе можно заменить их наследниками без изменения свойств программы.</br>
Класс, разработанный путем расширения на основании базового класса, должен переопределять его метода так, чтобы не нарушалась функциональность</br>
с точки зрения клиента. То есть не должно меняться ожидаемое поведение
</br></br>
`Interface Segregation Principle` - клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.</br>
Слишком "толстые" интерфейсы необходимо разделять на более мелкие, спецефические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе</br>
</br></br>
`Dependency Inversion Principle` - зависимости внутри системы строятся на основе абстракций.</br>
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономны и соединялись друг с другом с помощью абстракций


## END ---------------- SOLID ----------------

## ENUM

+ [1. Зачем нужен enum?](#1-зачем-нужен-enum)
+ [2. Что такое enum?](#2-что-такое-enum)
+ [3. Как указать значения для свойсты и как их получить](#3-как-указать-значения-для-свойсты-и-как-их-получить)

### 1. Зачем нужен enum?
Это класс для создания некоторого ограниченного круга значений
```
public enum DayOfWeek {
   SUNDAY,
   MONDAY,
   TUESDAY,
   WEDNESDAY,
   THURSDAY,
   FRIDAY,
   SATURDAY
}
```

### 2. Что такое enum?
Это финализированный класс, от него нельзя наследоваться

### 3. Как указать значения для свойств и как их получить
```
public enum DayOfWeek {

   SUNDAY ("Воскресенье"),
   MONDAY ("Понедельник"),
   TUESDAY ("Вторник"),
   WEDNESDAY ("Среда"),
   THURSDAY ("Четверг"),
   FRIDAY ("Пятница"),
   SATURDAY ("Суббота");

   private String title;

   DayOfWeek(String title) {
       this.title = title;
   }

   public String getTitle() {
       return title;
   }

   @Override
   public String toString() {
       return "DayOfWeek{" +
               "title='" + title + '\'' +
               '}';
   }
}
```
Получение всех значений `DayOfWeek.values()`
Получение индекса константы `int sundayIndex = DayOfWeek.SUNDAY.ordinal();`
Получение индекса по значению `DayOfWeek sunday = DayOfWeek.valueOf("SUNDAY");`


## END ---------------- ENUM ----------------

## Maven

+ [1. Как запускать jar file](#1-как-запускать-jar-file)
+ [2. Как запускать war file](#2-как-запускать-war-file)
+ [3. Чем отличается package от install](#3-чем-отличается-package-от-install)
+ [4. Какие есть команды у Maven](#4-какие-есть-команды-у-maven)
+ [5. Области действия зависимостей (scope)](#5-области-действия-зависимостей-scope)
+ [6. Плагины](#6-плагины)
+ [7. Как решить конфликт транзитивных зависимостей](#7-как-решить-конфликт-транзитивных-зависимостей)

### 1. Как запускать jar file
- java -jar main.jar

### 2. Как запускать war file
- Unwrap `jar -xvf MyWar.war`
- move into directory
- Run `java -classpath "lib/*:classes/." my.packages.destination.FileToRun`

### 3. Чем отличается package от install
- `package` - собирает проект и упаковывает его в формате (например jar, war)</br>
Она не устанавлиает собранный проект в локальный Maven озиторий или удаленный репозиторий, просто создает аптефакт

- `install` - собирает и упаковывает проект, а затем устанавливает его в локальный репозиторий Maven

### 4. Какие есть команды у Maven
- mvn clean
- mvn package
- mvn deploy - (установить артифакт в локальный репозиторий)
- mvn dependency:tree
- mvn archetype:generate - (создать проект из прототипа/шаблона проекта)
- mvn compile
- mvn -f dir/pom.xml package - (Форсировать использование зависемостей из другого pom файла)
- mvn -q package - (Упаковка в тихом режиме, показывает только ошибки)
- mvn -v
- mvn -DskipTests package - (Упаковка без тестов)
- mvn compiler:compile - (Компиляться только основные классы)
- mvn install
- mvn validate - (Провалидировать проект)
- mvn dependency:analyze
- mvn -help
- mvn test
- mvn verity - (Запускает проверку интеграционных тестов)
- mvn -o package - (Упаковка в режиме оффлайн)
- mvn -X package - (Упаков в режиме debug)
- mvn -V package - (Упаковка с отображением версий)
- mvn -T 4 clean install - (Параллельная упаковка в 4х потоках)

### 5. Области действия зависимостей (scope)
- test - зависимость будет использована при выполнении компиляции части проекта, которая содержит тесты, а также при запуске тестов
- compile - Настройка по умолчанию. Зависимость доступна для компиляции приложения и тестов
  - Для запуска тестов `mvn test`
  - для запуска приложения используется плагин `exec`
- provided - Аналогично `compile` за исключением того, что артефакт будет использоваться на этапе компиляции и тестирования, но не включается в сборку
  - например `hibernate`, `jsf` - необходимы только на этапе разработки
- runtime - артефакт нужен только на стадии выполнения приложения
- system - аналогично `provided` за исключением того, что артефакт будет указываться явно в виде абсолютного пути к файлу определенногому в теге systemPath
```
<dependencies>
    <dependency>
        <groupId>ru.carousel</groupId>
        <artifactId>carousel-lib</artifactId>
        <version>1.0</version>
        <scope>system</scope>
        <systemPath>
               /projects/libs/carousel-lib.jar
        </systemPath>
    </dependency>
</dependencies>
```

### 6. Плагины
- maven-compiler-plugin - плагин компиляции
- maven-resources-plugin - плагин включения ресурсов
- maven-source-plugin - плагин включения исходных кодов
- maven-dependency-plugin - плагин копирования зависимостей
- maven-jar-plugin - плагин создания jar-файла
- maven-surefire-plugin - плагин запуска тестов
- buildnumber-maven-plugin - плагин генерации номера сборки</br></br>

- `maven-compiler-plugin` - Плагин компиляции
  - Позволяет управлять версией компилятора
  - Позволяет определить версию java машины
  - source - версия java-кода
  - target - версия java машины
  - encoding - Кодировка исходного кода
```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.1</version>
    <configuration>
        <source>1.7</source>
        <target>1.7</target>
        <encoding>UTF-8</encoding>
    </configuration>
</plugin>
```

- `maven-resources-plugin` - плагин включения ресурсов
  - Перед сборкой копирует все ресурсы (файлы изображений, файлы .properties) в директорию таргет
```
<plugin>
    <artifactId>maven-resources-plugin</artifactId>
    <version>2.6</version>
    <executions>
        <execution>
            <id>copy-resources</id>
            <phase>validate</phase>
            <goals>
                <goal>copy-resources</goal>
            </goals>
            <configuration>
                <outputDirectory>
                       ${basedir}/target/resources
                </outputDirectory>
                <resources>
                    <resource>
                        <directory>src/main/resources/props</directory>
                        <filtering>true</filtering>
                        <includes>
                            <include>**/*.properties</include>
                        </includes>
                    </resource>
                    <resource>
                        <directory>src/main/resources/images</directory>
                        <includes>
                            <include>**/*.png</include>
                        </includes>
                    </resource>
                </resources>
            </configuration>
        </execution>
    </executions>
</plugin>
```

- `maven-source-plugin` - Плагин включения сходных кодов
  - позволяет включать в сборку проекта исходный код
```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-source-plugin</artifactId>
    <version>2.2.1</version>
    <executions>
        <execution>
            <id>attach-sources</id>
            <phase>verify</phase>
            <goals>
                <goal>jar</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

- `maven-dependency-plugin` - для копирования зависимостей в директорию сборки
  - outputDirectory - определение директории, в которую будут копироваться зависимости
  - overWriteReleases(default: false) - флаг необходимости перезаписывания зависимостей при создании релиза
  - overWriteSnapshots - флаг необходимости перезаписывания неокончательных зависимостей, в которых присутствует SNAPSHOT
  - overWriteIfNewer(default: true) - флаг необходимости перезаписывания библиотек с наличием более новых версий
```
<plugin> 
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>2.5.1</version>
    <configuration>
        <outputDirectory>
            ${project.build.directory}/lib/
        </outputDirectory>
        <overWriteReleases>false</overWriteReleases>
        <overWriteSnapshots>false</overWriteSnapshots>
        <overWriteIfNewer>true</overWriteIfNewer>
    </configuration>
    <executions>
        <execution> 
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
                <goal>copy-dependencies</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

- `maven-jar-plugin` - плагин создания jar-файла
  - позволяет сформировать манифест, 
  - описать дополнительные ресурсы, необходимые для включения в jar-файл
  - упаковать проект в jar-файл
  - `excludes` - блокирует включение в сборку определенных файлов изображений
```
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <includes>
            <include>**/properties/*</include>
        </includes>
        <excludes>
            <exclude>**/*.png</exclude>
        </excludes>
        <archive>
           <manifestFile>src/main/resources/META-INF/MANIFEST.MF</manifestFile>
        </archive>
    </configuration>
</plugin>
```
* Может создать и включить в сборку MANIFEST.MF самостоятельно
  * В секцию `archive` включить тег `manifest`
    * addClasspath - определяет необходимость добавления в манифест CLASSPATH
    * classpathPrefix - позволяет дописывать префикс перед каждым ресурсом
    * mainClass - указывает на главный исполяемый класс
```
<configuration>
    <archive>
        <manifest>
            <addClasspath>true</addClasspath>
            <classpathPrefix>lib/</classpathPrefix>
            <mainClass>ru.company.AppMain</mainClass>
        </manifest>
    </archive>
</configuration>
```

- `maven-surefire-plugin` - плагин для запуска тестов и генерации отчетов по результатам их выполнения
```
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>2.12.4</version>
        <configuration>
            <includes>
                <include>Sample.java</include>
            </includes>
        </configuration>
    </plugin>
</plugins>
```

### 7. Как решить конфликт транзитивных зависимостей
У нас есть 3 проекта с одиннаковыми артифактами разных версий
version-collision:
project-a
project-b
project-collision

1. Убрать транзитивную зависимость из проекта
2. Использовать dependencyManagement
```xml
<dependencyManagement>
   <dependencies>
      <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
         <version>29.0-jre</version>
      </dependency>
   </dependencies>
</dependencyManagement>
```
3. Использовать `maven-enforcer-plugin`
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-enforcer-plugin</artifactId>
    <version>3.0.0-M3</version>
    <executions>
        <execution>
            <id>enforce-banned-dependencies</id>
            <goals>
                <goal>enforce</goal>
            </goals>
            <configuration>
                <rules>
                    <banTransitiveDependencies/>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```
4. Использовать `dependencyConvergence`
В примере используется дефолтное поведение dependencyConvergence
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-enforcer-plugin</artifactId>
            <version>3.3.0</version>
            <executions>
                <execution>
                    <id>enforce</id>
                    <configuration>
                        <rules>
                            <dependencyConvergence/>
                        </rules>
                    </configuration>
                    <goals>
                        <goal>enforce</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

Можно исключить артифакт
```xml
...
<dependencyConvergence>
  <excludes>
    <exclude>com.google.guava:guava</exclude>
  </excludes>
</dependencyConvergence>
...
```

Можно включить артифакт
```xml
...
<dependencyConvergence>
    <includes>
        <include>com.google.guava:guava</include>
    </includes>
</dependencyConvergence>
...
```

## END ---------------- Maven ----------------

## Servlet

+ [1. Что такое servlet в java](#1-что-такое-servlet-в-java)
+ [2. Что такое контейнер сервлетов](#2-что-такое-контейнер-сервлетов)
+ [3. Какие функции выполняет контейнер сервлетов](#3-какие-функции-выполняет-контейнер-сервлетов)
+ [4. Контейнер сервлетов в контексте Spring](#4-контейнер-сервлетов-в-контексте-spring)
+ [5. Что делает `DispatcherServlet`](#5-что-делает-dispatcherservlet)

### 1. Что такое servlet в java
- Это класс, который используется для расширения возможностей серверных приложений, для обработки запросов и генерации ответов в протоколе HTTP
- Выполняются на сервере и работуют внутри контейнера сервлетов
- Когда на сервер HTTP-запрос от кликнта, контейнер сервлектов вызывает соответствующий сервлет для обработки запроса
- Могут обрабатывать различные типы запросов GET, POST, PUT, DELETE
- Обычно реализуют интерфейс `javax.servlet.Servlet` или расширяют абстрактный класс `javax.servlet.http.HttpServlet`
```
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.IOException;

public class HelloWorldServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html>");
        out.println("<body>");
        out.println("<h1>Hello, World!</h1>");
        out.println("</body>");
        out.println("</html>");
    }
}
```

### 2. Что такое контейнер сервлетов
Представляет собой часть веб-интерфейса или java-сервера приложений, которая управляет жизненным циклом сервлетов</br>
обрабатывает HTTP-запросы и генерирует HTTP-ответы

### 3. Какие функции выполняет контейнер сервлетов
- **Загрузка и инициализация сервлетов** - отвечает за загрузку соответствующих классов сервлетов и выполняет их инициализацию
- **Управление жизненным циклом сервлетов** - Создает экземпляры сервлетов, управляет их состоянием и освобождает ресурсы после завершения
- **Маршрутизация запросов** - При получении запроса определяет какому сервлету он должен быть направлен на основе URL или других параметров запроса
- **Передача данных запроса сервлету** - Предоставляет потоки ввода/вывода, такие как `HttpServletRequest` и `HttpServletResponse` чтобы сервлет мог получать данные от клиента и генерировать ответ
- **Управление потоками и масштабирование** - обрабатывает одновременные запросы от множества клиентов, управляет потоками и обеспечивает масштабируемость

Пример контейнеров Apache Tomcat, Jetty, IBM WebSphere, Oracle WebLogic

### 4. Контейнер сервлетов в контексте Spring
- Spring MVC предоставляет свой собственный контейнер сервлетов, который называется `DispatcherServlet`
- Он является посредником между клиенскими запросами и обрабатывающими их компонентами (контроллерами)

### 5. Что делает `DispatcherServlet`
- обрабатывает входящие запросы, основываясь на конфигурации приложения и на основе маппинга
- Определяет какой контроллер будет вызван для обработки каждого запроса
- Предоставляет поддержку для внедрения зависимостей в контроллеры и обработку исключений

## END ---------------- Servlet ----------------

## Swagger

+ [1. Какие аннотации используются для swagger документации](#1-какие-аннотации-используются-для-swagger-документации)

### 1. Какие аннотации используются для swagger документации
- `@Operation` - описывает операцию или обычно метод HTTP для определенного пути
- `@Parameter` - представляет один параметр в операции OpenAPI
- `@RequestBody` - представляет тело запроса в операции
- `@ApiResponse` - представляет ответ в операции
- `@Tag` - представляет теги для операции или определения OpenAPI
- `@Server` - представляет серверы для операции или для определения OpenAPI
- `@Callback` - исывает набор запросов
- `@Link` - представляет возможную ссылку времени разработки для ответа
- `@Schema` - позволяет определять входные и выходные данные
- `@ArraySchema` - позволяет определять входные и выходные данные для типов массивов
- `@Content` - позволяет схему и примеры для определенного типа мультимедиа
- `@Hidden` - скрывает ресурс, операцию или свойство
```
@Tag(name = "User", description = "The User API")
@RestController
public class UserController {}
    @Operation(summary = "Gets all users", tags = "user")
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Found the users",
            content = {
                @Content(
                    mediaType = "application/json",
                    array = @ArraySchema(schema = @Schema(implementation = UserApi.class)))
            }
        )
    })
    @GetMapping("/users")
    public List<UserApi> getUsers()
```


## END ---------------- Swagger ----------------

## Nginx

+ [1. Что такое Nginx](#1-что-такое-nginx)
+ [2. Как работает Nginx](#2-как-работает-nginx)
+ [3. Отличие Nginx от Apache](#3-отличие-nginx-от-apache)
+ [4. Конфигурация](#4-конфигурация)
+ [5. Основные команды](#5-основные-команды)

### 1. Что такое Nginx
Это веб-сервер, который обрабатывает запросы пользователя от браузера и присылает ту страницу, которая была запрошена

### 2. Как работает Nginx
Умеет:
- Принимает, обрабатываает и отдает клиентам запросы
  - Обработка происходит внутри специального модуля
  - Каждый запрос Nginx делит на небольшие однотипные структуры - рабочие соединение и обрабатывает несколько соединений параллельно
  - После выполнения они сливаются в единый блок и возвращаются в качестве ответа
- Выступает в качестве прокси-сервера
  - В микросервисной структуре Nginx-у сложно обрабатывать множество клиенских запросов, поэтому он работает в качестве "пересыльщика"
    - Принимает запрос от клиента
    - Передает его отдельному серверу для обработки
    - Получает ответ от сервера
    - Отправляет клиенту

### 3. Отличие Nginx от Apache
|                                 | Nginx           | Apache                               |
|---------------------------------|-----------------|--------------------------------------|
| Работа с динамическим контентом | уступает        | лучше работает с контентом с сервера |
| Работа со статическим контентом | Лучше работает  | хуже работает со статикой            |

### 4. Конфигурация
| Директива                                                                                      | Расшифровка                                                                                                                                                      |
|------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| listen 8080;                                                                                   | Сервер будет запускаться на порте 8080                                                                                                                           |
| ```server {listen 8080; root /data/up1; location / {}}```                                      | Сложная директива можевключать в себя несколько простых<br/>Он прослушивает порт 8080 и отдает статические файлы из data при обращении к корневой странице сайта |
| ```server {location / { proxy_pass http://localhost:8080;} location /images/ {root /data;}}``` | Перенаправление запроса                                                                                                                                          |
| ```location ~ \.(git jpg png)$ { root /data/images;}```                                        | Фильтр по типу файла                                                                                                                                             |
|                                                                                                |                                                                                                                                                                  |

### 5. Основные команды
| Команда | Описание                             | Пример            |
|---------|--------------------------------------|-------------------|
| stop    | быстро завершить                     | nginx -s stop     |
| quit    | плавно завершить                     | nginx -s quit     |
| reload  | перезагрузить конфигурационный файл  | nginx -s reload   |
| reopen  | открыть лог-файлы заново             | nginx -s reopen   |

## END ---------------- Nginx ----------------

## Java 8

+ [1. Методы интерфейсов по умолчанию](#1-методы-интерфейсов-по-умолчанию)
+ [2. Лямбда-выражения](#2-лямбда-выражения)
+ [3. Функциональные интерфейсы](#3-функциональные-интерфейсы)
+ [4. Ссылки на методы и конструкторы](#4-ссылки-на-методы-и-конструкторы)
+ [5. Области действия лямбд](#5-области-действия-лямбд)
+ [6. Доступ к полям и статическим переменным](#6-доступ-к-полям-и-статическим-переменным)
+ [7. Доступ к методам интерфейсом по умолчанию](#7-доступ-к-методам-интерфейсом-по-умолчанию)
+ [8. Stream](#8-stream)
+ [9. Апи для работы с датами](#9-апи-для-работы-с-датами)
+ [10. Аннотации](#10-аннотации)

### 1. Методы интерфейсов по умолчанию
```
interface Formula {
    double calculate(int a);
    
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```

### 2. Лямбда-выражения
```
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```

### 3. Функциональные интерфейсы
```
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```

### 4. Ссылки на методы и конструкторы
```
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);
```

### 5. Области действия лямбд
Лямбды могут ссылаться на переменные, обхявленные как final, на экземплярные поля класса и статические переменные
```
final int num = 1;
Converter<Integer, String> stringConverter = (from) -> String.valueOf(from + num);

stringConverter.convert(2);
```
переменная num не обязательно должна быть final, но должна быть неизменяемой

### 6. Доступ к полям и статическим переменным

### 7. Доступ к методам интерфейсом по умолчанию
Внутри лямбда-выражений запрещено обращаться к методам по умолчанию

### 8. Stream

### 9. Апи для работы с датами
- Clock
- Часовые пояса
- LocalTime
- LocalDate
- LocalDateTime

### 10. Аннотации
    @Repeatable


## END ---------------- Java 8 ----------------

## Аутентификация и авторизация

+ [1. Аутентификация](#1-аутентификация)
+ [2. Авторизация](#2-авторизация)


### 1. Аутентификация
- Цель: Аутентификация представляет собой процесс установления и подтверждения подлинности личности или субъекта, например пользователя, системы или оборудования
- Пример: В процессе аутентификации польователь предоставляет учетные данные (логин/пароль, отпечаток пальца) для проверки подлинности, чтобы подтвердить, что он действительно тот, за кого себя выдает

### 2. Авторизация
- Цель: Авторизация - это процесс управления доступом, который определяет, что имеет право делать аутентифицированный субъект. То есть, определяет, какие ресурсы и операции могут быть доступны для этого субъекта
- Пример: После того как пользоваетль аутентифицирован, авторизация определяет его достпные возможности - может ли он просматривать, создавать, удалять определенную информацию или выполнять определенные функции


## END ---------------- Аутентификация и авторизация ----------------

## JIT компилятор

+ [1. Что такое JIT компилятор](#1-аутентификация)


### 1. Что такое JIT компилятор


## END ---------------- JIT компилятор ----------------

26. Можно ли увеличить размер массива после его инициализации?
нет, только пересоздать новый массив


27. Как создать собственный иммутабельный класс?
final и без геттеров