https://github.com/johnivo/job4j/blob/master/interview_questions/Core.md#4-%D0%94%D0%BB%D1%8F-%D1%87%D0%B5%D0%B3%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-JDK

## ---------------- Основы ----------------

1. Какие преимущества у Java?
    - Основное преимущество  - кроссплатформенность
    - Огромный выбор библиотек под любые задачи
    - Автоматическое управление памятью
    - Многопоточность
    - ООП


2. Какие недостатки у Java?
    - Низкая скорость в сравненни с С и С++
    - Требует много памяти
    - Нет поддержки низкоуровневого программирования (например указателей)
    - Планирование новой программы занимает много времени из-за ООП
    - Многословность


3. Что такое JVM, JDK, JRE? В чем отличия?

   `JVM(Java Virtual Machine)` — это часть платформы Java, которая исполняет программы.
   программа, предназначенная для выполнения байт-кода. Преимущество - "Write once, run anywhere"

   `JRE(Java Runtime Environment)` — это элемент Java, расположенный на диске, создающий и запускающий JVM
   это пакет всего необходимого для запуска скомпилированной Java программы

   `JDK(Java Development Kit)` - позволяет разработчикам создавать Java-программы, которые могут выполняться и запускаться посредством JVM и JRE. JDK = JRE + компилятор
   включает в себя около 40 различных тулов (компилятор, лаунчер приложений, java debugger etc.


4. Что такое byte code?
    - это стандартное промежуточное представление [en], в которое может быть переведена компьютерная программа автоматическими средствами.


5. Что такое загрузчик классов classloader?
   Это объект, которые отвечает за загрузку классов. ClassLoader  это абстрактный класс


6. Что такое JIT?
   Если в программе присутствуют части кода, которые выполняются много раз,
   то их можно скомпилировать один раз в машинный код, чтобы в будущем ускорить их выполнение.
    - Ускорение работы программы достигается за счет увеличения потребления памяти (чтобы хранить этот код)


7. Что такое String[] args в методе main()?
   Это аргументы которые будут переданы из консоли


8. Что такое пакеты, зачем они нужны? Какие пакеты по умолчанию подключены?
   Для разграничения областей видимости и группировки классов

   По умолчанию подключено lang

## END ---------------- Основы ----------------


## ---------------- ООП ----------------

1. Что такое ООП?
   ООП - это объектно ориентированное программирование.
   Это программирование с помощью классов и объектов


2. Что такое объект?
   Объект  - это сущность, одновременно содержащая данные и поведения.
   Объекты - это строительные блоки объектно-ориентированных программ.

   Данные объектов - состояние объекта(атрибуты).
   Пример: атрибуты работника (SocialSecurityNumber, Gender, DateOfBirth)
   Поведения объектов - что объект может сделать( в процедурных языках определяется процедурами, функциями и подпрограммами) (методы).
   Пример: методы работника (setGender() getGender() - для установки и получения пола).

3. Что такое класс?
   Класс - это "чертеж" объекта


4. Какие преимущства у ООП?
    - Модульность - инкапсуляция объектов в себе упрощает разработку, уменьшает количество ошибок
    - Реюзабельность кода
    - Высокая скорость разработки - классы и интерфейсы в ООП могут легко трансформироваться в подобие полноценных библиотек
    - Расширяемость - ООП легко развивать, дополнять и менять. Этому способствует независимая модульная структура
    - Простота восприятия
    - Безопасность - инкапсулированных код недоступен извне, поэтому поломать что-либо сложнее
    - Гибкость - полиморфизм позволяет быстро адаптировать ООП-код под свои нужды


5. Какие недостатки у ООП?
    - Объекты во главе угла - из-за особенного внимания к объектам, меньше внимания уделяется вычислениям и алгоритмам
    - Негативно сказывается на скорости компиляции кода


6. Основные принципы ООП
    - Инкапсуляция
    - Наследование
    - Полиморфизм
    - Абстракция - каждый верхний слой над объектом (классы) более абстрактный


7. Что такое ассоциация? https://i.stack.imgur.com/BBNy5.png
   Объекты между собой никак не связаны. Первый объект может принадлежать сразу нескольким объектам одновременно и не управляться ими
   Наследование позволяет одному классу наследовать от другого, поэтому мы можем абстрагировать атрибуты и поведения для общих классов


8. Что такое агрегация?
   Это вложенность одного класса в другой, но при этом класс обертка не управляет сроком жизни вложенного объекта
   части могут принадлежать более чем одному целому за раз, и целое не управляет существованием и временем жизни частей

    - Например, отношения между человеком и его домашним адресом. У каждого человека есть свой адрес. Однако этот адрес может принадлежать более чем одному человеку за раз
      Однако этот адрес не управляется человеком — адрес существовал до того, как человек заселился и будет существовать после того, как человек выселится.


9. Что такое композиция?
   это отношения части-целого. Часть в композиции может быть частью только одного объекта за раз

    - Например: cердце, которое является частью тела одного человека, не может быть частью тела ещё одного человека одновременно.


10. Раннее и позднее связывание
    - Раннее - это когда метод, который будет вызван, известен во время компиляции, например, вызов статического метода
    - Позднее - это когда вызов метода может быть осуществлен только во время выполнения и у компилятора нет информации, чтобы проверить корректность такого вызова.


11. Можно ли переопределить private или static методы?
    нельзя


12. Можно ли менять модификатор доступа у унаследованных методов,свойств
    Понижать уровень доступа нельзя
    Повышать уровень доступа можно


13. Можно ли получить доступ к нестатическому полю из статического метода?
    нет

## END ---------------- ООП ----------------

## ---------------- Процедурная Java ----------------

1. Какие примитивные типы данных есть в Java?

   ТИП     |Размер в байтах |     Диапазон значений     |     Значение по умолчанию     |     Описание
   byte    |     1          |   -128 .. 127             |     0                         | Самое маленькое целое — один байт
   short   |     2          |   -32,768 .. 32,767       |     0                         | Короткое целое, два байта
   int     |     4          |   -2*10 в 9 .. 2*10 в 9   |     0                         | Целое число, 4 байта
   long    |     8          |   -9*10 в 18 .. 9*10 в 18 |     0L                        | Длинное целое, 8 байт
   float   |     4          |   -10 в 38 .. 10 в 38     |     0.0f                      | Дробное, 4 байта
   double  |     8          |   -10 в 308 .. 10 в 308   |     0.0d                      | Дробное, двойной длины, 8 байт
   boolean |     1          |   true, false             |     false                     | Логический тип (только true & false)
   char    |     2          |   0 .. 65,535             |     '\u0000'                  | Символы, 2 байта, все больше 0
   NaN     |                |                           |                               | Не число


2. Какими значения по умолчанию инициализируются поля примитивных типов
   данных?
   Числовые и char = 0
   Булево = false


3. Что такое автоупаковка и автораспаковка?

   Автоупаковка (autoboxing) — это процесс автоматической инкапсуляции данных простого типа, такого как int или double, в эквивалентную ему оболочку типа, как только понадобится объект этого типа. При этом нет необходимости в явном создании объекта нужного типа.
   Автораспаковка (auto-unboxing) — это процесс автоматического извлечения из упакованного объекта значения, когда оно потребуется.


4. Что такое класс-обертки?
   Обертка - это специальный класс, который хранит внутри себя значение примитива

   int - Integer
   short - Short
   long - Long

   Классы обертки позволяют невелировать недостатки, которые есть у примитивных типов
   Самый очевидный из них — примитивы не имеют методов.

5. Что такое cast?
   Приведение типов


6. Что такое пул интов?
   Java хранит пул интов [-128; 127]


7. Какие нюансы у строк в Java?
    - Класс реализует Serializable и CharSequence
    - Это final класс, который не может иметь потомков
    - это immutable класс, его объекты не могут быть изменены после создания. Любые операция приводят к созданию нового объекта
    - Благодаря неизменяемости - это потокобезопасный класс
    - Каждый объект может быть преобразован в строку с помощью toString


8. Что такое пул строк?
   Это набор сктрок, который хранится в Java heap
   Пул строк возможет благодаря неизменяемости строк в Java
   Пул строк помогает экономить большой объем памяти

   Когда мы используем двойные кавычки для создания строки, сначала строка ищется в пуле с таким же значением, если находится
   то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка

   Когда мы используем оператор new мы принуждаем создать новую строку


9. Почему строки не рекомендуется использовать для хранения паролей?
   Строка хранится в пуле строка до тех пор пока она не будет удалена сборщиком мусора
   Даже если мы думаем, что закончили работу с паролем, он остается доступен в памяти

   Лучше использовать массив символов для хранения пароля, так как мы можем его очистить после того, как закончим с ним работать


10. Почему строка неизменяемый и финализированный класс?
    - Строковый пул возможен только потому, что строка неизменна. Таким образом сохраняется много места в памяти
    - Изменяемая строка - это угроза приложению: Например параметры для соединения с бд передаются в виде строки и х нельзя изменить
    - Неизменная строка безопасна для многопоточности
    - Ее hashCode кэшируется в момент создания и нет необходимости расчитывать его снова. Это делает строку отличным кандидатом для ключа в Map
      и ее обработка будет быстрее


11. Что делает метод intern() в классе String?
    Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную нашему объекту, тогда возвращается ссылка на строку из пула
    Этот метод возвращает строкуЮ которая имеет то же значение, что и текущая строка, но гарантирует что это будет строка из пула уникальных строк


12. Можно ли использовать строку в конструкции Switch
    - строки switch чувствительны к регистру
    - оператор использует метод `String.equals()` для сравнения полученного значения со значениемя case, поэтому необходима проверка на null
    - согласно Java 7 для строк в switch компилятор формирует более эффективный байт код


13. Что такое инвариантность и ковариантность
    Ковариантность - случай когда более конкретный тип S может быть подставлен вместо более обобщенного типа Т
    Инвариантность - случай когда подставлять можно только определенный тип


14. В чем разница между String, StringBuffer, StringBuilder?
    String - это класс для создания объекта типа String
    StringBuffer - это класс, который используется для изменения строк и обеспечения безопасности потоков (синхронизирован)
    StringBuilder - это класс класс, который используется для изменения строк, не обеспечивающих потокобезопасность (не синхронизирован)


15. Каким образом переменные передаются в метода?
    Примитивные - копируется само значение
    Ссылочные - копируется ссылка


16. В чем разница между Hashtable и HashMap?
    Hashtable - все методы синхронизированные
    HashMap - все методы не синхронизированные

## END ---------------- Процедурная Java ----------------

## ---------------- ООП в Java ----------------

1. Какие виды есть в java?
    - Вложенные внутренние классы
    - Вложенные статические классы
    - Локальные классы
    - Анонимные классы


2. Что такое вложенные классы? В каком случаях они применяются?
   Это классы, которые создаются внутри других классов
   Бывает 2 вида вложенных классов: Нестатические и статические

   Нестатические в свою очередь делятся на подвиды
    - Анонимные
    - Локальные

   Внутреннние классы - это классы для выделения в программе некой сущности, которая неразрывно связана с другой сущностью
   Например - Руль, сиденьк, педали - это составные части велосипеда

    - Объект внутреннего класса не может существовать без объекта "внешнего" класса
    - У объеккта внутреннего класса есть доступк переменных "внешнего" класса
    - Объект внутреннего класса нельзя создать в статическом методе "внешнего" класса
    - Внутренний класс не может содержать статические переменные и методы


3. Что такое "локальный класс"? Каковы его особенности?
   Это классы  объявленные внутри других методов

    - Локальные классы могут работать только с final переменными метода
    - Локальные классы нельзя объявлять с модификаторами доступа
    - Локальные классы обладают доступом к переменным метода


4. Что такое "анонимные классы"? Где они применяются?
    - Это обычные нестатические вложенные классы, в более кратком виде. Объявляется класс и сразу создается экземпляр

   Используются когда
    - тело класса является коротким
    - нужен только ожин экземпляр класса
    - класс используется в месте его создания или сразу после него
    - имя класса не важно


5. Каким образом из вложенного класса получить доступ к полю внешнего класса?
   Для получения доступа из внутреннего класса к экземпляру его внешнего класса необходимо в ссылке указать имя класса и влючевое слово this
   OuterClass.this


6. Что такое перечисления (enum) ?
   enum - это класс java.lang.Enum
   Элементы перечисления - экземпляры enum-класса, доступные статически


7. Как проблема ромбовидного наследования решена в Java?
   В Java нет множественного наследования
   Но есть возможность использовать неограниченное количество интерфейсов


8. Что такое конструктор по умолчанию?
   Если конструктор у класса не задан, то по умолчанию создастся пустой конструктор без реализации, которые будет вызывать super


9. Могу ли быть приватные конструкторы? Для чего они нужны?
   Может
   Защищает класс от явного превращения в экземпляр. Используется в шаблоне "Одиночка"
   Обычно для создания объекта требуется вызвать другой метод


10. Что такое классы-загрузчики и динамическая загрузка классов?
    Есть 2 типа загрузки классов
    - Статическая
    - Динамическая

    Статическая - это привычная загрузка, которая производится автоматически. При запуске программы загрузчик классов рекрсивно загружает все классы, встречающиеся в программе, начиная с main
    Динамическая - производится через метод Class.forName(String className) или с использованием ClassLoader
    Динамическая загрузка классов имеет смысл, когда требуется загрузить класс во время выполнения программы, когда нужно заменить класс, изменив, например, какую-то логику, не рестартуя приложения

    // загружаем класс через ClassLoader
    ClassLoader classLoader = MainClass.class.getClassLoader();
    Class aClass = classLoader.loadClass("com.jenkov.MyClass");
    myClass = (MyClass) aClass.newInstance();


11. Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?
    - Конструктор по-умолчанию не принимает никаких параметров
    - Конструктор копирования принимает в качестве параметра объект класса
    - Конструктор с параметрами принимает на фход параметры

    Конструктор копирования
```
// конструктор копирования
public Circle(Circle circle) {
    this(circle.getName(), circle.getArea(), circle.getPerimeter()); //будет вызван конструктор с параметрами ниже
}
```

12. Какие модификации уровня доступа вы знаете, расскажите про каждый из них.
    - private (закрытый) - доступ не предоставляется никому, кроме методов этого класса
    - default, package, friendly - доступ по умолчанию. Открытый внутри собственного пакета
    - protected (защищённый) - доступ в пределах пакета и классов наследников
    - public (открытый) - доступен всем и везде


13. Что означает модификатор static?
    Это значит что моле или метод будет относиться к классу, а не к инстансу(объекту) класса


14. Могут ли нестатические методы перегрузить статические?
    Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.


15. Могут ли быть переопределены статические методы?
    Переопределить базовый статический метод нельзя: Instance method имяМетода in классНаследник cannot override method имяМетода in родительскийКласс


16. Можно ли сузить уровень доступа/тип возвращаемого значения при переопределение метода?
    нет, можно только расширить


17. Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы
    Можно менять модификатор доступа в стороны расширения

    - У переопределенного метода должны быть те же аргументы, что и у метода родителя.
    - У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.
    - Модификатор доступа у переопределенного метода также не может отличаться от «оригинального» в меньшую сторону

18. Могут ли классы быть статическими
    Да


19. Что такое сигнатуры методы?
    Это имя + параметры (порядок параметров имеет значение)


20. Что такое переопределение и перегрузка методов?
    переопределение - изменение тела унаследованного метода
    перегрузка - несколько вариантом методов с разными аргументами


21. Когда вызывается конструктор?
    ПРи созданииэксземпляра класса


22. Что означает ключевое слово final?
    final - у метода, у переменной, у класса

    Класс нельзя унаследовать
    Метод нельзя переопределить
    Свойство нельзя переопределить


23. Могут ли быть конструкторы у абстрактных классов? Зачем они нужны?
    Да
    Создать экземпляр абстрактного класса нельзя, но все-равно можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе


24. Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
    Это контракт описывающий возможности
    По умолчанию все методы объявляются как public abstract (начиная с Java 8 - default)
    Поля - public static final


25. Может ли интерфейс наследоваться от интерфейса?
    Интерфейс может наследоваться только от интерфейсов


26. Что такое дефолтные методы интерфейсов?
    Это реализация метода по умолчанию


27. Как решается проблема ромбовидного наследования при наследовании интерфейсов с default методами?
    Никак. Будет ошибка на этапе компиляции.


28. Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
    - конструктор созданного класса объекта
    - конструктор родителя созданного класса объекта (неявный super в начале конструктора класса)


29. Какие бываю и зачем нужны блоки инициализации?
    - Блоки инициализации представляют собой наборы выражений инициализации полей, заключенные в фигурные скобки и размещаемые внутри класса вне объявлений методов или конструкторов.
    - Блок инициализации выполняется так же, как если бы он был расположен в верхней части тела любого конструктора.
    - Если блоков инициализации несколько, они выполняются в порядке следования в тексте класса.

    Бываю статические и нестатические
    static {}
    {}

    Зачем?
    - более читабельный код
    - внутри блоков можно не только присваивать значение, но и писать команды (вывод в косоль, циклы и т.д.)


30. Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
    - Все статические блоки от первого предка - до последнего наследника
    - попарно динамические блоки инициализации и конструктор (от предка до последнего потомка)


31. Что произойдет, если в блоке инициализации возникнет ошибка?
    -Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется,
    чтобы объявления этих исключений были перечислены в throws всех конструкторов класса.
    Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции. (java.lang.ExceptionInInitializerError;)

    - остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте.
       Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.
    
       ( тип ошибки - Если возникшее исключение - наследник Error,
         то в обоих случаях будет выброшено java.lang.Error.
         Исключение: java.lang.ThreadDeath - смерть потока.
         В этом случае никакое исключение выброшено не будет.
       )


32. Какие методы есть у object
    wait — поток переходит в режим ожидания в течение указанного времени.
    equals — сравнивает объекты.
    clone — клонирование объекта
    notify — просыпается один поток, который ждет на “мониторе” данного объекта.
    finalize — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет. (deprecated)
    toString — возвращает строковое представление объекта.
    hashCode — возвращает хеш-код
    notifyAll — просыпаются все потоки, которые ждут на “мониторе” данного объекта.


33. Что такое метод equals(). Чем он отличается от операции ==. (https://habr.com/ru/post/168195/)
    При сравнении с помощью `==` идет сравнение по ссылкам
    При сравнении по equals() идет сравнение по состоянию объектов

    Хем-код - это число. Битовая строка фиксированной длины, полученная из массива произвольной длины (ограничена типом int)


34. Каким образом реализованы методы equals() и hashCode()

    hashCode() - `public native int hashCode();` - реализация на языке С++

    equals() -
```
public boolean equals(Object obj) {
    return (this == obj);
}
```

35. Правила переопределения equals()
    При переопределении обязательно необходимо переопределить hashCode()


36. Правила при переопределении hashCode
    у них должен быть реализован метод для создания ключа и значения должны быть финализированы


37. Могут ли у разных объектов быть одиннаковые hashCode() ?
    Да, это называется коллизией


38. Чем a.getClass().equals(A.class) отличается от instanceOf A.class
    - метод getClass () всегда возвращает точно тот класс, от которого был порожден объект.


39. Может ли метод быть одновременно abstract и final?
    нет


40. Функиональные интерфейсы
    Функциональным считается интерфейс с одним не реализованным (абстрактным) методом
    + интерфейсы, которые создаются след образом

```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);
}
```
@FunctionalInterface - сообщает компилятору, что данный интерфейс функциональный и должен содержать не более одного метода

* Абстрактные интерфейсы могут иметь методы, которые не входят в ограничения одного метода

Статические методы
```
@FunctionalInterface
public interface Converter<T, N> {
    N converter (T t);

    staitc <T> boolean isNotNull(T t) {
        return t != null;
    }
}
```
+ методы по умолчанию
```
@FunctionalInterface
public interface Converter<T, N> {
  N converter (T t);

  staitc <T> boolean isNotNull(T t) {
    return t != null;
  }

  default void writeToConsole (T t) {
    System.out.println("Текущий объем - " + t.toString());
  }
}
```
### END ---------------- ООП в Java ----------------


## ---------------- Исключения ----------------

1. Опишите иерархию исключений?

|     |                   | Object       |            |
|-----|-------------------|-----------|------------|
|     |                   | Throwable    |            |
|  Error   |              |       Exception       |   |
|  OutOfMemoryError   | StackOverflowError |RuntumeException | IOExeption |
|  LinkageError   |                   |IllegalArgumentExceprion |            |


3. Расскажите про обрабатываемые и необрабатываемые исключения?
    - контролируемые исключения (checked) - это ошибки, которые можно и нужно обрабатывать в программе
    - неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) - не трубуют обязательной обработки, но при желании можно обработать
    - исключения времени выполнения (RuntimeExceptions, потомок класса Exception)


4. Какой оператор позволяет принудительно выбросить исключение?
   throw


5. Как создать собственное (пользовательское) исключение?
   Создать класси у наследоваться от Exception


6. В каком случае не выполнится блок finally
   Если в блоке try или catch есть System.exit


7. Может ли метод main выбросить исключение во вне и е
   да, в стандартный вывод ошибок будет выведено сообщение об ошибке, в котором будет указано имя потока
   Если нет запущенных потоков-недемонов, то программа будет завершена, иначе будет ждать завершения всех потоков


8. В каком порядке следует обрабатывать исключения в catch блоках?
   В порядке от наследников к родителю


9. Что такое try-with-resources?
   Это оператор, который решает проблему с обязательным вывзовом close()


10. Что произойдет есть исключение будет выброшено из блока catch после чего другое исключенгие будет выброшено из блока finally
    В finally можно реализовать вложенны try-catch


11. В чем разница между Exception и Error?
    Error - невозмжноо починить
    Exception - можно обработать ошибку


12. Можно ли использовать проверяемые исключения в лямбда функциях
    Нет


## END ---------------- Исключения ----------------

## ---------------- Сериализация и копирование ----------------

1. Что такое сериализация и как она реализована в Java?
   Сериализация  - это процесс сохранения объекта в последовательный байт
   Десериализация  - это процесс восстановления объекта в байт


2. Для чего нужна сериализация?
   Сериализация нужна для передачи объектов


3. Опишите процесс сериализации/десериализации с использованием Serializable
   При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API) выполняет:

    - запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор SerialVersionUID, идентификаторы полей класса);
    - рекурсивную запись в поток описания суперклассов до класса java.lang.Object (не включительно);
    - запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;
    - рекурсивную запись объектов, которые являются полями сериализуемого объекта.

   При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.

   При имплементации интерфейса Serializable у класса появляется идентификатор версии.
   Он вычисляется по содержимому класса - полям, порядку объявления, методам.
   Соотвественно при десериализации поля, порядок и методы должны совпадать.
   Чтобы избежать возможных ошибок можно вручную задать для класса идентификатор версии (long serialVersionUID)


4. Какие поля не будут сериализованы при сериализации?
   Те, которые не помечены как transient

   Поля с модификатором final сериализуются как и обычные.
   За одним исключением – их невозможно десериализовать при использовании `Externalizable`.
   Ибо final-поля должны быть инициализированы в конструкторе,
   а после этого в readExternal изменить значение этого поля будет невозможно.
   Соответственно – если вам необходимо сериализовать объект, имеющий final-поле,
   вам придется использовать только стандартную сериализацию.


5. Как изменить стандартное поведение сериализации/десериализации?
    - Реализовать интерфейс `java.io.Externalizable`, который позволяет применение пользовательской логики сериализации.
      Способ сериализации и десериализации описывается в методах `writeExternal()` и `readExternal()`.
      Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.

    - Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его,
      а не метод по умолчанию :
      ~ writeObject() - запись объекта в поток;
      ~ readObject() - чтение объекта из потока;
      ~ writeReplace() - позволяет заменить себя экземпляром другого класса перед записью;
      ~ readResolve() - позволяет заменить на себя другой объект после чтения.


6. Как создать собственный протокол сериализации?
   Для создания собственного протокола сериализации достаточно реализовать интерфейс `Externalizable`, который содержит два метода:
   `writeExternal()` и `readExternal()`


7. В чем проблема сериализации Singleton?
   Проблема в том, что после десериализации мы получим другой объект.
   Как этого избежать:
    - явный запрет сериализации
    - определение метода с сигнатурой (default/public/private/protected/) Object readResolve() throws ObjectStreamException


8. Как происходит сериализация
    1. Унаследоваться от интерфейса Serializable
       [Serializable] - маркерный интерфейс

    2. Определить переменную
       private static final long serialVersionId = 1;
       Данные поле будет содержать уникальный идентификатор версии сериализованного класса

   При сериализации значение serialVersionId сравнивается с десериализованным значением
   ! Если значения не совпадут будет выброшено исключение InvalidClassException

    3. Сериализайия внутренних классов
       Все вложенные классы должны имплементировать интерфейс Serializable

    4. Для того, чтобы свойство не сериализовалось, необходимо использовать ключевое слово transient


## END ---------------- Сериализация и копирование ----------------

## ---------------- Дженерики ----------------

1. Что такое дженерики?
   Дженерики - это типы с параметром


2. Для чего нужны Дженерики?
   Дженерики помогают упростить реализацию принципа ООП - Полиморфизм


3. Что такое сырые типы?
   Raw type - это класс-дженерик, из которого удалили его тип
   Возможность превратить в Raw type оставили для совмещения со старым кодом


4. Что такое `wildcard`?
   Upper Bounded Wildcards - <? extends Animal> - в такой объект ничего кроме null положить нельзя
   Это значит, что метод принимает на вход коллекцию объектов класса Animal либо объектов любого класса-наследника Animal

   Lower Bounded Wildcards - <? super Animal> - Можно положить:
   superZoo.encage(new Elephant("Джимбо", 3));
   superZoo.encage(new Animal("", 1))
   Это значит, что метод принимает на вход коллекцию объектов класса Animal либо любого другого класса предка Animal


5. Расскажите про принцы PECS ***
   Producer Extends Consumer Super - если у нас есть некая коллеция, типизированная wildcard с верхней границей (extends) то это "продюсер"

## END ---------------- Дженерики ----------------

## ---------------- Коллекции ----------------

1. Что такое коллекция?
   Коллекции - это наборы однородных элементов


2. Расскажите про иерархию коллекций?

   Первая иерархия
   Collection делится на подколлекции:
    - Set - описывает такую структуру как множество, содержащее неупорядоченные уникальные элементы. Есть стандартные реализации - TreeSet, HashSet, LinckedHashSet
    - List - структура данных, которая хранит упорядоченную последовательность объектов. Реализации - ArrayList, Vector, LinckedList
    - Queue - Хранит элементы в виде очереди, которая следует правилу First In First Out. Реализации - LinckedList, PriorityQueue

   Вторая иерархия
   Map делится на подколлекции:
    - HashTable, LinkedHashMap, TreeMap


3. Почему Map - это не Collection, в то время как List и Set являются Collection?
   Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».


4. В чем разница между классами java.util.Collection и java.util.Collections?
   java.util.Collections - набор статических методов для работы с коллекциями.

   java.util.Collection - один из основных интерфейсов Java Collections Framework.


5. Что такое «fail-fast поведение»?
   fail-fast означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом

   Fail-fast итератор генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, а fail-safe – нет.

   Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):
    - при изменении коллекции счетчик модификаций так же изменяется;
    - при создании итератора ему передается текущее значение счетчика;
    - при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.


6. Какая разница между fail-fast и fail-safe?
   В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.


7. Чем различается Enumeration и Iterator?
    - с помощью Enumeration нельзя добавлять/удалять элементы;
    - в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
    - Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.


8. Как между собой связаны Iterable, Iterator и «for-each»?
   Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.


9. Сравните Iterator и ListIterator.
    - ListIterator расширяет интерфейс Iterator
    - ListIterator может быть использован только для перебора элементов коллекции List;
    - Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next().
      Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous();
    - ListIterator не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы previous() и next().
    - При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove().
      Iterator не поддерживает данного функционала.


10. Как поведёт себя коллекция, если вызвать iterator.remove()?
    Если вызову iterator.remove() предшествовал вызов iterator.next(),
    то iterator.remove() удалит элемент коллекции, на который указывает итератор,
    в противном случае будет выброшено IllegalStateException().


11. Чем Set отличается от List?
    List допускает дубликаты
    Set имеет только уникальные значения


12. Расскажите про интерфейс Set
    Интерфейс Set расширяет интерфейс Collection
    Представляет набор уникальных элементов

    Реализации:
    - SortedSet - NavigableSet
    - AbstractSet - HashSet - LinkedHashSet
    - TreeSet


13. Что будет если добавлять элементы в TreeSet по возрастанию?
    Так как в основе TreeSet будет красное черное дерево, поэтому все элементы буду сбалансированы


14. Как устроен HashSet, сложность основных операций (16)
    - Реализует интерфейс Set
    - Базовой структурой для HashSet является HashTable
    - Повторяющиеся элементы не допускаются
    - порядок элементов не сохранится, так как для сохранения элементов происходит на основании хеш-кода


15. Как устроен LinkedHashSet сложность основных операций
    - Реализует интерфейс Set
    - Базовой структурой для LinkedHashSet является LinkedList
    - Порядок элементов будет сохранен
    - Повторяющиеся элементы не допускаются


16. Как устроен TreeSet сложность основных операций
    - Реализует интерфейс Set
    - Базовой структурой для TreeSet является TreeMap
    - Используется природный порядок элементов, основанный на Comparator


17. Расскажите про интерфейс List
    Интерфейс List расширяет интерфейс Collection
    Представляет собой список


18. Как устроен ArrayList сложность основных операций
    - Это список реализованный на основе массива
    - Доступ к элементу по индексу за константное время
    - Доступ к элементам по значению за линейное время
    - Вставка в конеч за константное время
    - Удаление из списка варьируется
    - Вставка элемента варьируется
    - необходимо одно единое пространство для хранения


19. Как устроен LinkedList сложность основных операций
    - Это двусвязный список, основанный на объектах с ссылками между ними
    - на получение элемента по индексу необходимо линейное время
    - На добавление и удаление потребуется константное время
    - На поиск позиции и вставки или удаления за константное время


20. Почему LinkedList реализует и List и Deque
    - LinkedList позволяет добавлять элементы в начало и в конец списка, что хорошо согласуется с Deque


21. Как перестроить Связанный список в HashTable
    Переопределить hashCode и использовать  "адрес в память"


22. Существуют ли какие-нибудь требованию к объектам, используемым в качестве ключа в HashMap?
    у них должен быть реализован метод для создания ключа и значения должны быть финализированы
    equals и hashCode


## END ---------------- Коллекции ----------------

## ---------------- База данных ----------------

1. В чем разница между Statement и PreparedStatement?
   Statement - не защищен
   PreparedStatement - переданные параметры защищены от sql инъекций


2. План исполнения запроса
   Пример Postgresql

   Explain [(OPTION [,...])]
    - Analyze [boolean] - запрос выполнится и составит план выполнения
    - Verbose [boolean] - добавит дополнительную информацию
    - Costs [boolean] - добавит стоимость каждого запроса
    - Buffer [boolean] - определяет число блоков с диска и из кеша
    - Timing [boolean] - Время запуска и время выполнения на каждом узле
    - Summary [boolean]
    - Fomat [TEXT|XML|JSON|YAML] - для подготовки отчета


3. Как работает индекс в таблице
    1. Таблица без индексов выглядит как куча (Heap). При запросе будет сканироваться вся таблица
    2. Преимущества индексов
       - Повышают скорость поиска информации и производительность запросов
    3. Недостатки
       - Требуют много места на диске и в оперативной памяти
       - Замедляют производительность системы (медленнее выполняются операции вставок, обновлений, удалений)
    4. Структура
       - Состоят из:
       - наборов страниц
       - узлов, имеющих древовидную структуру, иерархическую
       - Хранятся в виде сбалансированных B-деревьев
       - При создании индекса создаются указатели на строки таблицы, которые удовлетворяют условию
    5. Виды индексов
       - Составной (несколько колонок)
       - Функциональные или индекс по выражению
       - Обычный, по одной колонке
    6. Типы индексов
       - B-tree (дефолтное)
       - Hash - хранятся в 32-битной хеш код, полученный из значения индексируемого столбца
         Обрабатывает только простые сравнения равенства
       - Gist - это инфраструктура, в которой можно реализовать множество стратегий индексирования
       - Sp-gist - это инфраструктура, которая поддерживает различные виды поиска.
         Позволяет реализовать несбалансированные дисковые структуры данных
       - Gin - инвертированные индексы, которые подходят для данных, содержащих компонентные значения, например массивы
       - Brin - хранят сводки о значениях, хранящихся в последовательных диапазонах физических блоков таблицы


4. Блокировка таблицы
   Виды блокировок
    - Разделяемые (shared locks) - блокировка на чтение
    - Монолитные (exclusive locks) - блокировка на чтение и запись

   --- Табличная блокировка (exclusive lock)

   `Lock Tables`

   | +         | -      | 
   |---------------------|-----------------------------|
   | требуют небольшого объема памяти  | Отстуствует параллелизм   |
   | быстрая работа при блокировке большого количества таблиц     | Все остальные операции ждут |
   | быстрая работа при операциях Group by или при полном сканировании |   |
   | Подходит когда данные меняются редко                      |     |


   --- Пользовательская блокировка - конкретной строки
   ```SELECT GET_LOCK(‘key’, 10); - key & timeout```

| +         | -                                                                            | 
   |------------------------------------------------------------------------------|-----------------------------|
| одна блокировка для всех приложений  | Небезопасно использовать с репликацией на основе SQL-выражений               |
| Блокировка на уровне приложения | Из-за возможности вызвать сколько угодно lock опасность множества блокировок |
| Подобие транзакции |                                                                              |
| Меньше издержки чем у транзакции |                                                                              |


   ---Глобальная блокировка

   При применении
    - конфликтует с другими блокировками
    - Вызывает снятие всех предыдущих блокировок

| +         | -      | 
   |---------------------|-----------------------------|
| Для получения резервной копии  | Нужно быть аккуратным и знать что делать  |
| Эту команду использует для быстрого alter таблиц | Может быть довольно длительной, так как будет дожидаться выполнения всех Select запросов |
| не так затратна как полная остановка сервера, так как большая часть информации кешируется |   |
| Используется для восстановления |     |

   ---Построчные блокировка

| +         | -      | 
   |---------------------|-----------------------------|
| Лучшее управление конкуретным доступом  | Максимальные издержки |
| Позволяет одновременно выполнять несколько изменений одного ресурса | Приводит к взаимоблокировки |
| Позволяет заблокировать одну строку на долгое время | Работают медленнее табличных блокировок если используется большая часть таблицы|
| Меньше конфликтов блокировок |  Работают намного медленней при полном сканировании таблицы или для группировок Group by |


6. Транзакции
    - Каждая транзация начинается с инструкции
      Begin Transaction и заканчивается
      Commit или Rollback

    - Транзакция - это совокупность операций над базов, которые могут быть либо выполнены все вместе либо не будет выполенна ни одна из них

    - Транзакции основаны на многоверсионной модели (Multiversion Concurrency Control)
        - каждый Sql оператор видит так называемый снимок данных (snapshot)
        - Снимок - это не физическая копия всей базы, это несколько чисел, которые идентифицируют текущую транзакцию и те транзакции,
          которые уже выполнились в момент начала текущей

   **Свойства транзакий**
    - Атомарность - транзакция либо выполняется полностью, либо не выполняется совсем
    - Согласованность - после успешного выполнения транзакции база данных должны быть приведена из олного состояние в другое
    - Изолированность - Во время выполнения транзации другие транзакции должны оказывать минимальное влияние на нее
    - Долговечность - После успешной фиксации транзакции пользователь должен быть уверен, что данные надежно сохранены в базе данных

   **Риски**
   
      - _Потерянное обновление (lost update)_ - Когда разные транзакции одновременно изменяют ожни и те же данные, то после фиксации изменений может оказаться,
      что одна транзакция перезаписала другую
      - Грязное чтение (dirty read) - Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась.
      Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе
      - _Неповторяющиеся чтение (non-repeatable read)_ - При повторном чтении тех же данных в рамках одной транзакции оказывается, что другая транзакция успела изменить
      и зафиксировать эти данные
      - _Фантомное чтение (phantom read)_ - Транзакция выполняет сборку данных и параллельно другая транзакция добавляет строки
      - _Аномалия сериализации (serialization anomaly)_ - Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одной
      из возможных вариантов упорядочения этих транзакций

   **Уровни изоляции**

   - Read uncommitted (dirty read)
   - Read committed - только зафиксированные изменения
   - Repeatable read (phantom read) - видим вставленные записи
   - Serializable - самый безопасный


7. Пул соединений к БД
   Это шаблон доступа к данным, основной целью которого является снижение накладных расходов, связанных с выполнение подключений к бд

   Этапы соединения с БД
    - Открытие соединения с БД с помощью драйверов
    - Открытие TCP  сокетов для чтения/записи
    - Чтение/запись данных через сокет
    - Закрытие соединения
    - Закрытие порта

   Так как открытие соединения с БД это трудозатратная операция, мы можем настроить ряд соединений при старте приложения,
   которыми мы будем пользоваться в процессе


8. Функция vs Процедура

   **Функции**
    - Имеет возвращаемый тип и возвращаемое значение
    - Использование DML(insert, update,delete) запросов внутри функции невозможно.
      Разрешены только SELECT запросы
    - Не имеет выходных аргументов
    - Вызов хранимой процедуры из функции невозможен
    - Вызов функции внутри SELECT запросов возможен

```
   //создает или заменяют функцию с именем
   CREATE [or REPLACE] FUNCTION function_name
   (param_list)
   // возвращаемый тип
   RETURN return_type
   LANGUAGE plpgsql
   as
   $$
   // объявление переменных
   DECLARE
   -- variable declaration
   // начало запроса
   BEGIN
   -- logic
   // окончание запроса
   END;
   $$
```
   **Процедура**
   - Не имеет возвращаемого типа, но имеет выходные аргументы 
   - Использование DML запросов возможно 
   - Имеет входные и выходные аргументы 
   - Использование или управление транзакциями возможно в хранимой процедуре 
   - Вызов процедуры из SELECT запросов невозможен
```
   CREATE [or REPLACE] PROCEDURE procedure_name
   (param_list)
   LANGUAGE language_name
   AS
   $$
   -- stored-procedure-body
   $$
```
## END ---------------- База данных ----------------

## ---------------- Concurrency ----------------

1. В чем разница между sleep() и wait()?
   wait - освобождает монитор
   sleep- не освобождает монитор

## END ---------------- Concurrency ----------------

## ----------------- Spring ----------------

1. Что такое `Autowiring` и как работает
   **IOC** - Inversion of control
   делегирование части обязанностей внешнему компоненту

Бин - создаваемый Spring-ом объект класса, который можно внедрить в качестве значения поля в другой объект

ApplicationContext - Это сердце спринга. Как правило, он создается в самом начале работы приложения

По умолчанию каждый бин имеет внутриспринговое свойство 'scope' в значении 'singleton',
то есть создается ровно один экземпляр класса
```
Определение бина
ИЛИ В файле xml
<bean id="product" class="main.java.Product"></bean>
// Указание места сканирования
<context:component-scan base-package="main"/>
// Поднять контекст из файл xml
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml"))
```
Как работает
При поднятии контекста создается бин-объект всех объектов, которые помечены аннотациями '@Component', '@Service', '@Controller', '@Repository'
Когда спринг видит аннотацию @Autowired он начинает искать подходящий бин. Если бин только один, то он без проблем его инжектит

Аннотация `@Autowired` можно ставить
- На поле
- На сеттеры
- На определенные методы

Если оддинаковых бинов несколько
- Для определения конкретного бина необходимо использовать аннотацию '@Qualifier("dependency1") ServiceDependency'
- Для использования всех бинов
```
@Autowired
public void setDependency(ServiceDependency[] dependencies)
```

2. Плюсы и минусы `@Autowired`

| +  | -   | 
|-----|-----|
|  Требует меньше кода  | Менее экспрессивный, чем явное инжектирование |
|  Уменьшает время разработки | Усложняет автонаписание инструкций |
|    | Множетвенные инъекции могут пересекаться с названием конкруктора|

   **Ограничения**
   - Явные зависимости и аргументы конструктора и свойства всегда переписывают инъекции
   - Инъекции через констркутор всегда переписывают инекции свойств
   - Нельзя переписать примитивы
   - Сложно ориентироваться при большом количестве инъекций


4. В чём разница между @Component, @Service и @Repository аннотациями?
   **@Component** - универсальный компонент

   **@Repository** - компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.class
   умеет перехватывать спецефичные для платфомы исключения и повторно генерирует их как одно из унифицированных непроверенных исключений Spring

   **@Service** - фасад для некоторой бизнес логики

   **@Controller** - класс, в котором указываются контроллеры приложения
   Для получения объекта body внутри методов необходимо дополнительно использовать аннотацию @RequestBody
   Используется для возврата view
```
@Controller
@RequestMapping("books")
public class SimpleBookController {

    @GetMapping("/{id}", produces = "application/json")
    public @ResponseBody Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```
   **@RestController** - Это специализированная сервис контроллера. Включает в себя @Controller и @ResponseBody аннотации
   Необходим при написании REST запросов
```
@RestController
@RequestMapping("books-rest")
public class SimpleBookRestController {
    
    @GetMapping("/{id}", produces = "application/json")
    public Book getBook(@PathVariable int id) {
        return findBookById(id);
    }
    
    private Book findBookById(int id) {
        // ...
    }
}
```
   **@Configuration** - класс для настройки приложения


5. AOP
   Аспектно-ориентированное программирование - это парадигма программирования, являющейся в дальнейшем развитием процедурно и объектно-ориентированного программирования

   **Join Point** - это точки наблюдения, присоединения к коду, где планируется введение функциональности

```
@Pointcut("execution(* com.example.spring._10.AOP_order.dao.*.*(..)))")
public void forDaoPackage () {}
```
   **Pointcut** - Это срез, запрос точек присоединения

   **Advice**  - набор инстракций выполняемых на точках среза (может быть несколько для одного Pointcut)
   - Before - Перед вызовом метода
   - After - После вызовом метода
   - After returning - После возврата значения
   - After throwing - В случае exception
   - After finally - В случае выполения блока finally
   - Around - можно сделать пред, пост обработку перед вызовом метода, а также вообще обойти вызов метода

   **Aspect**
   модуль, в котором собраны описанные Pointcut и Advice


6. Spring boot
   В базе используется сервер Tomcat

   Без Spring Boot
    - Импортировать необходимые Spring-модули
    - Импортировать библиотеку web-контейнеров (в случае web-приложения)
    - Импортировать сторонние библиотеки (Hibernate, Jackson)
    - Искать версии, совместимые со Spring
    - Конфигурировать компонент DAO, такие как источник данных, управление транзакциями ит т.д.
    - Конфигурировать компоненты web-слоя, такие как диспетчер ресурсов, view resolver
    - Определить класс, который щагрузит все необходимые конфигурации

   Основные особенности
    1. Управленияе зависимостями
    2. Автоматическая конфигурация
    3. Встроенные контейнеры сервлетов

- Spring упаковывает необходимые сторонние зависимости для каждого типа приложения посредством starter-пакетов (spring-boot-starter-web, spring-boot-starter-data-jpa)
- Spring автоматически конфигурирует зарегистрированные бины в зависимости от подключенного стартера
- Каждое Spring-boot приложение включает встроенные web-сервлеты
  Spring ам настроивает контейнер сервлетов.
  Приложение может запускаться как jar-файл

Основной класс приложения

**@SpringBootApplication** - включает в себя
- @Configuration
- @EnableAutoConfiguration
- @ComponentScan


6. Hibernate ленивая инициализация (LazyInitialization)
   @OneToMany(fetch=FetchType.Lazy)

Для акцивации такой связи необходимо проверить било ли инициализировано
boolean success = Hibernate.isInitialized(products);

Инициализировать
Hibernate.initialize(post);


7. RestTemplate
```
@Bean
public RestTemplate restTemplate (RestTemplateBuilder builder) {
    return builder
        .setConnectTimeout(Duration.ofMills(3000))
        .setReadTimeout(Duration.ofMills(3000))
        .build();
}

@Bean
public RestTemplate restTemplate () {
    RestTemplate restTemplate = new RestTemplate();
    return restTemplate;
}
```

8. Как активировать/деактивировать Бин
   @Profile("dev")
   @Profile("production")

Добавляет возможность включать/выключать бины для разных окружений

В файлу 'application.properties'
spring.profiles.active=dev

Дополнительно в интерфейсе 'ConfigurableEnvironment' можно установить настройки активных профилей вызвав 'SpringApplication.setAdditionalProdiles(...)'


9. Spring Filters

   Для создания фильтры необходимо создать бин и заинжектить интерфейс 'Filter'
```
@Component
@Order(1)
public class TransactionFilter implements Filter {
    @Override
    public void doFilter (
        ServlerRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOExeprion, ServlerException {
        HTTPServlerRequest req = (HTTPServlerRequest) request;
        
        LOG.info("Staring a transaction for req: {}");
        
        req.getRequestURI();
        
        chain.doFilter(request, response);
        
        LOG.info("Commiting a transaction for req: {}");
        
        req.fetRequestURI();
    }
}
```
Мы можем извлечь

`url = req.getRequestURI();`

`method = req.getMethod();`

`contentType = res.getContentType();`

Регистрация бина
```
@Bean
public FilterRegistrationBean<RequestResponseLoggingFilter> loggingFilter () {
FilterRegistrationBean<RequestResponseLoggingFilter> registrationBean = new FilterRegistrationBean<>();

    registrationBean.setFilter(new RequestResponseLoggingFilter());
    registrationBean.addUrlPattern("users");
    registrationBean.setOrder(2);

    return registrationBean;
}
```

10. Как работает Spring изнутри

    **Ключевые понятия**
    - Бины - это обычный объект, который живет внутри DI-контейнера
    - DI-контейнер - Ключевой и фундаментальный механизм Spring.
    
    Спринт - это по сути набор бинов, связанных вместе через DI контейнер
    При конфигурации например 'OAuth' в 'application.properties' спринт предоставляет бин 'OAuth2RestTemplate'
    При этом этот бин при обращении к внешнему API будет знать, куда и как пойти, чтобы получить OAuth токен
    как его обновлять, в какое место нашего запроса его добавлять и т.д.
    То есть контейнер - это механизм общения между нашим кодом и библиотеками, подключенными к проекту

    Использование инъекций зависимостей не подразумевает создания интерфейсов для каждого компонента.

    - Контекст - Представлен интерфейсом 'ApplicationContext'. Позволяет реагировать на различные события,
      которые происходят внутри приложения, управлять жизненным циклом

    - Конфигурация - описание доступных бинов
      Бины могут быть описаны как в одном файле, так как и в разных

    - Сканирование компонентов - спринг сканирует приложений на предмет таких аннотаций как @Component, @Service и т.д. и создает из них бины
      при этом это считается неявным изменением контекста приложения

    **Spring boot**

    _Автоконфигурация_

    Это набор конфигурационных классов, которые создают и регистрируют определенные бины в приложении.
    Можно сказать, что сам Embedded Servler Container - это тоже еще один бин

    - Включается аннотацией '@EnableAutoConfiguration'
    - Работает в последнюю очередь, после регистрации пользовательских бинов
    - Принимает решение о конфигурации на основании доступных в classpath классов, свойств в 'application.properties'
    - Можно включать и выключать разные аспекты автоконфигурации
    - Всегда отдает приоритет пользовательским бинам

    **Условия и порядок регистрации бинов**

    Логика при регистрации бинов управляется набором `@ConditionalOn*` аннотаций 
    Можно указать, чтобы быин создавался при наличии в classpath (@ConditionalOnClass), 
    наличии существующего бина (@ConditionalOnBean), отсутствии бина (@ConditionalOnMissingBean)

    ```
    @SpringBootApplication
    public class DemoApplication {
        public static void main(String[] args) {
            SpringApplication.run(DemoApplication.class, args);
        }
    }
    ```
    1. **@SpringBootApplication** - мета аннотация, алиас для нескольких аннотаций
    - @SpringBootConfiguration
    - @EnableAutoConfiguration
    - @ComponentScan

    1. **SpringApplication.run()**
        это хелпер, который используя список предоставленных конфигураций создает 'ApplicationContext',
        конфигурирует его, выводит баннер в консоли и засекает время старта приложения

    2. **AnnotationConfigEmbeddedWebApplicationContext** - Наследник Spring Boot
        знает о embedded servlet container-ах и умеет их запускать

    3. **@EnableAutoConfiguration** - включает автоконфигурацию
    ```
    @Import(EnableAutoConfigurationImportSelector.class)
        public @interface EnableAutoConfiguration {
        ...
    }
    ```

    `EnableAutoConfigurationImportSelector` - это конфигурация, которая добавит несколько бинов в контекст.
    Этот класс не объявляет бины сам, а использует так называемые фабрики.
    Класс смотрит в файл 'spring.factories' и загружает оттуда список значений, которые являются именами классов ((авто)конфигураций),
    которые Spring Boot импортирует

    **Этапы инициализации**

    1. Парсирование конфигурациии создание 'BeanDefinition'
    Задача данного этапа - это создание всех 'BeanDefinition'.
    'BeanDefinition' - это специальный интерфейсы, через который можно получить доступ к метаданным будущего бина

    2. Настройка созданных 'BeanDefinition'
      После первого этапа у нас имеется Map, в котром хранятся 'BeanDefinition'
      Спринт дает нам возможность повлиять на то, какими будут наши бины еще до их создания,
      то есть мы можем получить доступ к метаданным класса.
      Для получения доступа к метаданным есть специальный интерфейс 'BeanFactoryPostProcessor'
    ```
    public interface BeanFactoryPostProcessor {
    `void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;
    }
    ```
    Данная фабрика содержит такие методы как 'getBeanDefinitionNames', через который можно получить все 'BeanDefinitionNames',
    а потом по конкретному имени получить 'BeanDefinition' для дальнейшей обработки метаданных

    Например, если в классе есть поля, которые должны быть заполнены из файла '.propeties' 
       то после постпроцессинга они будут добавлены к класс бина

    3. Создание экземпляров бинов
      Созданием экземпляров бинов занимается 'BeanFactory' при этом можно дерегировать это кастомным 'FactoryBean'
      Экземпляры бинов создаются на основе ранее созданных 'BeanDefinition'
      После создания бина он добавляется в Map<BeanName, Bean>

    4. Настройка созданных бинов
      Интерфейс 'BeanPostProcessor' позволяет вклиниться в процесс настройки бинов, до того как они попадут в контейнер
    ```
    public interface BeanPostProcessor {
      Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // до init метода
      Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; // после init метода
    }
    ```

    * Если нужно сделать прокси над объектом, то лучше это делать в `postProcessAfterInitialization`
    * `BeanPostProcessor` обязательно должен быть бином

11. Как создать свой 'spring-boot-starter'


## END ----------------- Spring -----------------

## ----------------- Stream -----------------

1. Стримы Общее
    1. Stream из массива
       Arrays.stream(array)

    2. Stream из ArrayList
       list.stream()

    3. Stream из Map
       map.entrySet.stream()

    4. Stream из указанных элементов
       Stream.of("1", "2", "3")

    5. Лист из указанных элементов
       Arrays.asList("a1", "a2", "a3").stream()

    6. Стрим из файла
       Files.lines(Paths.get("file.txt"))

    7. Стрим из строки
       "123".chars()

    8. Создание из Stream.builder
       Stream.builder().add("a1").add("a2").add("a3").build()

    9. Создание параллельного стрима
       collection.parallelStream()

    10. Создание бесконечного стрима
        Stream.iterate(1, n -> n +1)

    11. Создание бесконечных стримов с помощью
        Stream.generate(() -> "a1"))

   Методы
   1. Конвейерные - возвращают другой stream, то есть работают как builder
   2. Терминальные - Возвращают другой объект, такой как коллекция, примитивы, объекты, Optional

        ! У стрима может быть сколько угодно вызовов конвейерных методов  и в конце один терминальный
        При этом все конвеейрные методы выполняются лениво и пока не будет вызван терминальный, никаких действий не происходит

```
Конвейерные методы
   'filter'
   collection.stream()
    .filter("a1"::equals)
    .count()

    'skip' - позволяет пропускать первые N элементов
    collection.stream()
        .skip(collection.size() - 1)
        .findFirst()
        .orElse("1")

    'distinct' - возвращает стрим без дубликатов
    collection.stream()
        .distinct()
        .collect(Collectors.toList())

    'map' - преобразует каждый элемент массива
    collection.stream()
        .map((s) -> s + "_1")
        .collect(Collectors.toList())

    'peek' - возвращает тот же стрим, но применяет функцию к каждому элементу
    collection.stream()
        .map(String::toUpperCase)
        .peek((e) -> System.out.println("," + e))
        .collect(Collectors.toList())

    'limit' - ограничивает выборку определенным количеством элементов
    collection.stream()
        .limit(2)
        .collect(Collectors.toList())

    'sorted' - позволяет сортировать значения либо в натуральном порядке либо задавая Comparable
    collection.stream()
        .sorted()
        .collect(Collectors.toList())

    'mapToInt' - аналог map, но возвращает числовой стрим
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .toArray()

    'mapToDouble'
    'mapToLong'

    'flatMap' - похоже на map, о может создавать из одного элемента несколько
    'flatMapToInt'
    'flatMapToDouble'
    'flatMapToLong'

    collection.stream()
        .flatMap((p) -> Arrays.asList(p.split(",").stream()))
        .toArray(String[]::new)

    'reduce' - позволяет выполнять агрегатные функции на всей коллекцией, возвращает одно значение для стрима (Optional)
    collection.stream()
    .reduce((s1, s2) -> s1 + s2)
    .orElse(0)
```
```
Терминальные методы

    'findFirst' - возвращает первый элемент из стрима (Возвращает Optional)
    collection.stream()
        .findFirst()
        .orElse("1")

    'findAny' - возвращает плюбой подходящий элемент из стрима (Возвращает Optional)
    collection.stream()
        .findAny()
        .orElse("1")

    'collect' - представление результатов в виду коллекций и других структур данных
    collection.stream()
        .filter((s) -> s.contains("1"))
        .collect(Collectors.toList())

    'anyMatch' - возвращает true если условие выполняется хотя бы для одного значения
    collection.stream()
        .anyMatch("a1"::equals)

    'count' - возвращает количество элементов в стриме
    collection.stream()
        .filter((s) -> s.contains("1"))
        .count()

    'noneMatch' - возвращает true если условие не выполняется ни для одного элемента
    collection.stream()
        .noneMatch((s) -> s.contains("1"))

    'allMatch' - возвращает true если условие выполняется для всех элементов
    collection.stream()
        .allMatch((s) -> s.contains("1"))

    'min' - возвращает минимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .min(String::compareTo)
        .get()

    'max' - возвращает максимальный элемент, в качестве условия используется компаратор
    collection.stream()
        .max(String::compareTo)
        .get()

    'forEach' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
    set.stream()
        .forEach((p) -> p.append("_1"))

    'forEachOrdered' - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении гарантируется
    list.stream()
        .forEachOrdered((p) -> p.append("_1"))

    'toArray' - возвращает массив значений стрима
    collection.stream()
        .map(String::toUpperCase)
        .toArray(String[]::new)
```
```
Дополнительные методы числовых стримов

    'sum' - Возвращает сумму чисел
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .sum()

    'average' - Возвращает среднее арифметическое
    collection.stream()
        .mapToInt((s) -> Integer.parseInt(s))
        .average()

    'mapToObj' - Преобразует числовой стрим обратно в объект
    Stream.mapToObj((id) -> new Key(id))
        .toArray()
```
```
Другие методы
   'isParallerl' - Узнать является ли стрим параллельным

    'parallel' - Вернуть параллельный стрим, если стрим уже параллельный, то может вернуть самого себя
    
    collection.stream()
        .peek(...) // операция последовательная
        .parallel()
        .map(...) // операция мождет выполняться параллельно
        .sequential()
        .reduce(...) // операция снова последовательна
```

2. Collectors
   Методы статаические

   `toList` - Представляет стрим в виде списка
   `toCollection` - Представляет стрим в виде коллекции
   `toSet` - Представляет стрим в виде множества

   `toConcurrentMap` - Преобразовывает стрим в Map
   `toMap` - Преобразовывает стрим в Map

   `averagingInt` - Среднее значение
   `averagingDouble`
   `averagingLong`

   `summingInt` - Возвращает сумму
   `summingDouble`
   `summingLong`

   `partitioningBy` - разделяет коллекцию на две части по соответствующему условию
   и возвращает как Map<Boolean, List>

   `groupingBy` - разделяет коллекцию на несколько частей и возвращает Map<N, List<T>>

   `mapping` - дополнительные преобразования значений для сложных Collector-ов

```
strings.stream()
    .collect(Collectors.joining(" "), "<b>", "</b>")

string.stream()
    .collect(Collectors.groupingBy((p) -> p.substring(0, 1)))
```

3. Функциональный интерфейсы

`Predicate`(filter) - означает, что он будет пропускать только те элементы, которые возвращают true
```
public static void main(String[] args) {
    List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8)
        .filter(x -> x % 2==0)
        .collect(Collectors.toList());
}
```

`Consumer`(peek, forEach)
```
public static void main(String[] args) {
    List<String> peopleGreetings = Stream.of("Elena", "John", "Alex", "Jim", "Sara")
        .peek(x -> System.out.println("Hello " + x + " !!!"))
        .collect(Collectors.toList());
}
```
`Supplier`(generate)
```
public static void main(String[] args) {
    ArrayList<String> nameList = new ArrayList<>();
    nameList.add("Elena");
    nameList.add("John");
    nameList.add("Alex");
    nameList.add("Jim");
    nameList.add("Sara");
    
    Stream.generate(() -> {
        int value = (int) (Math.random() * nameList.size());
        return nameList.get(value);
    }).limit(5).forEach(System.out::println);
}
```
`Function`(map)
```
public static void main(String[] args) {
    List<Integer> values = Stream.of("32", "43", "74", "54", "3")
        .map(x -> Integer.valueOf(x)).collect(Collectors.toList());
}
```
`UnaryOperator`(iterate)

1. Элемент, с котрого начинается генерация
2. Указывает принцип генерации новых элементов
```
public static void main(String[] args) {
    Stream.iterate(9, x -> x * x)
        .limit(4)
        .forEach(System.out::println);
}
```

3. Меняет ли начальные данные stream?
   нет

## END ---------------- Stream ----------------

## ---------------- SOLID ----------------

- Single Responsibility Principle (Принцип единственной ответственности).
- Open Closed Principle (Принцип открытости/закрытости).
- Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
- Interface Segregation Principle (Принцип разделения интерфейса).
- Dependency Inversion Principle (Принцип инверсии зависимостей).

'Single Responsibility Principle' - никогда не должно быть больше одной причины изменить класс.

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс

Пример:
    Представьте себе модуль, который обрабатывает заказы.
    Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа

Данный класс протировечит SRP так как он отвечает за 3 обязанности.
В идеале это должны быть 3 отдельных класса, каждый из которых отвечает за свою область

`Open Closed Principle` - программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
Должна быть возможность изменять внешнее поведеление класс, не внося физические изменения в сам класс.
Класс должны разрабатываться так, чтобы для поднастройки класс к конкретным условиям применения было доставточно расширить его или переопределить некоторые функции

`Liskov’s Substitution Principle` - объекты в программе можно заменить их наследниками без изменения свойств программы.
Класс, разработанный путем расширения на основании базового класса, должен переопределять его метода так, чтобы не нарушалась функциональность
с точки зрения клиента. То есть не должно меняться ожидаемое поведение

`Interface Segregation Principle` - клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
Слишком "толстые" интерфейсы необходимо разделять на более мелкие, спецефические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе

`Dependency Inversion Principle` - зависимости внутри системы строятся на основе абстракций.
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономны и соединялись друг с другом с помощью абстракций

## END ---------------- SOLID ----------------

## ---------------- Java 8 ----------------

1. Методы интерфейсов по умолчанию
```
interface Formula {
    double calculate(int a);
    
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```
2. Лямбда-выражения
```
Collections.sort(names, (String a, String b) -> {
    return b.compareTo(a);
});
```
3. Функциональные интерфейсы
```
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
4. Ссылки на методы и конструкторы
```
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);
```
5. Области действия лямбд
   Лямбды могут ссылаться на переменные, обхявленные как final, на экземплярные поля класса и статические переменные
```
final int num = 1;
Converter<Integer, String> stringConverter = (from) -> String.valueOf(from + num);

stringConverter.convert(2);
```
переменная num не обязательно должна быть final, но должна быть неизменяемой

6. Доступ к полям и статическим переменным

7. Доступ к методам интерфейсом по умолчанию
   Внутри лямбда-выражений запрещено обращаться к методам по умолчанию

8. Stream

9. Апи для работы с датами
    - Clock
    - Часовые пояса
    - LocalTime
    - LocalDate
    - LocalDateTime

10. Аннотации
    @Repeatable

## END ---------------- Java 8 ----------------

    26. Можно ли увеличить размер массива после его инициализации?
    нет, только пересоздать новый массив


    27. Как создать собственный иммутабельный класс?
final и без геттеров