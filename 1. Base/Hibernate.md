
+ [1. Проблема несоответствия](#проблема-несоответствия)
+ [2. Что такое Hibernate](#2-что-такое-hibernate)
+ [3. Многоуровневая архитектура](#3-многоуровневая-архитектура)
+ [4. Создание классов с возможностью сохранения]()
+ [5. Реализация связей между объектами]()
+ [6. Метаданные]()

## 1. Проблема несоответствия

+ [Проблема детализации](#проблема-детализации)
+ [Проблема подтипов](#проблема-подтипов)
+ [Проблема идентичности](#проблема-идентичности)
+ [Проблемы, связанные с ассоциациями](#проблемы-связанные-с-ассоциациями)
+ [Проблема навигации по данным](#проблема-навигации-по-данным)

### Проблема детализации
Есть таблица `User`, в которую необходимо добавить информацию об адресе
Тут встает проблема:
- Добавить несколько столбцов (город, улица, номер дома и т.д.)
- Добавить один столбец

Хотелось бы иметь возможность создать новый тип в рамках таблице, как например:
```sql
create table USER (
    USERNAME varchar(15) not null primary key,
    ADDRESS address not null
)
```

Вариат решения:
```sql
create table USERS (
    USERNAME varchar(15) not null primary key,
    ADDRES_STREET varchar(255) not null,
    ADDRESS_ZIPCODE varchar(5) not null,
    ADDRESS_CITY varchar(255) not null
)
```

### Проблема подтипов
Мы хотим иметь возможность оплаты несколькими способами.
У нас есть суперкласс BilingDetails и его наследники CreditCard, BandAccount

Базы данных как правило не поддерживают табличного наследования


### Проблема идентичности
В Java определяется два понятия тождественности:
- Идентичность экземпляров (a == b)
- Равенство экземпляров, определяемое методом equals()

В базе данных идентичность определяется при помощи сравнения первичных ключей
Поэтому желательно всегда иметь скрытый идентификатор, при помощи которого будет просиходит сопоставление
```sql
CREATE table USERS (
    ID bigint ot null primaty key,
    USERNAME varchar(15) not null unique
   ...
)
```

### Проблемы, связанные с ассоциациями
В объектно-ориентированных языках ассоциации представлены объектными ссылками

Реализация многие ко многим
```java
public class User {
  Set billingDetails;
}

public class BillingDetails {
  Set users;
}
```

Для реализации многие ко многим в БД необходима создать новую таблицу ссылок
```sql
create table USER_BILLINGDETAILS (
    USER_ID bigint,
    BILLINGDETAILS_ID bigint,
    primary key (USER_ID, BILLINGDETAILS_ID),
    foreign key (USER_ID) references USERS,
    foreign key (BILLINGDETAILS_ID) references BILLINGDETAILS
)
```

### Проблема навигации по данным
Для навигации по данным в Java используется iterator

Для последовательного извлечения данных из бд необходимо делать множество запросов, что не оптимально
Именно из-за данной проблемы появляется проблема n+1


## 2. Что такое Hibernate

- Hibernate ORM - состоит из ядра, базовой службы зранения для баз данных SQL и оригинального API
- Hibernate EntityManager - реализация стандартного Java Persistence API, дополнительный модуль пверх Hibernate ORM
- Hibernate Validator - эталонная реализация спецификации Bean Validation. Обеспечивает проверку классов предметной модели
- Hibernate Evers - целями Evers явяются ведение журнала событий и хранение нескольких версий данных в базе данных SQL. Позволяет хранить испторию изменения данных и событий
- Hibernate Search - Позволяет создавать запросы к базе данных, используя мощный и естественно интегрированный API
- Hibernate OGM - реализация объектно-сеточного отображения. Предоставляет поддержку JPA для NoSQL-решений, используя ядро движка Hibernate


## 3. Многоуровневая архитектура

Подчиняется правилам:</br>
- Передача информации осуществляется сверху вниз. Каждый уровень зависит только от интерфейса того уровня, который находится непосредственно перед ним
- Каждый уровень ничего не знает о других уровнях

Уровень представления</br>
    Пользовательский интерфейс. Код, отвечающий за управление страницей, навигацию
        
Уровень бизнес-логики</br>
    Конкретные формы зависят от приложения. Отвечает за реализацию любых бизнес-правил или системных требований, которые воспринимаются пользователем как относящиеся к предметной области

Уровень хранения</br>
    Уровень длительного хранения данных состоит из набора классов и компонентов, ответственных за сохранение и извлечение данных из одного или нескольких хранилищ.

Базы данных</br>
    Как правило является внешней и используется несколькими приложениями.


## 4. Создание классов с возможностью сохранения

1. Если имя пользователя хранится в базе данных в одном столбце `NAME`
Следующий пример не является ошибкой
```java
public class User {
  protected String firstName;
  protected String lastname;

  public String getName() {
    return firstname + ' ' + lastname;
  }
  
  public void setName(String name) {
    StringTokenizer t = new StringTokenizer(name);
    firstname = t.nextToken();
    lastname = t.nextToken();
  }
}
```

2. Для коллекций проверяется идетичность.
Для свойства, представляющего хранимую коллекцию, метод чтения должен возвращать ту же коллекцию, которую Hibernate передал в метод записи
```java
protected String[] names = new String[0];
public void setNames(List<String> names) {
  this.names = names.toArray(new String[names.size()]);
}
public List<String> getNames() {
  return Arrays.asList(names); // так делать нельзя
}
```

## 5. Реализация связей между объектами

+ [1. Многие к одному]()

### 1. Многие к одному
bidirectional навигация
```java
public class Bid {
    protected Item item;
    
    public Item getItem() {
        return item;
    }

    public void setItem(Item item) {
      this.item = item;
    }
}

public class Item {
  protected Set<Bid> bids = new HashSet<Bid>();

  public Set<Bid> getBids () {
    return bids;
  }

  public void setBids (Set<Bid> bids) {
    this.bids = bids;
  }
}
```

Способ привязки предложения цены (Bid) к товару (Item)
```java
anItem.getBids().add(aBid); // (1)
aBid.setItem(anItem); // (2)
```
1. Добавить экземпляр `Bid` в коллекцию `bids` объекта Item
2. Установить свойство `Item` жкземпляра `bid`


## 6. Метаданные

Стандартные аннотации JPA можно найти в пакете `javax.persistence`
При использовании аннотации `@Entity` все атрибуты класса автоматически становятся хранимыми, при использовании стратегии по умолчанию

Аннотации типобезопасны, и метаданные JPA включаются в файлы скомпилированных классов. 
Во время запуска приложения Hibernate читает классы и метаданные, используюя механизм рефлекции Java

